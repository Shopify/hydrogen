[
  {
    "name": "Analytics.CartView",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Publishes a `cart_viewed` event to the `Analytics.Provider` component.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\n\nexport default function CartView() {\n  return (\n    &lt;div className=\"cart\"&gt;\n      &lt;h1&gt;Cart&lt;/h1&gt;\n      &lt;Analytics.CartView /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\n\nexport default function CartView() {\n  return (\n    &lt;div className=\"cart\"&gt;\n      &lt;h1&gt;Cart&lt;/h1&gt;\n      &lt;Analytics.CartView /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsCartViewGeneratedType",
        "typeDefinitions": {
          "AnalyticsCartViewGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "name": "AnalyticsCartViewGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "BasicViewProps",
                "filePath": "src/analytics-manager/AnalyticsView.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsView.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function AnalyticsCartView(props: BasicViewProps) {\n  return <AnalyticsView {...props} type=\"cart_viewed\" />;\n}"
          },
          "BasicViewProps": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "BasicViewProps",
            "value": "{\n  data?: OtherData;\n  customData?: OtherData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          }
        }
      }
    ]
  },
  {
    "name": "Analytics.CollectionView",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Publishes a `collection_viewed` event to the `Analytics.Provider` component.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\nimport {Analytics} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json({\n    collection: {\n      id: '123',\n      title: 'ABC',\n      handle: 'abc',\n    },\n  });\n}\n\nexport default function Collection() {\n  const {collection} = useLoaderData();\n  return (\n    &lt;div className=\"collection\"&gt;\n      &lt;h1&gt;{collection.title}&lt;/h1&gt;\n      &lt;Analytics.CollectionView\n        data={{\n          collection: {\n            id: collection.id,\n            handle: collection.handle,\n          },\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\nimport {Analytics} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json({\n    collection: {\n      id: '123',\n      title: 'ABC',\n      handle: 'abc',\n    },\n  });\n}\n\nexport default function Collection() {\n  const {collection} = useLoaderData&lt;typeof loader&gt;();\n  return (\n    &lt;div className=\"collection\"&gt;\n      &lt;h1&gt;{collection.title}&lt;/h1&gt;\n      &lt;Analytics.CollectionView\n        data={{\n          collection: {\n            id: collection.id,\n            handle: collection.handle,\n          },\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsCollectionViewGeneratedType",
        "typeDefinitions": {
          "AnalyticsCollectionViewGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "name": "AnalyticsCollectionViewGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "CollectionViewProps",
                "filePath": "src/analytics-manager/AnalyticsView.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsView.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function AnalyticsCollectionView(props: CollectionViewProps) {\n  return <AnalyticsView {...props} type=\"collection_viewed\" />;\n}"
          },
          "CollectionViewProps": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionViewProps",
            "value": "{\n  data: CollectionPayload;\n  customData?: OtherData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "CollectionPayload",
                "description": ""
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          },
          "CollectionPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionPayload",
            "value": "{\n  collection: CollectionPayloadDetails;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "collection",
                "value": "CollectionPayloadDetails",
                "description": ""
              }
            ]
          },
          "CollectionPayloadDetails": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionPayloadDetails",
            "value": "{\n  /** The collection id. */\n  id: string;\n  /** The collection handle. */\n  handle: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "handle",
                "value": "string",
                "description": "The collection handle."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The collection id."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Analytics.CustomView",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Publishes a custom page view event to the `Analytics.Provider` component. The `type` prop must be preceded by `custom_`.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\n\nexport default function Promotion() {\n  return (\n    &lt;div className=\"promotion\"&gt;\n      &lt;h1&gt;Promotion page&lt;/h1&gt;\n      &lt;Analytics.CustomView\n        type=\"custom_promotion_viewed\"\n        data={{\n          promotion: {\n            id: '123',\n          },\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\n\nexport default function Promotion() {\n  return (\n    &lt;div className=\"promotion\"&gt;\n      &lt;h1&gt;Promotion page&lt;/h1&gt;\n      &lt;Analytics.CustomView\n        type=\"custom_promotion_viewed\"\n        data={{\n          promotion: {\n            id: '123',\n          },\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsCustomViewGeneratedType",
        "typeDefinitions": {
          "AnalyticsCustomViewGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "name": "AnalyticsCustomViewGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "CustomViewProps",
                "filePath": "src/analytics-manager/AnalyticsView.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsView.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function AnalyticsCustomView(props: CustomViewProps) {\n  return <AnalyticsView {...props} />;\n}"
          },
          "CustomViewProps": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomViewProps",
            "value": "{\n  type: typeof AnalyticsEvent.CUSTOM_EVENT;\n  data?: OtherData;\n  customData?: OtherData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "`custom_${string}`",
                "description": ""
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          }
        }
      }
    ]
  },
  {
    "name": "Analytics.Provider",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Provides a context for tracking page views and cart events to send as analytics data to Shopify. This component is integrated with the Customer Privacy API for consent management. The provider can also be used to connect third-party analytics services through its subscribe and publish system. The [`useAnalytics`](/docs/api/hydrogen/2024-07/hooks/useanalytics) hook provides access to the analytics provider context.\n\nYou can also listen to a `document` event for `shopifyCustomerPrivacyApiLoaded`. It will be emitted when the Customer Privacy API is loaded.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Analytics, getShopAnalytics} from '@shopify/hydrogen';\nimport {defer} from '@shopify/remix-oxygen';\nimport {Outlet, useLoaderData} from '@remix-run/react';\n\nexport async function loader({context}) {\n  const {cart, env} = context;\n  const cartPromise = cart.get();\n\n  return defer({\n    cart: cartPromise,\n    shop: getShopAnalytics(context),\n    consent: {\n      checkoutDomain: env.PUBLIC_CHECKOUT_DOMAIN,\n      storefrontAccessToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      withPrivacyBanner: true, // false stops the privacy banner from being displayed\n      // localize the privacy banner\n      country: context.storefront.i18n.country,\n      language: context.storefront.i18n.language,\n    },\n  });\n}\n\nexport default function App() {\n  const data = useLoaderData();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Analytics.Provider\n          cart={data.cart}\n          shop={data.shop}\n          consent={data.consent}\n        &gt;\n          &lt;Outlet /&gt;\n        &lt;/Analytics.Provider&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Analytics, getShopAnalytics} from '@shopify/hydrogen';\nimport {defer, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {Outlet, useLoaderData} from '@remix-run/react';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const {cart, env} = context;\n  const cartPromise = cart.get();\n\n  return defer({\n    cart: cartPromise,\n    shop: getShopAnalytics({\n      storefront: context.storefront,\n      publicStorefrontId: env.PUBLIC_STOREFRONT_ID,\n    }),\n    consent: {\n      checkoutDomain: env.PUBLIC_CHECKOUT_DOMAIN,\n      storefrontAccessToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      withPrivacyBanner: true, // false stops the privacy banner from being displayed\n      // localize the privacy banner\n      country: context.storefront.i18n.country,\n      language: context.storefront.i18n.language,\n    },\n  });\n}\n\nexport default function App() {\n  const data = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Analytics.Provider\n          cart={data.cart}\n          shop={data.shop}\n          consent={data.consent}\n        &gt;\n          &lt;Outlet /&gt;\n        &lt;/Analytics.Provider&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsProviderProps",
        "typeDefinitions": {
          "AnalyticsProviderProps": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AnalyticsProviderProps",
            "value": "{\n  /** React children to render. */\n  children?: ReactNode;\n  /** The cart or cart promise to track for cart analytics. When there is a difference between the state of the cart, `AnalyticsProvider` will trigger a `cart_updated` event. It will also produce `product_added_to_cart` and `product_removed_from_cart` based on cart line quantity and cart line id changes. */\n  cart: Promise<CartReturn | null> | CartReturn | null;\n  /** An optional function to set wether the user can be tracked. Defaults to Customer Privacy API's `window.Shopify.customerPrivacy.analyticsProcessingAllowed()`. */\n  canTrack?: () => boolean;\n  /** An optional custom payload to pass to all events. e.g language/locale/currency. */\n  customData?: Record<string, unknown>;\n  /** The shop configuration required to publish analytics events to Shopify. Use [`getShopAnalytics`](/docs/api/hydrogen/2024-07/utilities/getshopanalytics). */\n  shop: Promise<ShopAnalytics | null> | ShopAnalytics | null;\n  /** The customer privacy consent configuration and options. */\n  consent: Consent;\n  /** @deprecated Disable throwing errors when required props are missing. */\n  disableThrowOnError?: boolean;\n  /** The domain scope of the cookie set with `useShopifyCookies`. **/\n  cookieDomain?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "canTrack",
                "value": "() => boolean",
                "description": "An optional function to set wether the user can be tracked. Defaults to Customer Privacy API's `window.Shopify.customerPrivacy.analyticsProcessingAllowed()`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Promise<CartReturn | null> | CartReturn | null",
                "description": "The cart or cart promise to track for cart analytics. When there is a difference between the state of the cart, `AnalyticsProvider` will trigger a `cart_updated` event. It will also produce `product_added_to_cart` and `product_removed_from_cart` based on cart line quantity and cart line id changes."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "ReactNode",
                "description": "React children to render.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "consent",
                "value": "Consent",
                "description": "The customer privacy consent configuration and options."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cookieDomain",
                "value": "string",
                "description": "The domain scope of the cookie set with `useShopifyCookies`. *",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "Record<string, unknown>",
                "description": "An optional custom payload to pass to all events. e.g language/locale/currency.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "disableThrowOnError",
                "value": "boolean",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Disable throwing errors when required props are missing."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "Promise<ShopAnalytics | null> | ShopAnalytics | null",
                "description": "The shop configuration required to publish analytics events to Shopify. Use [`getShopAnalytics`](/docs/api/hydrogen/2024-07/utilities/getshopanalytics)."
              }
            ]
          },
          "CartReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartReturn",
            "value": "Cart & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "Consent": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Consent",
            "value": "Partial<\n  Pick<\n    CustomerPrivacyApiProps,\n    'checkoutDomain' | 'storefrontAccessToken' | 'withPrivacyBanner' | 'country'\n  >\n> & {language?: LanguageCode}",
            "description": ""
          },
          "CustomerPrivacyApiProps": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerPrivacyApiProps",
            "value": "{\n  /** The production shop checkout domain url.  */\n  checkoutDomain: string;\n  /** The storefront access token for the shop. */\n  storefrontAccessToken: string;\n  /** Whether to load the Shopify privacy banner as configured in Shopify admin. Defaults to true. */\n  withPrivacyBanner?: boolean;\n  /** Country code for the shop. */\n  country?: CountryCode;\n  /** Language code for the shop. */\n  locale?: LanguageCode;\n  /** Callback to be called when visitor consent is collected. */\n  onVisitorConsentCollected?: (consent: VisitorConsentCollected) => void;\n  /** Callback to be call when customer privacy api is ready. */\n  onReady?: () => void;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "checkoutDomain",
                "value": "string",
                "description": "The production shop checkout domain url."
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "Country code for the shop.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "LanguageCode",
                "description": "Language code for the shop.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onReady",
                "value": "() => void",
                "description": "Callback to be call when customer privacy api is ready.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVisitorConsentCollected",
                "value": "(consent: VisitorConsentCollected) => void",
                "description": "Callback to be called when visitor consent is collected.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storefrontAccessToken",
                "value": "string",
                "description": "The storefront access token for the shop."
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withPrivacyBanner",
                "value": "boolean",
                "description": "Whether to load the Shopify privacy banner as configured in Shopify admin. Defaults to true.",
                "isOptional": true
              }
            ]
          },
          "VisitorConsentCollected": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VisitorConsentCollected",
            "value": "{\n  analyticsAllowed: boolean;\n  firstPartyMarketingAllowed: boolean;\n  marketingAllowed: boolean;\n  preferencesAllowed: boolean;\n  saleOfDataAllowed: boolean;\n  thirdPartyMarketingAllowed: boolean;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "analyticsAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "firstPartyMarketingAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "marketingAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "preferencesAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "saleOfDataAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "thirdPartyMarketingAllowed",
                "value": "boolean",
                "description": ""
              }
            ]
          },
          "PrivacyBanner": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PrivacyBanner",
            "value": "{\n  /* Display the privacy banner */\n  loadBanner: (options?: Partial<CustomerPrivacyConsentConfig>) => void;\n  /* Display the consent preferences banner */\n  showPreferences: (options?: Partial<CustomerPrivacyConsentConfig>) => void;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "loadBanner",
                "value": "(options?: Partial<CustomerPrivacyConsentConfig>) => void",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "showPreferences",
                "value": "(options?: Partial<CustomerPrivacyConsentConfig>) => void",
                "description": ""
              }
            ]
          },
          "CustomerPrivacyConsentConfig": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerPrivacyConsentConfig",
            "value": "{\n  checkoutRootDomain: string;\n  storefrontRootDomain?: string;\n  storefrontAccessToken: string;\n  country?: CountryCode;\n  /** The privacyBanner refers to `language` as `locale`  */\n  locale?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "checkoutRootDomain",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "LanguageCode",
                "description": "The privacyBanner refers to `language` as `locale`",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storefrontAccessToken",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storefrontRootDomain",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "ShopAnalytics": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopAnalytics",
            "value": "{\n  /** The shop ID. */\n  shopId: string;\n  /** The language code that is being displayed to user. */\n  acceptedLanguage: LanguageCode;\n  /** The currency code that is being displayed to user. */\n  currency: CurrencyCode;\n  /** The Hydrogen subchannel ID generated by Oxygen in the environment variable. */\n  hydrogenSubchannelId: string | '0';\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "acceptedLanguage",
                "value": "LanguageCode",
                "description": "The language code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currency",
                "value": "CurrencyCode",
                "description": "The currency code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hydrogenSubchannelId",
                "value": "string | '0'",
                "description": "The Hydrogen subchannel ID generated by Oxygen in the environment variable."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shopId",
                "value": "string",
                "description": "The shop ID."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Analytics.ProductView",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Publishes a `product_viewed` event to the `Analytics.Provider` component.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\nimport {Analytics} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json({\n    product: {\n      id: '123',\n      title: 'ABC',\n      vendor: 'abc',\n      selectedVariant: {\n        id: '456',\n        title: 'DEF',\n        price: {\n          amount: '100',\n        },\n      },\n    },\n  });\n}\n\nexport default function Product() {\n  const {product} = useLoaderData();\n  const {selectedVariant} = product;\n\n  return (\n    &lt;div className=\"product\"&gt;\n      &lt;h1&gt;{product.title}&lt;/h1&gt;\n      &lt;Analytics.ProductView\n        data={{\n          products: [\n            {\n              id: product.id,\n              title: product.title,\n              price: selectedVariant?.price.amount || '0',\n              vendor: product.vendor,\n              variantId: selectedVariant?.id || '',\n              variantTitle: selectedVariant?.title || '',\n              quantity: 1,\n            },\n          ],\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\nimport {Analytics} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json({\n    product: {\n      id: '123',\n      title: 'ABC',\n      vendor: 'abc',\n      selectedVariant: {\n        id: '456',\n        title: 'DEF',\n        price: {\n          amount: '100',\n        },\n      },\n    },\n  });\n}\n\nexport default function Product() {\n  const {product} = useLoaderData&lt;typeof loader&gt;();\n  const {selectedVariant} = product;\n\n  return (\n    &lt;div className=\"product\"&gt;\n      &lt;h1&gt;{product.title}&lt;/h1&gt;\n      &lt;Analytics.ProductView\n        data={{\n          products: [\n            {\n              id: product.id,\n              title: product.title,\n              price: selectedVariant?.price.amount || '0',\n              vendor: product.vendor,\n              variantId: selectedVariant?.id || '',\n              variantTitle: selectedVariant?.title || '',\n              quantity: 1,\n            },\n          ],\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsProductViewGeneratedType",
        "typeDefinitions": {
          "AnalyticsProductViewGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "name": "AnalyticsProductViewGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "ProductViewProps",
                "filePath": "src/analytics-manager/AnalyticsView.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsView.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function AnalyticsProductView(props: ProductViewProps) {\n  return <AnalyticsView {...props} type=\"product_viewed\" />;\n}"
          },
          "ProductViewProps": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductViewProps",
            "value": "{\n  data: ProductsPayload;\n  customData?: OtherData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ProductsPayload",
                "description": ""
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          },
          "ProductsPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductsPayload",
            "value": "{\n  /** The products associated with this event. */\n  products: Array<ProductPayload & OtherData>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "products",
                "value": "Array<ProductPayload & OtherData>",
                "description": "The products associated with this event."
              }
            ]
          },
          "ProductPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductPayload",
            "value": "{\n  /** The product id. */\n  id: Product['id'];\n  /** The product title. */\n  title: Product['title'];\n  /** The displaying variant price. */\n  price: ProductVariant['price']['amount'];\n  /** The product vendor. */\n  vendor: Product['vendor'];\n  /** The displaying variant id. */\n  variantId: ProductVariant['id'];\n  /** The displaying variant title. */\n  variantTitle: ProductVariant['title'];\n  /** The quantity of product. */\n  quantity: number;\n  /** The product sku. */\n  sku?: ProductVariant['sku'];\n  /** The product type. */\n  productType?: Product['productType'];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The product id."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "string",
                "description": "The displaying variant price."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "productType",
                "value": "string",
                "description": "The product type.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "quantity",
                "value": "number",
                "description": "The quantity of product."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "sku",
                "value": "string",
                "description": "The product sku.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string",
                "description": "The product title."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantId",
                "value": "string",
                "description": "The displaying variant id."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantTitle",
                "value": "string",
                "description": "The displaying variant title."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "vendor",
                "value": "string",
                "description": "The product vendor."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Analytics.SearchView",
    "category": "components",
    "subCategory": "analytics",
    "isVisualComponent": false,
    "related": [],
    "description": "Publishes a `search_viewed` event to the `Analytics.Provider` component.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\nimport {json} from '@shopify/remix-oxygen';\nimport {useLoaderData} from '@remix-run/react';\n\nexport async function loader({request}) {\n  const url = new URL(request.url);\n  const searchParams = new URLSearchParams(url.search);\n  const searchTerm = String(searchParams.get('q') || '');\n\n  return json({\n    searchTerm,\n  });\n}\n\nexport default function SearchPage() {\n  const {searchTerm} = useLoaderData();\n  return (\n    &lt;div className=\"search\"&gt;\n      &lt;h1&gt;Search&lt;/h1&gt;\n      &lt;Analytics.SearchView data={{searchTerm}} /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Analytics} from '@shopify/hydrogen';\nimport {type LoaderFunctionArgs, json} from '@shopify/remix-oxygen';\nimport {useLoaderData} from '@remix-run/react';\n\nexport async function loader({request}: LoaderFunctionArgs) {\n  const url = new URL(request.url);\n  const searchParams = new URLSearchParams(url.search);\n  const searchTerm = String(searchParams.get('q') || '');\n\n  return json({\n    searchTerm,\n  });\n}\n\nexport default function SearchPage() {\n  const {searchTerm} = useLoaderData&lt;typeof loader&gt;();\n  return (\n    &lt;div className=\"search\"&gt;\n      &lt;h1&gt;Search&lt;/h1&gt;\n      &lt;Analytics.SearchView data={{searchTerm}} /&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "AnalyticsSearchViewGeneratedType",
        "typeDefinitions": {
          "AnalyticsSearchViewGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "name": "AnalyticsSearchViewGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "SearchViewProps",
                "filePath": "src/analytics-manager/AnalyticsView.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsView.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function AnalyticsSearchView(props: SearchViewProps) {\n  return <AnalyticsView {...props} type=\"search_viewed\" />;\n}"
          },
          "SearchViewProps": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SearchViewProps",
            "value": "{\n  data?: SearchPayload;\n  customData?: OtherData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "OtherData",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "SearchPayload",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          },
          "SearchPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SearchPayload",
            "value": "{\n  /** The search term used for the search results page */\n  searchTerm: string;\n  /** The search results */\n  searchResults?: any;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "searchResults",
                "value": "any",
                "description": "The search results",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "searchTerm",
                "value": "string",
                "description": "The search term used for the search results page"
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getShopAnalytics",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "A function that queries for shop required analytics data to be used in the [`Analytics.Provider`](/docs/api/hydrogen/2024-07/components/Analytics-provider) component.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Analytics, getShopAnalytics} from '@shopify/hydrogen';\nimport {defer} from '@shopify/remix-oxygen';\nimport {Outlet, useLoaderData} from '@remix-run/react';\n\nexport async function loader({context}) {\n  const {cart, env} = context;\n  const cartPromise = cart.get();\n\n  return defer({\n    cart: cartPromise,\n    shop: getShopAnalytics({\n      storefront: context.storefront,\n      publicStorefrontId: env.PUBLIC_STOREFRONT_ID,\n    }),\n    consent: {\n      checkoutDomain: env.PUBLIC_CHECKOUT_DOMAIN,\n      storefrontAccessToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      withPrivacyBanner: true, // false stops the privacy banner from being displayed\n      // localize the privacy banner\n      country: context.storefront.i18n.country,\n      language: context.storefront.i18n.language,\n    },\n  });\n}\n\nexport default function App() {\n  const data = useLoaderData();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Analytics.Provider\n          cart={data.cart}\n          shop={data.shop}\n          consent={data.consent}\n        &gt;\n          &lt;Outlet /&gt;\n        &lt;/Analytics.Provider&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Analytics, getShopAnalytics} from '@shopify/hydrogen';\nimport {defer, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {Outlet, useLoaderData} from '@remix-run/react';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const {cart, env} = context;\n  const cartPromise = cart.get();\n\n  return defer({\n    cart: cartPromise,\n    shop: getShopAnalytics({\n      storefront: context.storefront,\n      publicStorefrontId: env.PUBLIC_STOREFRONT_ID,\n    }),\n    consent: {\n      checkoutDomain: env.PUBLIC_CHECKOUT_DOMAIN,\n      storefrontAccessToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      withPrivacyBanner: true, // false stops the privacy banner from being displayed\n      // localize the privacy banner\n      country: context.storefront.i18n.country,\n      language: context.storefront.i18n.language,\n    },\n  });\n}\n\nexport default function App() {\n  const data = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Analytics.Provider\n          cart={data.cart}\n          shop={data.shop}\n          consent={data.consent}\n        &gt;\n          &lt;Outlet /&gt;\n        &lt;/Analytics.Provider&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "GetShopAnalyticsGeneratedType",
        "typeDefinitions": {
          "GetShopAnalyticsGeneratedType": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "GetShopAnalyticsGeneratedType",
            "description": "",
            "params": [
              {
                "name": "input1",
                "description": "",
                "value": "ShopAnalyticsProps",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "Promise<ShopAnalytics | null>",
              "value": "Promise<ShopAnalytics | null>"
            },
            "value": "export async function getShopAnalytics({\n  storefront,\n  publicStorefrontId = '0',\n}: ShopAnalyticsProps): Promise<ShopAnalytics | null> {\n  return storefront\n    .query(SHOP_QUERY, {\n      cache: storefront.CacheLong(),\n    })\n    .then(({shop, localization}: {shop: Shop; localization: Localization}) => {\n      return {\n        shopId: shop.id,\n        acceptedLanguage: localization.language.isoCode,\n        currency: localization.country.currency.isoCode,\n        hydrogenSubchannelId: publicStorefrontId,\n      };\n    });\n}"
          },
          "ShopAnalyticsProps": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopAnalyticsProps",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/2024-07/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * The `PUBLIC_STOREFRONT_ID` generated by Oxygen in the environment variable.\n   */\n  publicStorefrontId: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "publicStorefrontId",
                "value": "string",
                "description": "The `PUBLIC_STOREFRONT_ID` generated by Oxygen in the environment variable."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/2024-07/utilities/createstorefrontclient)."
              }
            ]
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "ShopAnalytics": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopAnalytics",
            "value": "{\n  /** The shop ID. */\n  shopId: string;\n  /** The language code that is being displayed to user. */\n  acceptedLanguage: LanguageCode;\n  /** The currency code that is being displayed to user. */\n  currency: CurrencyCode;\n  /** The Hydrogen subchannel ID generated by Oxygen in the environment variable. */\n  hydrogenSubchannelId: string | '0';\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "acceptedLanguage",
                "value": "LanguageCode",
                "description": "The language code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currency",
                "value": "CurrencyCode",
                "description": "The currency code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hydrogenSubchannelId",
                "value": "string | '0'",
                "description": "The Hydrogen subchannel ID generated by Oxygen in the environment variable."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shopId",
                "value": "string",
                "description": "The shop ID."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "useAnalytics",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [],
    "description": "A hook that provides access to the analytics provider context. Must be a descendent of [`Analytics.Provider`](/docs/api/hydrogen/2024-07/components/Analytics-provider).",
    "type": "hook",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useAnalytics} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function CustomAnalytics() {\n  const {subscribe, register} = useAnalytics();\n  const {ready} = register('CustomAnalytics'); // unique string identifier\n\n  useEffect(() =&gt; {\n    // Triggers on every page navigation\n    subscribe('page_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Page viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.ProductView&gt;`\n    subscribe('product_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Product viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CollectionView&gt;`\n    subscribe('collection_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Collection viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CartView&gt;`\n    subscribe('cart_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Cart viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.SearchView&gt;`\n    subscribe('search_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Search viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CustomView type=\"custom_promotion_viewed\"&gt;`\n    subscribe('custom_promotion_viewed', (data) =&gt; {\n      console.log('CustomAnalytics - Promotion viewed:', data);\n    });\n\n    // Triggers when the cart is updated\n    subscribe('cart_updated', (data) =&gt; {\n      console.log('CustomAnalytics - Cart updated:', data);\n    });\n\n    // Triggers when an existing cart line increases in quantity or a new cart line is added\n    subscribe('product_added_to_cart', (data) =&gt; {\n      console.log('CustomAnalytics - Product added to cart:', data);\n    });\n\n    // Triggers when an existing cart line decreases in quantity or a cart line is removed\n    subscribe('product_removed_from_cart', (data) =&gt; {\n      console.log('CustomAnalytics - Product removed from cart:', data);\n    });\n\n    // Register the CustomAnalytics component as ready\n    ready();\n  }, []);\n\n  return null;\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  type PageViewPayload,\n  type ProductViewPayload,\n  type CollectionViewPayload,\n  type CartViewPayload,\n  type CartUpdatePayload,\n  type CartLineUpdatePayload,\n  type SearchViewPayload,\n  useAnalytics,\n} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function CustomAnalytics() {\n  const {subscribe, register} = useAnalytics();\n  const {ready} = register('CustomAnalytics'); // unique string identifier\n\n  useEffect(() =&gt; {\n    // Triggers on every page navigation\n    subscribe('page_viewed', (data: PageViewPayload) =&gt; {\n      console.log('CustomAnalytics - Page viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.ProductView&gt;`\n    subscribe('product_viewed', (data: ProductViewPayload) =&gt; {\n      console.log('CustomAnalytics - Product viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CollectionView&gt;`\n    subscribe('collection_viewed', (data: CollectionViewPayload) =&gt; {\n      console.log('CustomAnalytics - Collection viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CartView&gt;`\n    subscribe('cart_viewed', (data: CartViewPayload) =&gt; {\n      console.log('CustomAnalytics - Cart viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.SearchView&gt;`\n    subscribe('search_viewed', (data: SearchViewPayload) =&gt; {\n      console.log('CustomAnalytics - Search viewed:', data);\n    });\n\n    // Triggers on a page that uses `&lt;Analytics.CustomView type=\"custom_promotion_viewed\"&gt;`\n    subscribe('custom_promotion_viewed', (data: unknown) =&gt; {\n      console.log('CustomAnalytics - Promotion viewed:', data);\n    });\n\n    // Triggers when the cart is updated\n    subscribe('cart_updated', (data: CartUpdatePayload) =&gt; {\n      console.log('CustomAnalytics - Cart updated:', data);\n    });\n\n    // Triggers when an existing cart line increases in quantity or a new cart line is added\n    subscribe('product_added_to_cart', (data: CartLineUpdatePayload) =&gt; {\n      console.log('CustomAnalytics - Product added to cart:', data);\n    });\n\n    // Triggers when an existing cart line decreases in quantity or a cart line is removed\n    subscribe('product_removed_from_cart', (data: CartLineUpdatePayload) =&gt; {\n      console.log('CustomAnalytics - Product removed from cart:', data);\n    });\n\n    // Register the CustomAnalytics component as ready\n    ready();\n  }, []);\n\n  return null;\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Returns",
        "description": "",
        "type": "AnalyticsContextValueForDoc",
        "typeDefinitions": {
          "AnalyticsContextValueForDoc": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AnalyticsContextValueForDoc",
            "value": "{\n  /** A function to tell you the current state of if the user can be tracked by analytics. Defaults to Customer Privacy API's `window.Shopify.customerPrivacy.analyticsProcessingAllowed()`. */\n  canTrack?: () => boolean;\n  /** The current cart state. You can overwrite the type by passing a generic */\n  cart?: UserCart | DefaultCart;\n  /** The custom data passed in from the `AnalyticsProvider`. */\n  customData?: Record<string, unknown>;\n  /** The previous cart state. You can overwrite the type by passing a generic */\n  prevCart?: UserCart | DefaultCart;\n  /** A function to publish an analytics event. */\n  publish?: AnalyticsContextPublishForDoc;\n  /** A function to register with the analytics provider. It holds the first browser load events until all registered key has executed the supplied `ready` function. [See example register  usage](/docs/api/hydrogen/2024-07/hooks/useanalytics#example-useanalytics.register). */\n  register?: (key: string) => {ready: () => void};\n  /** The shop configuration required to publish events to Shopify. */\n  shop?: Promise<ShopAnalytics | null> | ShopAnalytics | null;\n  /** A function to subscribe to analytics events. */\n  subscribe?: AnalyticsContextSubscribeForDoc;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "canTrack",
                "value": "() => boolean",
                "description": "A function to tell you the current state of if the user can be tracked by analytics. Defaults to Customer Privacy API's `window.Shopify.customerPrivacy.analyticsProcessingAllowed()`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "UserCart | DefaultCart",
                "description": "The current cart state. You can overwrite the type by passing a generic",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "Record<string, unknown>",
                "description": "The custom data passed in from the `AnalyticsProvider`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "prevCart",
                "value": "UserCart | DefaultCart",
                "description": "The previous cart state. You can overwrite the type by passing a generic",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "publish",
                "value": "AnalyticsContextPublishForDoc",
                "description": "A function to publish an analytics event.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "register",
                "value": "(key: string) => { ready: () => void; }",
                "description": "A function to register with the analytics provider. It holds the first browser load events until all registered key has executed the supplied `ready` function. [See example register  usage](/docs/api/hydrogen/2024-07/hooks/useanalytics#example-useanalytics.register).",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "Promise<ShopAnalytics | null> | ShopAnalytics | null",
                "description": "The shop configuration required to publish events to Shopify.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "subscribe",
                "value": "AnalyticsContextSubscribeForDoc",
                "description": "A function to subscribe to analytics events.",
                "isOptional": true
              }
            ]
          },
          "DefaultCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DefaultCart",
            "value": "Promise<CartReturn | null> | CartReturn | null",
            "description": ""
          },
          "CartReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartReturn",
            "value": "Cart & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "AnalyticsContextPublishForDoc": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AnalyticsContextPublishForDoc",
            "value": "PublishPageView | PublishProductView | PublishCollectionView | PublishCartView | PublishSearchView | PublishCartUpdated | PublishProductAddedToCart | PublishProductRemovedFromCart | PublishCustomEvent",
            "description": ""
          },
          "PublishPageView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishPageView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"page_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "PageViewPayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishPageView = (event: 'page_viewed', payload: PageViewPayload) => void;"
          },
          "PageViewPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PageViewPayload",
            "value": "UrlPayload & BasePayload",
            "description": ""
          },
          "UrlPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "UrlPayload",
            "value": "{\n  /** The url location of when this event is collected. */\n  url: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "The url location of when this event is collected."
              }
            ]
          },
          "BasePayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "BasePayload",
            "value": "{\n  /** The shop data passed in from the `AnalyticsProvider`. */\n  shop: ShopAnalytics | null;\n  /** The custom data passed in from the `AnalyticsProvider`. */\n  customData?: AnalyticsProviderProps['customData'];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "customData",
                "value": "Record<string, unknown>",
                "description": "The custom data passed in from the `AnalyticsProvider`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "ShopAnalytics | null",
                "description": "The shop data passed in from the `AnalyticsProvider`."
              }
            ]
          },
          "ShopAnalytics": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopAnalytics",
            "value": "{\n  /** The shop ID. */\n  shopId: string;\n  /** The language code that is being displayed to user. */\n  acceptedLanguage: LanguageCode;\n  /** The currency code that is being displayed to user. */\n  currency: CurrencyCode;\n  /** The Hydrogen subchannel ID generated by Oxygen in the environment variable. */\n  hydrogenSubchannelId: string | '0';\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "acceptedLanguage",
                "value": "LanguageCode",
                "description": "The language code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currency",
                "value": "CurrencyCode",
                "description": "The currency code that is being displayed to user."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hydrogenSubchannelId",
                "value": "string | '0'",
                "description": "The Hydrogen subchannel ID generated by Oxygen in the environment variable."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
                "syntaxKind": "PropertySignature",
                "name": "shopId",
                "value": "string",
                "description": "The shop ID."
              }
            ]
          },
          "PublishProductView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishProductView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "ProductViewPayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishProductView = (\n  event: 'product_viewed',\n  payload: ProductViewPayload,\n) => void;"
          },
          "ProductViewPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductViewPayload",
            "value": "ProductsPayload & UrlPayload & BasePayload",
            "description": ""
          },
          "ProductsPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductsPayload",
            "value": "{\n  /** The products associated with this event. */\n  products: Array<ProductPayload & OtherData>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "products",
                "value": "Array<ProductPayload & OtherData>",
                "description": "The products associated with this event."
              }
            ]
          },
          "ProductPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ProductPayload",
            "value": "{\n  /** The product id. */\n  id: Product['id'];\n  /** The product title. */\n  title: Product['title'];\n  /** The displaying variant price. */\n  price: ProductVariant['price']['amount'];\n  /** The product vendor. */\n  vendor: Product['vendor'];\n  /** The displaying variant id. */\n  variantId: ProductVariant['id'];\n  /** The displaying variant title. */\n  variantTitle: ProductVariant['title'];\n  /** The quantity of product. */\n  quantity: number;\n  /** The product sku. */\n  sku?: ProductVariant['sku'];\n  /** The product type. */\n  productType?: Product['productType'];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The product id."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "string",
                "description": "The displaying variant price."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "productType",
                "value": "string",
                "description": "The product type.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "quantity",
                "value": "number",
                "description": "The quantity of product."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "sku",
                "value": "string",
                "description": "The product sku.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string",
                "description": "The product title."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantId",
                "value": "string",
                "description": "The displaying variant id."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantTitle",
                "value": "string",
                "description": "The displaying variant title."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "vendor",
                "value": "string",
                "description": "The product vendor."
              }
            ]
          },
          "OtherData": {
            "description": "",
            "name": "OtherData",
            "value": "OtherData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          },
          "PublishCollectionView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishCollectionView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"collection_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "CollectionViewPayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishCollectionView = (\n  event: 'collection_viewed',\n  payload: CollectionViewPayload,\n) => void;"
          },
          "CollectionViewPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionViewPayload",
            "value": "CollectionPayload & UrlPayload & BasePayload",
            "description": ""
          },
          "CollectionPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionPayload",
            "value": "{\n  collection: CollectionPayloadDetails;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "collection",
                "value": "CollectionPayloadDetails",
                "description": ""
              }
            ]
          },
          "CollectionPayloadDetails": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CollectionPayloadDetails",
            "value": "{\n  /** The collection id. */\n  id: string;\n  /** The collection handle. */\n  handle: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "handle",
                "value": "string",
                "description": "The collection handle."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "The collection id."
              }
            ]
          },
          "PublishCartView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishCartView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"cart_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "CartViewPayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishCartView = (event: 'cart_viewed', payload: CartViewPayload) => void;"
          },
          "CartViewPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartViewPayload",
            "value": "CartPayload & UrlPayload & BasePayload",
            "description": ""
          },
          "CartPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartPayload",
            "value": "{\n  /** The current cart state. */\n  cart: CartReturn | null;\n  /** The previous cart state. */\n  prevCart: CartReturn | null;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "CartReturn | null",
                "description": "The current cart state."
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "prevCart",
                "value": "CartReturn | null",
                "description": "The previous cart state."
              }
            ]
          },
          "PublishSearchView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishSearchView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"search_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "SearchViewPayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishSearchView = (\n  event: 'search_viewed',\n  payload: SearchViewPayload,\n) => void;"
          },
          "SearchViewPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SearchViewPayload",
            "value": "SearchPayload & UrlPayload & BasePayload",
            "description": ""
          },
          "SearchPayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SearchPayload",
            "value": "{\n  /** The search term used for the search results page */\n  searchTerm: string;\n  /** The search results */\n  searchResults?: any;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "searchResults",
                "value": "any",
                "description": "The search results",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "searchTerm",
                "value": "string",
                "description": "The search term used for the search results page"
              }
            ]
          },
          "PublishCartUpdated": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishCartUpdated",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"cart_updated\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "CartUpdatePayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishCartUpdated = (\n  event: 'cart_updated',\n  payload: CartUpdatePayload,\n) => void;"
          },
          "CartUpdatePayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartUpdatePayload",
            "value": "CartPayload & BasePayload & OtherData",
            "description": ""
          },
          "PublishProductAddedToCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishProductAddedToCart",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_added_to_cart\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "CartLineUpdatePayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishProductAddedToCart = (\n  event: 'product_added_to_cart',\n  payload: CartLineUpdatePayload,\n) => void;"
          },
          "CartLineUpdatePayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartLineUpdatePayload",
            "value": "CartLinePayload & CartPayload & BasePayload & OtherData",
            "description": ""
          },
          "CartLinePayload": {
            "filePath": "src/analytics-manager/AnalyticsView.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartLinePayload",
            "value": "{\n  /** The previous state of the cart line that got updated. */\n  prevLine?: CartLine | ComponentizableCartLine;\n  /** The current state of the cart line that got updated. */\n  currentLine?: CartLine | ComponentizableCartLine;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currentLine",
                "value": "CartLine | ComponentizableCartLine",
                "description": "The current state of the cart line that got updated.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-manager/AnalyticsView.tsx",
                "syntaxKind": "PropertySignature",
                "name": "prevLine",
                "value": "CartLine | ComponentizableCartLine",
                "description": "The previous state of the cart line that got updated.",
                "isOptional": true
              }
            ]
          },
          "PublishProductRemovedFromCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishProductRemovedFromCart",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_removed_from_cart\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "CartLineUpdatePayload",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishProductRemovedFromCart = (\n  event: 'product_removed_from_cart',\n  payload: CartLineUpdatePayload,\n) => void;"
          },
          "PublishCustomEvent": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "PublishCustomEvent",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "`custom_${string}`",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "payload",
                "description": "",
                "value": "OtherData",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type PublishCustomEvent = (\n  event: `custom_${string}`,\n  payload: OtherData,\n) => void;"
          },
          "AnalyticsContextSubscribeForDoc": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AnalyticsContextSubscribeForDoc",
            "value": "SubscribePageView | SubscribeProductView | SubscribeCollectionView | SubscribeCartView | SubscribeSearchView | SubscribeCartUpdated | SubscribeProductAddedToCart | SubscribeProductRemovedFromCart | SubscribeCustomEvent",
            "description": ""
          },
          "SubscribePageView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribePageView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"page_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: PageViewPayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribePageView = (\n  event: 'page_viewed',\n  callback: (payload: PageViewPayload) => void,\n) => void;"
          },
          "SubscribeProductView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeProductView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: ProductViewPayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeProductView = (\n  event: 'product_viewed',\n  callback: (payload: ProductViewPayload) => void,\n) => void;"
          },
          "SubscribeCollectionView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeCollectionView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"collection_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: CollectionViewPayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeCollectionView = (\n  event: 'collection_viewed',\n  callback: (payload: CollectionViewPayload) => void,\n) => void;"
          },
          "SubscribeCartView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeCartView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"cart_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: CartViewPayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeCartView = (\n  event: 'cart_viewed',\n  callback: (payload: CartViewPayload) => void,\n) => void;"
          },
          "SubscribeSearchView": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeSearchView",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"search_viewed\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: SearchViewPayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeSearchView = (\n  event: 'search_viewed',\n  callback: (payload: SearchViewPayload) => void,\n) => void;"
          },
          "SubscribeCartUpdated": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeCartUpdated",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"cart_updated\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: CartUpdatePayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeCartUpdated = (\n  event: 'cart_updated',\n  callback: (payload: CartUpdatePayload) => void,\n) => void;"
          },
          "SubscribeProductAddedToCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeProductAddedToCart",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_added_to_cart\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: CartLineUpdatePayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeProductAddedToCart = (\n  event: 'product_added_to_cart',\n  callback: (payload: CartLineUpdatePayload) => void,\n) => void;"
          },
          "SubscribeProductRemovedFromCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeProductRemovedFromCart",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "\"product_removed_from_cart\"",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: CartLineUpdatePayload) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeProductRemovedFromCart = (\n  event: 'product_removed_from_cart',\n  callback: (payload: CartLineUpdatePayload) => void,\n) => void;"
          },
          "SubscribeCustomEvent": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "name": "SubscribeCustomEvent",
            "description": "",
            "params": [
              {
                "name": "event",
                "description": "",
                "value": "`custom_${string}`",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              },
              {
                "name": "callback",
                "description": "",
                "value": "(payload: OtherData) => void",
                "filePath": "src/analytics-manager/AnalyticsProvider.tsx"
              }
            ],
            "returns": {
              "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "type SubscribeCustomEvent = (\n  event: `custom_${string}`,\n  callback: (payload: OtherData) => void,\n) => void;"
          }
        }
      }
    ],
    "examples": {
      "description": "Example usage with `useAnalytics`:",
      "exampleGroups": [
        {
          "title": "useAnalytics.register",
          "examples": [
            {
              "description": "Registers a unique key with the analytics provider component, enabling custom analytics integrations to wait for a callback before sending event data.",
              "codeblock": {
                "title": "",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {\n  type PageViewPayload,\n  useAnalytics,\n  useLoadScript,\n} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function MyAnalytics() {\n  const {subscribe, register} = useAnalytics();\n\n  // Load the 3p analytics script\n  const scriptStatus = useLoadScript(\n    'https://example.com/some-3p-analytics-script.js',\n  );\n\n  // unique string identifier\n  const {ready} = register('MyAnalytics');\n\n  useEffect(() =&gt; {\n    // Make sure the 3p script is loaded\n    if (scriptStatus !== 'done') return;\n\n    // Initialize the 3p analytics script\n\n    // Subscribe to analytics events\n    subscribe('page_viewed', (data: PageViewPayload) =&gt; {\n      // report to 3p analytics\n    });\n\n    // Register the MyAnalytics component as ready\n    ready();\n  }, []);\n\n  return null;\n}\n",
                    "language": "js"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "CacheCustom",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      },
      {
        "name": "CacheNone",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachenone"
      },
      {
        "name": "CacheShort",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cacheshort"
      },
      {
        "name": "CacheLong",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachelong"
      }
    ],
    "description": "This allows you to create your own caching strategy, using any of the options available in a `CachingStrategy` object.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {CacheCustom} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheCustom({\n        maxAge: 1000 * 60 * 60 * 24 * 365,\n        staleWhileRevalidate: 1000 * 60 * 60 * 24 * 7,\n      }),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {CacheCustom} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheCustom({\n        maxAge: 1000 * 60 * 60 * 24 * 365,\n        staleWhileRevalidate: 1000 * 60 * 60 * 24 * 7,\n      }),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "CacheCustomGeneratedType",
        "typeDefinitions": {
          "CacheCustomGeneratedType": {
            "filePath": "src/cache/strategies.ts",
            "name": "CacheCustomGeneratedType",
            "description": "",
            "params": [
              {
                "name": "overrideOptions",
                "description": "",
                "value": "AllCacheOptions",
                "filePath": "src/cache/strategies.ts"
              }
            ],
            "returns": {
              "filePath": "src/cache/strategies.ts",
              "description": "",
              "name": "AllCacheOptions",
              "value": "AllCacheOptions"
            },
            "value": "export function CacheCustom(overrideOptions: CachingStrategy): AllCacheOptions {\n  return overrideOptions as AllCacheOptions;\n}"
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "CacheLong",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      },
      {
        "name": "CacheNone",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachenone"
      },
      {
        "name": "CacheShort",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cacheshort"
      },
      {
        "name": "CacheCustom",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachecustom"
      }
    ],
    "description": "The `CacheLong` strategy instructs caches to store data for 1 hour, and `staleWhileRevalidate` data for an additional 23 hours. Note: these time values are subject to change.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {CacheLong} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheLong(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {CacheLong} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheLong(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "CacheLongGeneratedType",
        "typeDefinitions": {
          "CacheLongGeneratedType": {
            "filePath": "src/cache/strategies.ts",
            "name": "CacheLongGeneratedType",
            "description": "",
            "params": [
              {
                "name": "overrideOptions",
                "description": "",
                "value": "AllCacheOptions",
                "isOptional": true,
                "filePath": "src/cache/strategies.ts"
              }
            ],
            "returns": {
              "filePath": "src/cache/strategies.ts",
              "description": "",
              "name": "AllCacheOptions",
              "value": "AllCacheOptions"
            },
            "value": "export function CacheLong(overrideOptions?: CachingStrategy): AllCacheOptions {\n  guardExpirableModeType(overrideOptions);\n  return {\n    mode: PUBLIC,\n    maxAge: 3600, // 1 hour\n    staleWhileRevalidate: 82800, // 23 Hours\n    ...overrideOptions,\n  };\n}"
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "CacheNone",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      },
      {
        "name": "CacheShort",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cacheshort"
      },
      {
        "name": "CacheLong",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachelong"
      },
      {
        "name": "CacheCustom",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachecustom"
      }
    ],
    "description": "The CacheNone() strategy instructs caches not to store any data. The function accepts no arguments.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {CacheNone} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheNone(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {CacheNone} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheNone(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "CacheNoneGeneratedType",
        "typeDefinitions": {
          "CacheNoneGeneratedType": {
            "filePath": "src/cache/strategies.ts",
            "name": "CacheNoneGeneratedType",
            "description": "",
            "params": [],
            "returns": {
              "filePath": "src/cache/strategies.ts",
              "description": "",
              "name": "NoStoreStrategy",
              "value": "NoStoreStrategy"
            },
            "value": "export function CacheNone(): NoStoreStrategy {\n  return {\n    mode: NO_STORE,\n  };\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "CacheShort",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      },
      {
        "name": "CacheNone",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachenone"
      },
      {
        "name": "CacheLong",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachelong"
      },
      {
        "name": "CacheCustom",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachecustom"
      }
    ],
    "description": "The `CacheShort` strategy instructs caches to store data for 1 second, and `staleWhileRevalidate` data for an additional 9 seconds. Note: these time values are subject to change.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {CacheShort} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheShort(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {CacheShort} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const data = await context.storefront.query(\n    `#grahpql\n  {\n    shop {\n      name\n      description\n    }\n  }`,\n    {\n      cache: CacheShort(),\n    },\n  );\n\n  return json(data);\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "CacheShortGeneratedType",
        "typeDefinitions": {
          "CacheShortGeneratedType": {
            "filePath": "src/cache/strategies.ts",
            "name": "CacheShortGeneratedType",
            "description": "",
            "params": [
              {
                "name": "overrideOptions",
                "description": "",
                "value": "AllCacheOptions",
                "isOptional": true,
                "filePath": "src/cache/strategies.ts"
              }
            ],
            "returns": {
              "filePath": "src/cache/strategies.ts",
              "description": "",
              "name": "AllCacheOptions",
              "value": "AllCacheOptions"
            },
            "value": "export function CacheShort(overrideOptions?: CachingStrategy): AllCacheOptions {\n  guardExpirableModeType(overrideOptions);\n  return {\n    mode: PUBLIC,\n    maxAge: 1,\n    staleWhileRevalidate: 9,\n    ...overrideOptions,\n  };\n}"
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "InMemoryCache",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      }
    ],
    "description": "> Caution:\n> This utility should only be used when deploying Hydrogen to a Node.js environment. It should *not* be used when deploying Hydrogen to Oxygen.\n\nIf you are deploying Hydrogen to a Node.js environment, you can use this limited implementation of an in-memory cache. It only supports the `cache-control` header. It does NOT support `age` or `expires` headers.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "const {createRequestHandler} = require('@remix-run/express');\nconst path = require('path');\nconst {installGlobals} = require('@remix-run/node');\nconst express = require('express');\nconst {createStorefrontClient, InMemoryCache} = require('@shopify/hydrogen');\n\ninstallGlobals();\n\nconst app = express();\n\nconst BUILD_DIR = path.join(process.cwd(), 'build');\n\napp.use(\n  '/build',\n  express.static('public/build', {immutable: true, maxAge: '1y'}),\n);\n\napp.all('*', async (req) =&gt; {\n  const {storefront} = createStorefrontClient({\n    cache: new InMemoryCache(),\n    // `waitUntil` is only needed on worker environments. For Express/Node, it isn't applicable\n    waitUntil: null,\n    i18n: {language: 'EN', country: 'US'},\n    publicStorefrontToken: process.env.PUBLIC_STOREFRONT_API_TOKEN,\n    privateStorefrontToken: process.env.PRIVATE_STOREFRONT_API_TOKEN,\n    storeDomain: process.env.PUBLIC_STORE_DOMAIN,\n    storefrontId: process.env.PUBLIC_STOREFRONT_ID,\n    storefrontHeaders: {\n      cookie: req.get('cookie'),\n    },\n  });\n\n  return createRequestHandler({\n    build: require(BUILD_DIR),\n    mode: process.env.NODE_ENV,\n    getLoadContext: () =&gt; ({storefront}),\n  });\n});\n\nconst port = process.env.PORT || 3000;\n\napp.listen(port, () =&gt; {\n  console.log(`Express server listening on port ${port}`);\n});\n",
            "language": "js"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": []
  },
  {
    "name": "createWithCache",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates utility functions to store data in cache with stale-while-revalidate support.\n - Use `withCache.fetch` to simply fetch data from a third-party API.\n - Use the more advanced `withCache.run` to execute any asynchronous operation.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "// In your app's `server.ts` file:\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {createWithCache, CacheLong} from '@shopify/hydrogen';\n// Use another `createRequestHandler` if deploying off oxygen\nimport {createRequestHandler} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request, env, executionContext) {\n    const cache = await caches.open('my-cms');\n    const withCache = createWithCache({\n      cache,\n      waitUntil: executionContext.waitUntil.bind(executionContext),\n      request,\n    });\n\n    // 1. Create a custom utility to query a third-party API:\n    const fetchMyCMS = async (query) =&gt; {\n      const {data, response} = await withCache.fetch(\n        'https://my-cms.com/api',\n        {\n          method: 'POST',\n          body: query,\n          headers: {Authorization: 'Bearer 123'},\n        },\n        {\n          // Optionally, specify a cache strategy.\n          // Default is CacheShort().\n          cache: CacheLong(),\n          // Cache if there are no GralhQL errors:\n          shouldCacheResponse: (body) =&gt; !body?.errors,\n          // Optionally, add extra information to show\n          // in the Subrequest Profiler utility.\n          displayName: 'My CMS query',\n        },\n      );\n\n      // Access the response properties:\n      console.log(data, response.headers);\n\n      return data;\n    };\n\n    // 2. Or Create a more advanced utility to query multiple APIs under the same cache key:\n    const fetchMultipleCMS = (options) =&gt; {\n      // Prefix the cache key and make it unique based on arguments.\n      return withCache.run(\n        ['my-cms-composite', options.id, options.handle],\n        CacheLong(),\n        async (params) =&gt; {\n          // Run multiple subrequests in parallel, or any other async operations.\n          const [response1, response2] = await Promise.all([\n            fetch('https://my-cms-1.com/api', {\n              method: 'POST',\n              body: JSON.stringify({id: options.id}),\n            }),\n            fetch('https://my-cms-2.com/api', {\n              method: 'POST',\n              body: JSON.stringify({handle: options.handle}),\n            }),\n          ]);\n\n          // Throw if any response is unsuccessful.\n          // This is important to prevent the results from being cached.\n          if (!response1.ok || !response2.ok) {\n            throw new Error('Failed to fetch data');\n          }\n\n          const [data1, data2] = await Promise.all([\n            response1.json(),\n            response2.json(),\n          ]);\n\n          // Validate data and throw to avoid caching errors.\n          if (data1.errors || data2.errors) {\n            throw new Error('API errors');\n          }\n\n          // Optionally, add extra information to show\n          // in the Subrequest Profiler utility.\n          params.addDebugData({displayName: 'My CMS query'});\n\n          // Compose the result as needed.\n          return {\n            ...data1,\n            ...data2,\n            extra1: response1.headers.get('X-Extra'),\n            extra2: response2.headers.get('X-Extra'),\n          };\n        },\n      );\n    };\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      getLoadContext: () =&gt; ({\n        // Make sure to update env.d.ts to\n        // include these properties in `AppLoadContext`.\n        fetchMyCMS,\n        fetchMultipleCMS,\n      }),\n    });\n\n    return handleRequest(request);\n  },\n};\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "// In your app's `server.ts` file:\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {createWithCache, CacheLong} from '@shopify/hydrogen';\n// Use another `createRequestHandler` if deploying off oxygen\nimport {createRequestHandler} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ) {\n    const cache = await caches.open('my-cms');\n    const withCache = createWithCache({\n      cache,\n      waitUntil: executionContext.waitUntil.bind(executionContext),\n      request,\n    });\n\n    type ExpectedResponse = {\n      content: unknown;\n      errors?: string;\n    };\n\n    // 1. Create a custom utility to query a third-party API:\n    const fetchMyCMS = async (query: string) =&gt; {\n      const {data, response} = await withCache.fetch&lt;ExpectedResponse&gt;(\n        'https://my-cms.com/api',\n        {\n          method: 'POST',\n          body: query,\n          headers: {Authorization: 'Bearer 123'},\n        },\n        {\n          // Optionally, specify a cache strategy.\n          // Default is CacheShort().\n          cache: CacheLong(),\n          // Cache if there are no GralhQL errors:\n          shouldCacheResponse: (body) =&gt; !body?.errors,\n          // Optionally, add extra information to show\n          // in the Subrequest Profiler utility.\n          displayName: 'My CMS query',\n        },\n      );\n\n      // Access the response properties:\n      console.log(data, response.headers);\n\n      return data;\n    };\n\n    // 2. Or Create a more advanced utility to query multiple APIs under the same cache key:\n    const fetchMultipleCMS = (options: {id: string; handle: string}) =&gt; {\n      // Prefix the cache key and make it unique based on arguments.\n      return withCache.run(\n        ['my-cms-composite', options.id, options.handle],\n        CacheLong(),\n        async (params) =&gt; {\n          // Run multiple subrequests in parallel, or any other async operations.\n          const [response1, response2] = await Promise.all([\n            fetch('https://my-cms-1.com/api', {\n              method: 'POST',\n              body: JSON.stringify({id: options.id}),\n            }),\n            fetch('https://my-cms-2.com/api', {\n              method: 'POST',\n              body: JSON.stringify({handle: options.handle}),\n            }),\n          ]);\n\n          // Throw if any response is unsuccessful.\n          // This is important to prevent the results from being cached.\n          if (!response1.ok || !response2.ok) {\n            throw new Error('Failed to fetch data');\n          }\n\n          const [data1, data2] = (await Promise.all([\n            response1.json(),\n            response2.json(),\n          ])) as [ExpectedResponse, ExpectedResponse];\n\n          // Validate data and throw to avoid caching errors.\n          if (data1.errors || data2.errors) {\n            throw new Error('API errors');\n          }\n\n          // Optionally, add extra information to show\n          // in the Subrequest Profiler utility.\n          params.addDebugData({displayName: 'My CMS query'});\n\n          // Compose the result as needed.\n          return {\n            ...data1,\n            ...data2,\n            extra1: response1.headers.get('X-Extra'),\n            extra2: response2.headers.get('X-Extra'),\n          };\n        },\n      );\n    };\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      getLoadContext: () =&gt; ({\n        // Make sure to update env.d.ts to\n        // include these properties in `AppLoadContext`.\n        fetchMyCMS,\n        fetchMultipleCMS,\n      }),\n    });\n\n    return handleRequest(request);\n  },\n};\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "CreateWithCacheGeneratedType",
        "typeDefinitions": {
          "CreateWithCacheGeneratedType": {
            "filePath": "src/cache/create-with-cache.ts",
            "name": "CreateWithCacheGeneratedType",
            "description": "Creates utility functions to store data in cache with stale-while-revalidate support.\n- Use `withCache.fetch` to simply fetch data from a third-party API.\n- Use the more advanced `withCache.run` to execute any asynchronous operation.",
            "params": [
              {
                "name": "cacheOptions",
                "description": "",
                "value": "CreateWithCacheOptions",
                "filePath": "src/cache/create-with-cache.ts"
              }
            ],
            "returns": {
              "filePath": "src/cache/create-with-cache.ts",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function createWithCache<T = unknown>(\n  cacheOptions: CreateWithCacheOptions,\n) {\n  const {cache, waitUntil, request} = cacheOptions;\n\n  return {\n    /**\n     * Utility function that executes asynchronous operations and caches the\n     * result according to the strategy provided. Use this to do any type\n     * of asynchronous operation where `withCache.fetch` is insufficient.\n     * For example, when making multiple calls to a third-party API where the\n     * result of all of them needs to be cached under the same cache key.\n     * Whatever data is returned from the `actionFn` will be cached according\n     * to the strategy provided.\n     * Use the `CachingStrategy` to define a custom caching mechanism for your data.\n     * Or use one of the built-in caching strategies: `CacheNone`, `CacheShort`, `CacheLong`.\n     * > Note:\n     * > To prevent caching the result you must throw an error. Otherwise, the result will be cached.\n     * > For example, if you call `fetch` but the response is not successful (e.g. status code >= 400),\n     * > you should throw an error. Otherwise, the response will be cached.\n     */\n    run<InferredActionReturn = T>(\n      cacheKey: CacheKey,\n      strategy: CachingStrategy,\n      actionFn: ({\n        addDebugData,\n      }: CacheActionFunctionParam) =>\n        | InferredActionReturn\n        | Promise<InferredActionReturn>,\n    ) {\n      return runWithCache(cacheKey, actionFn, {\n        strategy,\n        cacheInstance: cache,\n        waitUntil,\n        debugInfo: {\n          ...getDebugHeaders(request),\n          stackInfo: getCallerStackLine?.(),\n        },\n      });\n    },\n\n    /**\n     * Fetches data from a URL and caches the result according to the strategy provided.\n     * When the response is not successful (e.g. status code >= 400), the caching is\n     * skipped automatically and the returned `data` is `null`.\n     * You can also prevent caching by using the `shouldCacheResponse` option and returning\n     * `false` from the function you pass in. For example, you might want to fetch data from a\n     * third-party GraphQL API but not cache the result if the GraphQL response body contains errors.\n     */\n    fetch<Body = T>(\n      url: string,\n      requestInit?: RequestInit,\n      options?: Pick<DebugOptions, 'displayName'> &\n        Pick<\n          FetchCacheOptions<Body>,\n          'cache' | 'cacheKey' | 'shouldCacheResponse'\n        >,\n    ): Promise<{data: Body | null; response: Response}> {\n      return fetchWithServerCache<Body | null>(url, requestInit ?? {}, {\n        waitUntil,\n        cacheKey: [url, requestInit],\n        cacheInstance: cache,\n        debugInfo: {\n          url,\n          ...getDebugHeaders(request),\n          stackInfo: getCallerStackLine?.(),\n          displayName: options?.displayName,\n        },\n        ...options,\n      }).then(([data, response]) => ({data, response}));\n    },\n  };\n}"
          },
          "CreateWithCacheOptions": {
            "filePath": "src/cache/create-with-cache.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CreateWithCacheOptions",
            "value": "{\n  /** An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) */\n  cache: Cache;\n  /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */\n  waitUntil: WaitUntil;\n  /** The `request` object is used to access certain headers for debugging */\n  request?: CrossRuntimeRequest;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/create-with-cache.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache)"
              },
              {
                "filePath": "src/cache/create-with-cache.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "CrossRuntimeRequest",
                "description": "The `request` object is used to access certain headers for debugging",
                "isOptional": true
              },
              {
                "filePath": "src/cache/create-with-cache.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitUntil",
                "value": "WaitUntil",
                "description": "The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform."
              }
            ]
          },
          "CrossRuntimeRequest": {
            "filePath": "src/utils/request.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CrossRuntimeRequest",
            "value": "{\n  url?: string;\n  method?: string;\n  headers: {\n    get?: (key: string) => string | null | undefined;\n    [key: string]: any;\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "{ [key: string]: any; get?: (key: string) => string; }",
                "description": ""
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "method",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "generateCacheControlHeader",
    "category": "utilities",
    "subCategory": "caching",
    "isVisualComponent": false,
    "related": [],
    "description": "This utility function accepts a `CachingStrategy` object and returns a string with the corresponding `cache-control` header.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {generateCacheControlHeader, CacheShort} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json(\n    {some: 'data'},\n    {\n      headers: {\n        'cache-control': generateCacheControlHeader(CacheShort()),\n      },\n    },\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {generateCacheControlHeader, CacheShort} from '@shopify/hydrogen';\n\nexport async function loader() {\n  return json(\n    {some: 'data'},\n    {\n      headers: {\n        'cache-control': generateCacheControlHeader(CacheShort()),\n      },\n    },\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "GenerateCacheControlHeaderGeneratedType",
        "typeDefinitions": {
          "GenerateCacheControlHeaderGeneratedType": {
            "filePath": "src/cache/strategies.ts",
            "name": "GenerateCacheControlHeaderGeneratedType",
            "description": "",
            "params": [
              {
                "name": "cacheOptions",
                "description": "",
                "value": "AllCacheOptions",
                "filePath": "src/cache/strategies.ts"
              }
            ],
            "returns": {
              "filePath": "src/cache/strategies.ts",
              "description": "",
              "name": "string",
              "value": "string"
            },
            "value": "export function generateCacheControlHeader(\n  cacheOptions: CachingStrategy,\n): string {\n  const cacheControl: string[] = [];\n  Object.keys(cacheOptions).forEach((key: string) => {\n    if (key === 'mode') {\n      cacheControl.push(cacheOptions[key] as string);\n    } else if (optionMapping[key]) {\n      cacheControl.push(\n        `${optionMapping[key]}=${cacheOptions[key as keyof CachingStrategy]}`,\n      );\n    }\n  });\n  return cacheControl.join(', ');\n}"
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "CartForm",
    "category": "components",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a form for managing cart operations. Use `CartActionInput` to accept form inputs of known type.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@remix-run/server-runtime';\nimport {CartForm} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport default function Cart() {\n  return (\n    &lt;CartForm\n      action={CartForm.ACTIONS.LinesUpdate}\n      inputs={{\n        lines: [\n          {\n            id: 'gid://shopify/CartLine/123456789',\n            quantity: 3,\n          },\n        ],\n        other: 'data',\n      }}\n    &gt;\n      &lt;button&gt;Quantity up&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}) {\n  const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result;\n\n  if (action === CartForm.ACTIONS.LinesUpdate) {\n    result = await cart.updateLines(inputs.lines);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {type ActionFunctionArgs, json} from '@remix-run/server-runtime';\nimport {\n  type CartQueryDataReturn,\n  type HydrogenCart,\n  CartForm,\n} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport default function Cart() {\n  return (\n    &lt;CartForm\n      action={CartForm.ACTIONS.LinesUpdate}\n      inputs={{\n        lines: [\n          {\n            id: 'gid://shopify/CartLine/123456789',\n            quantity: 3,\n          },\n        ],\n        other: 'data',\n      }}\n    &gt;\n      &lt;button&gt;Quantity up&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}: ActionFunctionArgs) {\n  const cart = context.cart as HydrogenCart;\n  // cart is type HydrogenCart or HydrogenCartCustom\n  // Declare cart type in remix.env.d.ts for interface AppLoadContext to avoid type casting\n  // const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result: CartQueryDataReturn;\n\n  if (action === CartForm.ACTIONS.LinesUpdate) {\n    result = await cart.updateLines(inputs.lines);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "CartFormProps",
        "typeDefinitions": {
          "CartFormProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartFormProps",
            "value": "CartActionInputProps & CartFormCommonProps",
            "description": ""
          },
          "CartActionInputProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartActionInputProps",
            "value": "CartAttributesUpdateProps | CartBuyerIdentityUpdateProps | CartCreateProps | CartDiscountCodesUpdateProps | CartGiftCardCodesUpdateProps | CartLinesAddProps | CartLinesUpdateProps | CartLinesRemoveProps | CartNoteUpdateProps | CartSelectedDeliveryOptionsUpdateProps | CartMetafieldsSetProps | CartMetafieldDeleteProps | CartCustomProps",
            "description": ""
          },
          "CartAttributesUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartAttributesUpdateProps",
            "value": "{\n  action: 'AttributesUpdateInput';\n  inputs?: {\n    attributes: AttributeInput[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"AttributesUpdateInput\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ attributes: AttributeInput[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "AttributeInput": {
            "description": "",
            "name": "AttributeInput",
            "value": "AttributeInput",
            "members": [],
            "override": "[AttributeInput](/docs/api/storefront/2024-07/input-objects/AttributeInput) - Storefront API type"
          },
          "OtherFormData": {
            "description": "",
            "name": "OtherFormData",
            "value": "OtherFormData",
            "members": [],
            "override": "Any `<key: string, value: unknown>` pair"
          },
          "CartBuyerIdentityUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartBuyerIdentityUpdateProps",
            "value": "{\n  action: 'BuyerIdentityUpdate';\n  inputs?: {\n    buyerIdentity: CartBuyerIdentityInput;\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"BuyerIdentityUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ buyerIdentity: CartBuyerIdentityInput; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartBuyerIdentityInput": {
            "description": "",
            "name": "CartBuyerIdentityInput",
            "value": "CartBuyerIdentityInput",
            "members": [],
            "override": "[CartBuyerIdentityInput](/docs/api/storefront/2024-07/input-objects/CartBuyerIdentityInput) - Storefront API type"
          },
          "CartCreateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartCreateProps",
            "value": "{\n  action: 'Create';\n  inputs?: {\n    input: CartInput;\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"Create\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ input: CartInput; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartInput": {
            "description": "",
            "name": "CartInput",
            "value": "CartInput",
            "members": [],
            "override": "[CartInput](/docs/api/storefront/2024-07/input-objects/CartInput) - Storefront API type"
          },
          "CartDiscountCodesUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartDiscountCodesUpdateProps",
            "value": "{\n  action: 'DiscountCodesUpdate';\n  inputs?: {\n    discountCodes: string[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"DiscountCodesUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ discountCodes: string[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartGiftCardCodesUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartGiftCardCodesUpdateProps",
            "value": "{\n  action: 'GiftCardCodesUpdate';\n  inputs?: {\n    giftCardCodes: string[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"GiftCardCodesUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ giftCardCodes: string[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartLinesAddProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartLinesAddProps",
            "value": "{\n  action: 'LinesAdd';\n  inputs?: {\n    lines: Array<OptimisticCartLineInput>;\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"LinesAdd\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ lines: OptimisticCartLineInput[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "OptimisticCartLineInput": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticCartLineInput",
            "value": "CartLineInput & {\n  selectedVariant?: unknown;\n}",
            "description": ""
          },
          "CartLineInput": {
            "description": "",
            "name": "CartLineInput",
            "value": "CartLineInput",
            "members": [],
            "override": "[CartLineInput](/docs/api/storefront/2024-07/input-objects/CartLineInput) - Storefront API type"
          },
          "CartLinesUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartLinesUpdateProps",
            "value": "{\n  action: 'LinesUpdate';\n  inputs?: {\n    lines: CartLineUpdateInput[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"LinesUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ lines: CartLineUpdateInput[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartLineUpdateInput": {
            "description": "",
            "name": "CartLineUpdateInput",
            "value": "CartLineUpdateInput",
            "members": [],
            "override": "[CartLineUpdateInput](/docs/api/storefront/2024-07/input-objects/CartLineUpdateInput) - Storefront API type"
          },
          "CartLinesRemoveProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartLinesRemoveProps",
            "value": "{\n  action: 'LinesRemove';\n  inputs?: {\n    lineIds: string[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"LinesRemove\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ lineIds: string[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartNoteUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartNoteUpdateProps",
            "value": "{\n  action: 'NoteUpdate';\n  inputs?: {\n    note: string;\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"NoteUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ note: string; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartSelectedDeliveryOptionsUpdateProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartSelectedDeliveryOptionsUpdateProps",
            "value": "{\n  action: 'SelectedDeliveryOptionsUpdate';\n  inputs?: {\n    selectedDeliveryOptions: CartSelectedDeliveryOptionInput[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"SelectedDeliveryOptionsUpdate\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ selectedDeliveryOptions: CartSelectedDeliveryOptionInput[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartSelectedDeliveryOptionInput": {
            "description": "",
            "name": "CartSelectedDeliveryOptionInput",
            "value": "CartSelectedDeliveryOptionInput",
            "members": [],
            "override": "[CartSelectedDeliveryOptionInput](/docs/api/storefront/2024-07/input-objects/CartSelectedDeliveryOptionInput) - Storefront API type"
          },
          "CartMetafieldsSetProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartMetafieldsSetProps",
            "value": "{\n  action: 'MetafieldsSet';\n  inputs?: {\n    metafields: MetafieldWithoutOwnerId[];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"MetafieldsSet\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ metafields: MetafieldWithoutOwnerId[]; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "MetafieldWithoutOwnerId": {
            "description": "",
            "name": "MetafieldWithoutOwnerId",
            "value": "MetafieldWithoutOwnerId",
            "members": [],
            "override": "Same as [CartMetafieldsSetInput](https://shopify.dev/docs/api/storefront/2024-07/input-objects/CartMetafieldsSetInput) Storefront API type but without `ownerId`. `ownerId` is always set to the cart id."
          },
          "CartMetafieldDeleteProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartMetafieldDeleteProps",
            "value": "{\n  action: 'MetafieldsDelete';\n  inputs?: {\n    key: Scalars['String']['input'];\n  } & OtherFormData;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "\"MetafieldsDelete\"",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "{ key: string; } & OtherFormData",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartCustomProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartCustomProps",
            "value": "{\n  action: `Custom${string}`;\n  inputs?: Record<string, unknown>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "action",
                "value": "`Custom${string}`",
                "description": ""
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputs",
                "value": "Record<string, unknown>",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CartFormCommonProps": {
            "filePath": "src/cart/CartForm.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartFormCommonProps",
            "value": "{\n  /**\n   * Children nodes of CartForm.\n   * Children can be a render prop that receives the fetcher.\n   */\n  children: ReactNode | ((fetcher: FetcherWithComponents<any>) => ReactNode);\n  /**\n   * The route to submit the form to. Defaults to the current route.\n   */\n  route?: string;\n  /**\n   * Optional key to use for the fetcher.\n   * @see https://remix.run/hooks/use-fetcher#key\n   */\n  fetcherKey?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "ReactNode | ((fetcher: FetcherWithComponents<any>) => ReactNode)",
                "description": "Children nodes of CartForm. Children can be a render prop that receives the fetcher."
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "fetcherKey",
                "value": "string",
                "description": "Optional key to use for the fetcher.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/CartForm.tsx",
                "syntaxKind": "PropertySignature",
                "name": "route",
                "value": "string",
                "description": "The route to submit the form to. Defaults to the current route.",
                "isOptional": true
              }
            ]
          }
        }
      }
    ],
    "examples": {
      "description": "Examples of various ways to use the `CartForm` component.",
      "exampleGroups": [
        {
          "title": "CartForm using HTML input tags as form inputs",
          "examples": [
            {
              "description": "Use HTML input tags with CartForm to accept form inputs.",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {json} from '@remix-run/server-runtime';\nimport {CartForm} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport default function Note() {\n  return (\n    &lt;CartForm action={CartForm.ACTIONS.NoteUpdate}&gt;\n      &lt;input type=\"text\" name=\"note\" /&gt;\n      &lt;button&gt;Update Note&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}) {\n  const cart = context.cart;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result;\n\n  if (action === CartForm.ACTIONS.NoteUpdate) {\n    result = await cart.updateNote(inputs.note);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "jsx"
                  },
                  {
                    "title": "TypeScript",
                    "code": "import {type ActionFunctionArgs, json} from '@remix-run/server-runtime';\nimport {\n  type CartQueryDataReturn,\n  type HydrogenCart,\n  CartForm,\n} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport default function Note() {\n  return (\n    &lt;CartForm action={CartForm.ACTIONS.NoteUpdate}&gt;\n      &lt;input type=\"text\" name=\"note\" /&gt;\n      &lt;button&gt;Update Note&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}: ActionFunctionArgs) {\n  const cart = context.cart as HydrogenCart;\n  // cart is type HydrogenCart or HydrogenCartCustom\n  // Declare cart type in remix.env.d.ts for interface AppLoadContext to avoid type casting\n  // const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result: CartQueryDataReturn;\n\n  if (action === CartForm.ACTIONS.NoteUpdate) {\n    result = await cart.updateNote(inputs.note);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "tsx"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "Custom actions",
          "examples": [
            {
              "description": "Create custom actions to accept form inputs of unknown type. Just prepend `Custom` in front of your custom action name.",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {json} from '@remix-run/server-runtime';\nimport {CartForm} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport default function Cart() {\n  return (\n    &lt;CartForm\n      action=\"CustomEditInPlace\"\n      inputs={{\n        addLines: [\n          {\n            merchandiseId: 'gid://shopify/Product/123456789',\n            quantity: 1,\n          },\n        ],\n        removeLines: ['gid://shopify/CartLine/123456789'],\n      }}\n    &gt;\n      &lt;button&gt;Green color swatch&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}) {\n  const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result;\n\n  if (action === 'CustomEditInPlace') {\n    result = await cart.addLines(inputs.addLines);\n    result = await cart.removeLines(inputs.removeLines);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "jsx"
                  },
                  {
                    "title": "TypeScript",
                    "code": "import {type ActionFunctionArgs, json} from '@remix-run/server-runtime';\nimport {\n  type CartQueryDataReturn,\n  type HydrogenCart,\n  CartForm,\n} from '@shopify/hydrogen';\nimport {type CartLineInput} from '@shopify/hydrogen-react/storefront-api-types';\nimport invariant from 'tiny-invariant';\n\nexport default function Cart() {\n  return (\n    &lt;CartForm\n      action=\"CustomEditInPlace\"\n      inputs={{\n        addLines: [\n          {\n            merchandiseId: 'gid://shopify/Product/123456789',\n            quantity: 1,\n          },\n        ],\n        removeLines: ['gid://shopify/CartLine/123456789'],\n      }}\n    &gt;\n      &lt;button&gt;Green color swatch&lt;/button&gt;\n    &lt;/CartForm&gt;\n  );\n}\n\nexport async function action({request, context}: ActionFunctionArgs) {\n  const cart = context.cart as HydrogenCart;\n  // cart is type HydrogenCart or HydrogenCartCustom\n  // Declare cart type in remix.env.d.ts for interface AppLoadContext to avoid type casting\n  // const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result: CartQueryDataReturn;\n\n  if (action === 'CustomEditInPlace') {\n    result = await cart.addLines(inputs.addLines as CartLineInput[]);\n    result = await cart.removeLines(inputs.removeLines as string[]);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "tsx"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "CartForm with fetcher",
          "examples": [
            {
              "description": "Use `CartForm` with a fetcher to manually submit the form. An example usage is to submit the form on changes to the state of a checkbox.\n\nWhen using fetcher to submit, make sure to have a `CartForm.INPUT_NAME` data key and its data should be a JSON stringify object.",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {useFetcher} from '@remix-run/react';\nimport {json} from '@remix-run/server-runtime';\nimport {CartForm} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\n\nexport function ThisIsGift({metafield}) {\n  const fetcher = useFetcher();\n\n  const buildFormInput = (event) =&gt; ({\n    action: CartForm.ACTIONS.MetafieldsSet,\n    inputs: {\n      metafields: [\n        {\n          key: 'custom.gift',\n          type: 'boolean',\n          value: event.target.checked.toString(),\n        },\n      ],\n    },\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        checked={metafield?.value === 'true'}\n        type=\"checkbox\"\n        id=\"isGift\"\n        onChange={(event) =&gt; {\n          fetcher.submit(\n            {\n              [CartForm.INPUT_NAME]: JSON.stringify(buildFormInput(event)),\n            },\n            {method: 'POST', action: '/cart'},\n          );\n        }}\n      /&gt;\n      &lt;label htmlFor=\"isGift\"&gt;This is a gift&lt;/label&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport async function action({request, context}) {\n  const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result;\n\n  if (action === CartForm.ACTIONS.MetafieldsSet) {\n    result = await cart.setMetafields(inputs.metafields);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "jsx"
                  },
                  {
                    "title": "TypeScript",
                    "code": "import {useFetcher} from '@remix-run/react';\nimport {type ActionFunctionArgs, json} from '@remix-run/server-runtime';\nimport {\n  type CartQueryDataReturn,\n  type HydrogenCart,\n  CartForm,\n  type CartActionInput,\n} from '@shopify/hydrogen';\nimport invariant from 'tiny-invariant';\nimport type {Cart} from '@shopify/hydrogen/storefront-api-types';\n\nexport function ThisIsGift({metafield}: {metafield: Cart['metafield']}) {\n  const fetcher = useFetcher();\n\n  const buildFormInput: (\n    event: React.ChangeEvent&lt;HTMLInputElement&gt;,\n  ) =&gt; CartActionInput = (event) =&gt; ({\n    action: CartForm.ACTIONS.MetafieldsSet,\n    inputs: {\n      metafields: [\n        {\n          key: 'custom.gift',\n          type: 'boolean',\n          value: event.target.checked.toString(),\n        },\n      ],\n    },\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        checked={metafield?.value === 'true'}\n        type=\"checkbox\"\n        id=\"isGift\"\n        onChange={(event) =&gt; {\n          fetcher.submit(\n            {\n              [CartForm.INPUT_NAME]: JSON.stringify(buildFormInput(event)),\n            },\n            {method: 'POST', action: '/cart'},\n          );\n        }}\n      /&gt;\n      &lt;label htmlFor=\"isGift\"&gt;This is a gift&lt;/label&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport async function action({request, context}: ActionFunctionArgs) {\n  const cart = context.cart as HydrogenCart;\n  // cart is type HydrogenCart or HydrogenCartCustom\n  // Declare cart type in remix.env.d.ts for interface AppLoadContext to avoid type casting\n  // const {cart} = context;\n\n  const formData = await request.formData();\n  const {action, inputs} = CartForm.getFormInput(formData);\n\n  let status = 200;\n  let result: CartQueryDataReturn;\n\n  if (action === CartForm.ACTIONS.MetafieldsSet) {\n    result = await cart.setMetafields(inputs.metafields);\n  } else {\n    invariant(false, `${action} cart action is not defined`);\n  }\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {status, headers});\n}\n",
                    "language": "tsx"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "cartGetIdDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that returns the cart id from request header cookie.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartGetIdDefault, cartSetIdDefault} from '@shopify/hydrogen';\n\n// server.js\nexport default {\n  async fetch(request) {\n    const cart = createCartHandler({\n      storefront,\n      getCartId: cartGetIdDefault(request.headers),\n      setCartId: cartSetIdDefault(),\n    });\n  },\n};\n\n// Some route\nexport async function loader({context}) {\n  const {cart} = context;\n\n  cart.getCartId(); // gid://shopify/Cart/1234567890\n}\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartGetIdDefault",
        "description": "",
        "type": "CartGetIdDefaultGeneratedType",
        "typeDefinitions": {
          "CartGetIdDefaultGeneratedType": {
            "filePath": "src/cart/cartGetIdDefault.ts",
            "name": "CartGetIdDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "requestHeaders",
                "description": "",
                "value": "{ [key: string]: any; get?: (key: string) => string; }",
                "filePath": "src/cart/cartGetIdDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/cartGetIdDefault.ts",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "cartGetIdDefault = (\n  requestHeaders: CrossRuntimeRequest['headers'],\n) => {\n  const cookies = parse(getHeaderValue(requestHeaders, 'Cookie') || '');\n  return () => {\n    return cookies.cart ? `gid://shopify/Cart/${cookies.cart}` : undefined;\n  };\n}"
          }
        }
      }
    ]
  },
  {
    "name": "cartSetIdDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that returns a header with a Set-Cookie on the cart ID.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@remix-run/server-runtime';\nimport {cartGetIdDefault, cartSetIdDefault} from '@shopify/hydrogen';\n\n// server.js\nexport default {\n  async fetch(request) {\n    const cart = createCartHandler({\n      storefront,\n      getCartId: cartGetIdDefault(request.headers),\n      setCartId: cartSetIdDefault(), // defaults to session cookie\n      // setCartId: cartSetIdDefault({maxage: 60 * 60 * 24 * 365}), // 1 year expiry\n    });\n  },\n};\n\n// Some route\nexport async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateNote('Some note');\n\n  const headers = cart.setCartId(result.cart.id);\n\n  return json(result, {headers});\n}\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartSetIdDefault",
        "description": "",
        "type": "CartSetIdDefaultGeneratedType",
        "typeDefinitions": {
          "CartSetIdDefaultGeneratedType": {
            "filePath": "src/cart/cartSetIdDefault.ts",
            "name": "CartSetIdDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "cookieOptions",
                "description": "",
                "value": "CookieOptions",
                "isOptional": true,
                "filePath": "src/cart/cartSetIdDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/cartSetIdDefault.ts",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "cartSetIdDefault = (cookieOptions?: CookieOptions) => {\n  return (cartId: string) => {\n    const headers = new Headers();\n    headers.append(\n      'Set-Cookie',\n      stringify('cart', cartId.split('/').pop() || '', {\n        path: '/',\n        ...cookieOptions,\n      }),\n    );\n    return headers;\n  };\n}"
          },
          "CookieOptions": {
            "filePath": "src/cart/cartSetIdDefault.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CookieOptions",
            "value": "{\n  maxage?: number;\n  expires?: Date | number | string;\n  samesite?: 'Lax' | 'Strict' | 'None';\n  secure?: boolean;\n  httponly?: boolean;\n  domain?: string;\n  path?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "domain",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "expires",
                "value": "Date | number | string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "httponly",
                "value": "boolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxage",
                "value": "number",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "samesite",
                "value": "'Lax' | 'Strict' | 'None'",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/cart/cartSetIdDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "secure",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "createCartHandler",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates an API that can be used to interact with the cart.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {\n  createStorefrontClient,\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request, env, executionContext) {\n    const {storefront} = createStorefrontClient({\n      /* client parameters */\n    });\n\n    // Create a cart api instance.\n    const cart = createCartHandler({\n      storefront,\n      getCartId: cartGetIdDefault(request.headers),\n      setCartId: cartSetIdDefault(),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      getLoadContext: () =&gt; ({\n        storefront,\n        cart, // Pass the cart api instance to the loader context.\n      }),\n    });\n\n    return await handleRequest(request);\n  },\n};\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  createStorefrontClient,\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ): Promise&lt;Response&gt; {\n    const {storefront} = createStorefrontClient({\n      /* client parameters */\n    });\n\n    // Create a cart api instance.\n    const cart = createCartHandler({\n      storefront,\n      getCartId: cartGetIdDefault(request.headers),\n      setCartId: cartSetIdDefault(),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      getLoadContext: () =&gt; ({\n        storefront,\n        cart, // Pass the cart api instance to the loader context.\n      }),\n    });\n\n    return await handleRequest(request);\n  },\n};\n",
            "language": "ts"
          }
        ],
        "title": "server.(js|ts)"
      }
    },
    "definitions": [
      {
        "title": "createCartHandler(options)",
        "description": "",
        "type": "CartHandlerOptionsForDocs",
        "typeDefinitions": {
          "CartHandlerOptionsForDocs": {
            "filePath": "src/cart/createCartHandler.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartHandlerOptionsForDocs",
            "value": "{\n  /**\n   * A function that returns the cart id in the form of `gid://shopify/Cart/c1-123`.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * A function that sets the cart ID.\n   */\n  setCartId: (cartId: string) => Headers;\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/2024-07/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * The cart mutation fragment used in most mutation requests, except for `setMetafields` and `deleteMetafield`.\n   * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.\n   */\n  cartMutateFragment?: string;\n  /**\n   * The cart query fragment used by `cart.get()`.\n   * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.\n   */\n  cartQueryFragment?: string;\n  /**\n   * Define custom methods or override existing methods for your cart API instance.\n   * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-custom-methods) in the documentation.\n   */\n  customMethods?: TCustomMethods;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartMutateFragment",
                "value": "string",
                "description": "The cart mutation fragment used in most mutation requests, except for `setMetafields` and `deleteMetafield`. See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartQueryFragment",
                "value": "string",
                "description": "The cart query fragment used by `cart.get()`. See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "customMethods",
                "value": "TCustomMethods",
                "description": "Define custom methods or override existing methods for your cart API instance. See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-custom-methods) in the documentation.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart id in the form of `gid://shopify/Cart/c1-123`."
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "setCartId",
                "value": "(cartId: string) => Headers",
                "description": "A function that sets the cart ID."
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/2024-07/utilities/createstorefrontclient)."
              }
            ]
          },
          "Headers": {
            "description": "",
            "name": "Headers",
            "value": "Headers",
            "members": [],
            "override": "[Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) - Web API"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          }
        }
      },
      {
        "title": "Returns",
        "description": "The handler returns the following default methods. Any [custom](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-custom-methods) or overwritten methods will also be available in the returned cart instance.",
        "type": "HydrogenCartForDocs",
        "typeDefinitions": {
          "HydrogenCartForDocs": {
            "filePath": "src/cart/createCartHandler.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenCartForDocs",
            "value": "{\n  /**\n   * Adds items to the cart.\n   * If the cart doesn't exist, a new one will be created.\n   */\n  addLines?: CartLinesAddFunction;\n  /**\n   * Creates a new cart.\n   */\n  create?: CartCreateFunction;\n  /**\n   * Removes a custom field (metafield) from the cart.\n   */\n  deleteMetafield?: CartMetafieldDeleteFunction;\n  /**\n   * Retrieves the cart information.\n   */\n  get?: CartGetFunction;\n  /**\n   * Retrieves the unique identifier of the cart.\n   * By default, it gets the ID from the request cookie.\n   */\n  getCartId?: () => string | undefined;\n  /**\n   * Removes items from the cart.\n   */\n  removeLines?: CartLinesRemoveFunction;\n  /**\n   * Sets the unique identifier of the cart.\n   * By default, it sets the ID in the header cookie.\n   */\n  setCartId?: (cartId: string) => Headers;\n  /**\n   * Adds extra information (metafields) to the cart.\n   * If the cart doesn't exist, a new one will be created.\n   */\n  setMetafields?: CartMetafieldsSetFunction;\n  /**\n   * Updates additional information (attributes) in the cart.\n   */\n  updateAttributes?: CartAttributesUpdateFunction;\n  /**\n   * Updates the buyer's information in the cart.\n   * If the cart doesn't exist, a new one will be created.\n   */\n  updateBuyerIdentity?: CartBuyerIdentityUpdateFunction;\n  /**\n   * Updates discount codes in the cart.\n   */\n  updateDiscountCodes?: CartDiscountCodesUpdateFunction;\n  /**\n   * Updates gift card codes in the cart.\n   */\n  updateGiftCardCodes?: CartGiftCardCodesUpdateFunction;\n  /**\n   * Updates items in the cart.\n   */\n  updateLines?: CartLinesUpdateFunction;\n  /**\n   * Updates the note in the cart.\n   * If the cart doesn't exist, a new one will be created.\n   */\n  updateNote?: CartNoteUpdateFunction;\n  /**\n   * Updates the selected delivery options in the cart.\n   * Only available for carts associated with a customer access token.\n   */\n  updateSelectedDeliveryOption?: CartSelectedDeliveryOptionsUpdateFunction;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "addLines",
                "value": "CartLinesAddFunction",
                "description": "Adds items to the cart. If the cart doesn't exist, a new one will be created.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "create",
                "value": "CartCreateFunction",
                "description": "Creates a new cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "deleteMetafield",
                "value": "CartMetafieldDeleteFunction",
                "description": "Removes a custom field (metafield) from the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "get",
                "value": "CartGetFunction",
                "description": "Retrieves the cart information.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "Retrieves the unique identifier of the cart. By default, it gets the ID from the request cookie.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "removeLines",
                "value": "CartLinesRemoveFunction",
                "description": "Removes items from the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "setCartId",
                "value": "(cartId: string) => Headers",
                "description": "Sets the unique identifier of the cart. By default, it sets the ID in the header cookie.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "setMetafields",
                "value": "CartMetafieldsSetFunction",
                "description": "Adds extra information (metafields) to the cart. If the cart doesn't exist, a new one will be created.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateAttributes",
                "value": "CartAttributesUpdateFunction",
                "description": "Updates additional information (attributes) in the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateBuyerIdentity",
                "value": "CartBuyerIdentityUpdateFunction",
                "description": "Updates the buyer's information in the cart. If the cart doesn't exist, a new one will be created.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateDiscountCodes",
                "value": "CartDiscountCodesUpdateFunction",
                "description": "Updates discount codes in the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateGiftCardCodes",
                "value": "CartGiftCardCodesUpdateFunction",
                "description": "Updates gift card codes in the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateLines",
                "value": "CartLinesUpdateFunction",
                "description": "Updates items in the cart.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateNote",
                "value": "CartNoteUpdateFunction",
                "description": "Updates the note in the cart. If the cart doesn't exist, a new one will be created.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateSelectedDeliveryOption",
                "value": "CartSelectedDeliveryOptionsUpdateFunction",
                "description": "Updates the selected delivery options in the cart. Only available for carts associated with a customer access token.",
                "isOptional": true
              }
            ]
          },
          "CartLinesAddFunction": {
            "filePath": "src/cart/queries/cartLinesAddDefault.ts",
            "name": "CartLinesAddFunction",
            "description": "",
            "params": [
              {
                "name": "lines",
                "description": "",
                "value": "CartLineInput[]",
                "filePath": "src/cart/queries/cartLinesAddDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesAddDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesAddDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesAddFunction = (\n  lines: Array<CartLineInput>,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartLineInput": {
            "description": "",
            "name": "CartLineInput",
            "value": "CartLineInput",
            "members": [],
            "override": "[CartLineInput](/docs/api/storefront/2024-07/input-objects/CartLineInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "CartCreateFunction": {
            "filePath": "src/cart/queries/cartCreateDefault.ts",
            "name": "CartCreateFunction",
            "description": "",
            "params": [
              {
                "name": "input",
                "description": "",
                "value": "CartInput",
                "filePath": "src/cart/queries/cartCreateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartCreateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartCreateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartCreateFunction = (\n  input: CartInput,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartInput": {
            "description": "",
            "name": "CartInput",
            "value": "CartInput",
            "members": [],
            "override": "[CartInput](/docs/api/storefront/2024-07/input-objects/CartInput) - Storefront API type"
          },
          "CartMetafieldDeleteFunction": {
            "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
            "name": "CartMetafieldDeleteFunction",
            "description": "",
            "params": [
              {
                "name": "key",
                "description": "",
                "value": "string",
                "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartMetafieldDeleteFunction = (\n  key: Scalars['String']['input'],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartGetFunction": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "name": "CartGetFunction",
            "description": "",
            "params": [
              {
                "name": "cartInput",
                "description": "",
                "value": "CartGetProps",
                "isOptional": true,
                "filePath": "src/cart/queries/cartGetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGetDefault.ts",
              "description": "",
              "name": "Promise<CartReturn | null>",
              "value": "Promise<CartReturn | null>"
            },
            "value": "export type CartGetFunction = (\n  cartInput?: CartGetProps,\n) => Promise<CartReturn | null>;"
          },
          "CartGetProps": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartGetProps",
            "value": "{\n  /**\n   * The cart ID.\n   * @default cart.getCartId();\n   */\n  cartId?: string;\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n  /**\n   * The number of cart lines to be returned.\n   * @default 100\n   */\n  numCartLines?: number;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart ID.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "numCartLines",
                "value": "number",
                "description": "The number of cart lines to be returned.",
                "isOptional": true,
                "defaultValue": "100"
              }
            ]
          },
          "CartReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartReturn",
            "value": "Cart & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartLinesRemoveFunction": {
            "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
            "name": "CartLinesRemoveFunction",
            "description": "",
            "params": [
              {
                "name": "lineIds",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartLinesRemoveDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesRemoveDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesRemoveFunction = (\n  lineIds: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "Headers": {
            "description": "",
            "name": "Headers",
            "value": "Headers",
            "members": [],
            "override": "[Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) - Web API"
          },
          "CartMetafieldsSetFunction": {
            "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
            "name": "CartMetafieldsSetFunction",
            "description": "",
            "params": [
              {
                "name": "metafields",
                "description": "",
                "value": "MetafieldWithoutOwnerId[]",
                "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartMetafieldsSetFunction = (\n  metafields: MetafieldWithoutOwnerId[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "MetafieldWithoutOwnerId": {
            "description": "",
            "name": "MetafieldWithoutOwnerId",
            "value": "MetafieldWithoutOwnerId",
            "members": [],
            "override": "Same as [CartMetafieldsSetInput](https://shopify.dev/docs/api/storefront/2024-07/input-objects/CartMetafieldsSetInput) Storefront API type but without `ownerId`. `ownerId` is always set to the cart id."
          },
          "CartAttributesUpdateFunction": {
            "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
            "name": "CartAttributesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "attributes",
                "description": "",
                "value": "AttributeInput[]",
                "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartAttributesUpdateFunction = (\n  attributes: AttributeInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "AttributeInput": {
            "description": "",
            "name": "AttributeInput",
            "value": "AttributeInput",
            "members": [],
            "override": "[AttributeInput](/docs/api/storefront/2024-07/input-objects/AttributeInput) - Storefront API type"
          },
          "CartBuyerIdentityUpdateFunction": {
            "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
            "name": "CartBuyerIdentityUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "buyerIdentity",
                "description": "",
                "value": "CartBuyerIdentityInput",
                "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartBuyerIdentityUpdateFunction = (\n  buyerIdentity: CartBuyerIdentityInput,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartBuyerIdentityInput": {
            "description": "",
            "name": "CartBuyerIdentityInput",
            "value": "CartBuyerIdentityInput",
            "members": [],
            "override": "[CartBuyerIdentityInput](/docs/api/storefront/2024-07/input-objects/CartBuyerIdentityInput) - Storefront API type"
          },
          "CartDiscountCodesUpdateFunction": {
            "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
            "name": "CartDiscountCodesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "discountCodes",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartDiscountCodesUpdateFunction = (\n  discountCodes: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartGiftCardCodesUpdateFunction": {
            "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
            "name": "CartGiftCardCodesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "giftCardCodes",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartGiftCardCodesUpdateFunction = (\n  giftCardCodes: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartLinesUpdateFunction": {
            "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
            "name": "CartLinesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "lines",
                "description": "",
                "value": "CartLineUpdateInput[]",
                "filePath": "src/cart/queries/cartLinesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesUpdateFunction = (\n  lines: CartLineUpdateInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartLineUpdateInput": {
            "description": "",
            "name": "CartLineUpdateInput",
            "value": "CartLineUpdateInput",
            "members": [],
            "override": "[CartLineUpdateInput](/docs/api/storefront/2024-07/input-objects/CartLineUpdateInput) - Storefront API type"
          },
          "CartNoteUpdateFunction": {
            "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
            "name": "CartNoteUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "note",
                "description": "",
                "value": "string",
                "filePath": "src/cart/queries/cartNoteUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartNoteUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartNoteUpdateFunction = (\n  note: string,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartSelectedDeliveryOptionsUpdateFunction": {
            "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
            "name": "CartSelectedDeliveryOptionsUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "selectedDeliveryOptions",
                "description": "",
                "value": "CartSelectedDeliveryOptionInput[]",
                "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartSelectedDeliveryOptionsUpdateFunction = (\n  selectedDeliveryOptions: CartSelectedDeliveryOptionInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartSelectedDeliveryOptionInput": {
            "description": "",
            "name": "CartSelectedDeliveryOptionInput",
            "value": "CartSelectedDeliveryOptionInput",
            "members": [],
            "override": "[CartSelectedDeliveryOptionInput](/docs/api/storefront/2024-07/input-objects/CartSelectedDeliveryOptionInput) - Storefront API type"
          }
        }
      }
    ],
    "examples": {
      "description": "Examples of various ways to use the `createCartHandler` utility.",
      "exampleGroups": [
        {
          "title": "Cart fragments",
          "examples": [
            {
              "description": "Use `cartQueryFragment` and `cartMutateFragment` to change the cart data the queries will return.",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n} from '@shopify/hydrogen';\n\n// Override cart fragments\nconst cart = createCartHandler({\n  storefront,\n  getCartId: cartGetIdDefault(request.headers),\n  setCartId: cartSetIdDefault(),\n  cartQueryFragment: CART_QUERY_FRAGMENT,\n  cartMutateFragment: CART_MUTATE_FRAGMENT,\n});\n\n// cartQueryFragment requirements:\n// - Must be named `CartApiQuery`\n// - Only have access to the following query variables:\n//   - $cartId: ID!\n//   - $country: CountryCode\n//   - $language: LanguageCode\n//   - $numCartLines: Int\nconst CART_QUERY_FRAGMENT = `#graphql\n  fragment CartApiQuery on Cart {\n    id\n    totalQuantity\n    checkoutUrl\n    note\n  }\n`;\n\n// cartMutateFragment requirements:\n// - Must be named `CartApiMutation`\n// - Only have access to the following query variables:\n//   - $cartId: ID!\n//   - $country: CountryCode\n//   - $language: LanguageCode\nconst CART_MUTATE_FRAGMENT = `#graphql\n  fragment CartApiMutation on Cart {\n    id\n    totalQuantity\n    checkoutUrl\n    lines(first: 100) {\n      edges {\n        node {\n          id\n          quantity\n        }\n      }\n    }\n  }\n`;\n",
                    "language": "js"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "Custom methods",
          "examples": [
            {
              "description": "Define or override methods in your cart handler instance. Note that for addLines, updateDiscountCodes, updateBuyerIdentity, updateNote, updateAttributes, and setMetafields, if you override any of these methods, a new cart will not be created unless you implement the cart creation logic in your overriding method.",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n  cartLinesAddDefault,\n  cartLinesRemoveDefault,\n} from '@shopify/hydrogen';\n\nconst cartQueryOptions = {\n  storefront,\n  getCartId: cartGetIdDefault(request.headers),\n};\n\nconst getCartId = cartGetIdDefault(request.headers);\n\nconst cart = createCartHandler({\n  storefront,\n  getCartId,\n  setCartId: cartSetIdDefault(),\n  customMethods: {\n    editInLine: async (addLines, removeLineIds, optionalParams) =&gt; {\n      // Using Hydrogen default cart query methods\n      await cartLinesAddDefault(cartQueryOptions)(addLines, optionalParams);\n      return await cartLinesRemoveDefault(cartQueryOptions)(\n        removeLineIds,\n        optionalParams,\n      );\n    },\n    addLines: async (lines, optionalParams) =&gt; {\n      // With your own Storefront API graphql query\n      return await storefront.mutate(CART_LINES_ADD_MUTATION, {\n        variables: {\n          id: optionalParams.cartId || getCartId(),\n          lines,\n        },\n      });\n    },\n  },\n});\n\n// Use custom method editInLine that delete and add items in one method\ncart.editInLine(\n  ['123'],\n  [\n    {\n      merchandiseId: 'gid://shopify/ProductVariant/456789123',\n      quantity: 1,\n    },\n  ],\n);\n\n// Use overridden cart.addLines\nconst result = await cart.addLines(\n  [\n    {\n      merchandiseId: 'gid://shopify/ProductVariant/123456789',\n      quantity: 1,\n    },\n  ],\n  {\n    cartId: 'c-123',\n  },\n);\n// Output of result:\n// {\n//   cartLinesAdd: {\n//     cart: {\n//       id: 'c-123',\n//       totalQuantity: 1\n//     },\n//     errors: []\n//   }\n// }\n\nconst CART_LINES_ADD_MUTATION = `#graphql\n  mutation CartLinesAdd(\n    $cartId: ID!\n    $lines: [CartLineInput!]!\n    $country: CountryCode = ZZ\n    $language: LanguageCode\n  ) @inContext(country: $country, language: $language) {\n    cartLinesAdd(cartId: $cartId, lines: $lines) {\n      cart {\n        id\n        totalQuantity\n      }\n      errors: userErrors {\n        message\n        field\n        code\n      }\n    }\n  }\n`;\n",
                    "language": "js"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "Cart instance usage",
          "examples": [
            {
              "description": "Add items to the cart. If the cart does not exist, a new cart will be created.",
              "codeblock": {
                "title": "cart.addLines",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.addLines(\n    [\n      {\n        merchandiseId: 'gid://shopify/ProductVariant/123456789',\n        quantity: 1,\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n}\n\n// Output of result:\n// {\n//   cart: {\n//     id: 'c1-123',\n//     totalQuantity: 1\n//   },\n//   errors: []\n// }\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Create a new cart.",
              "codeblock": {
                "title": "cart.create",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.create(\n    {\n      lines: [\n        {\n          merchandiseId: 'gid://shopify/ProductVariant/123456789',\n          quantity: 1,\n        },\n      ],\n      discountCodes: ['FREE_SHIPPING'],\n    },\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 1,\n  //     discountCodes: [{ code: 'FREE_SHIPPING'}]\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Delete extra information (metafield) from the cart.",
              "codeblock": {
                "title": "cart.deleteMetafield",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.setMetafields(\n    [\n      {\n        key: 'custom.gift',\n        type: 'boolean',\n        value: 'true',\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n\n  const result2 = await cart.deleteMetafield(\n    'custom.gift',\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n}\n\n// server.js\n// To query for metafields, use the `cartQueryFragment` option when creating the cart handler.\nimport {\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n} from '@shopify/hydrogen';\n\nconst cart = createCartHandler({\n  storefront,\n  getCartId: cartGetIdDefault(request.headers),\n  setCartId: cartSetIdDefault(),\n  cartQueryFragment: CART_QUERY_FRAGMENT,\n});\n\nconst CART_QUERY_FRAGMENT = `#graphql\n  fragment CartApiQuery on Cart {\n    id\n    metafields(\n      identifiers: [{\n        namespace: \"custom\",\n        key: \"gift\"\n      ])\n    {\n      namespace\n      key\n      type\n      value\n    }\n\n  }\n`;\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Retrieve the cart information.",
              "codeblock": {
                "title": "cart.get",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function loader({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.get();\n\n  // Optional parameters\n  const result2 = await cart.get({\n    cartId: '123', // override the cart id\n    numCartLines: 50, //override to return 50 cart lines\n    country: 'US', // override the country code to 'US'\n    language: 'EN', // override the language code to 'EN'\n  });\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Get the unique identifier of the cart.",
              "codeblock": {
                "title": "cart.getCartId",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function loader({context}) {\n  // Usage\n  context.cart.getCartId(); // 'gid://shopify/Cart/123'\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Remove items from the cart.",
              "codeblock": {
                "title": "cart.removeLines",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.removeLines(\n    ['123'],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 0\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Set the unique identifier of the cart.",
              "codeblock": {
                "title": "cart.setCartId",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  const result = await cart.addLines([\n    {\n      merchandiseId: 'gid://shopify/ProductVariant/123456789',\n      quantity: 1,\n    },\n  ]);\n\n  // Usage\n  const headers = cart.setCartId(result.cart.id);\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Add extra information (metafields) to the cart. If the cart does not exist, a new cart will be created.",
              "codeblock": {
                "title": "cart.setMetafields",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.setMetafields(\n    [\n      {\n        key: 'custom.gift',\n        type: 'boolean',\n        value: 'true',\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n\n  const result2 = await cart.deleteMetafield(\n    'custom.gift',\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n}\n\n// server.js\n// To query for metafields, use the `cartQueryFragment` option when creating the cart handler.\nimport {\n  createCartHandler,\n  cartGetIdDefault,\n  cartSetIdDefault,\n} from '@shopify/hydrogen';\n\nconst cart = createCartHandler({\n  storefront,\n  getCartId: cartGetIdDefault(request.headers),\n  setCartId: cartSetIdDefault(),\n  cartQueryFragment: CART_QUERY_FRAGMENT,\n});\n\nconst CART_QUERY_FRAGMENT = `#graphql\n  fragment CartApiQuery on Cart {\n    id\n    metafields(\n      identifiers: [{\n        namespace: \"custom\",\n        key: \"gift\"\n      ])\n    {\n      namespace\n      key\n      type\n      value\n    }\n\n  }\n`;\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update additional information (attributes) in the cart. If the cart does not exist, a new cart will be created.",
              "codeblock": {
                "title": "cart.updateAttributes",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateAttributes(\n    [\n      {\n        key: 'Somekey',\n        value: '1',\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 1\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update the buyers information in the cart. If the cart does not exist, a new cart will be created.",
              "codeblock": {
                "title": "cart.updateBuyerIdentity",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateBuyerIdentity(\n    {\n      customerAccessToken: '123',\n    },\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 1\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update discount codes in the cart.",
              "codeblock": {
                "title": "cart.updateDiscountCodes",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateDiscountCodes(\n    ['FREE_SHIPPING'],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 1\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update gift card codes in the cart.",
              "codeblock": {
                "title": "cart.updateGiftCardCodes",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateGiftCardCodes(\n    ['ABC123'],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     appliedGiftCards: [{\n  //       lastCharacters: 'C123',\n  //       amountUsed: {\n  //         amount: 10,\n  //         currencyCode: 'USD',\n  //       }\n  //     }],\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update items in the cart.",
              "codeblock": {
                "title": "cart.updateLines",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateLines(\n    [\n      {\n        merchandiseId: 'gid://shopify/ProductVariant/123456789',\n        quantity: 2,\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 2\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update the note in the cart. If the cart does not exist, a new cart will be created.",
              "codeblock": {
                "title": "cart.updateNote",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateNote(\n    'Some notes',\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 0\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            },
            {
              "description": "Update the selected delivery options in the cart. Only available for carts associated with a customer access token.",
              "codeblock": {
                "title": "cart.updateSelectedDeliveryOptions",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "export async function action({context}) {\n  const {cart} = context;\n\n  // Usage\n  const result = await cart.updateSelectedDeliveryOptions(\n    [\n      {\n        deliveryGroupId: '123',\n        deliveryOptionHandle: 'Canada Post',\n      },\n    ],\n    // Optional parameters\n    {\n      cartId: '123', // override the cart id\n      country: 'US', // override the country code to 'US'\n      language: 'EN', // override the language code to 'EN'\n    },\n  );\n\n  // Output of result:\n  // {\n  //   cart: {\n  //     id: 'c1-123',\n  //     totalQuantity: 2\n  //   },\n  //   errors: []\n  // }\n}\n",
                    "language": "js"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "useOptimisticCart",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [
      {
        "name": "CartForm",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/cartform"
      }
    ],
    "description": "The `useOptimisticCart` takes an existing cart object, processes all pending cart actions, and locally mutates the cart with optimistic state. An optimistic cart makes cart actions immediately render in the browser while actions sync to the server. This increases the perceived performance of the application.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {defer} from '@shopify/remix-oxygen';\nimport {Link} from '@remix-run/react';\nimport {CartForm, useOptimisticCart} from '@shopify/hydrogen';\n\n// Root loader returns the cart data\nexport async function loader({context}) {\n  return defer({\n    cart: context.cart.get(),\n  });\n}\n\n// The cart component renders each line item in the cart.\nexport function Cart({cart}) {\n  // `useOptimisticCart` adds optimistic line items to the cart.\n  // These line items are displayed in the cart until the server responds.\n  const optimisticCart = useOptimisticCart(cart);\n\n  if (!optimisticCart?.lines?.nodes?.length) return &lt;p&gt;Nothing in cart&lt;/p&gt;;\n\n  return optimisticCart.lines.nodes.map((line) =&gt; (\n    &lt;div key={line.id}&gt;\n      &lt;Link to={`/products${line.merchandise.product.handle}`}&gt;\n        {line.merchandise.product.title}\n      &lt;/Link&gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{lineIds: [line.id]}}\n      &gt;\n        {/* Each line item has an `isOptimistic` property. Optimistic line items\n        should have actions disabled */}\n        &lt;button type=\"submit\" disabled={!!line.isOptimistic}&gt;\n          Remove\n        &lt;/button&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  ));\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {defer, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {Link} from '@remix-run/react';\nimport {CartForm, useOptimisticCart} from '@shopify/hydrogen';\nimport type {Cart} from '@shopify/hydrogen/storefront-api-types';\n\n// Root loader returns the cart data\nexport async function loader({context}: LoaderFunctionArgs) {\n  return defer({\n    cart: context.cart.get(),\n  });\n}\n\n// The cart component renders each line item in the cart.\nexport function Cart({cart: originalCart}: {cart: Cart}) {\n  // `useOptimisticCart` adds optimistic line items to the cart.\n  // These line items are displayed in the cart until the server responds.\n  const cart = useOptimisticCart(originalCart);\n  if (!cart?.lines?.nodes?.length) return &lt;p&gt;Nothing in cart&lt;/p&gt;;\n\n  return cart.lines.nodes.map((line) =&gt; (\n    &lt;div key={line.id}&gt;\n      &lt;Link to={`/products${line.merchandise.product.handle}`}&gt;\n        {line.merchandise.product.title}\n      &lt;/Link&gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{lineIds: [line.id]}}\n      &gt;\n        {/* Each line item has an `isOptimistic` property. Optimistic line items\n        should have actions disabled */}\n        &lt;button type=\"submit\" disabled={!!line.isOptimistic}&gt;\n          Remove\n        &lt;/button&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  ));\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "UseOptimisticCartGeneratedType",
        "typeDefinitions": {
          "UseOptimisticCartGeneratedType": {
            "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
            "name": "UseOptimisticCartGeneratedType",
            "description": "",
            "params": [
              {
                "name": "cart",
                "description": "The cart object from `context.cart.get()` returned by a server loader.",
                "value": "DefaultCart",
                "isOptional": true,
                "filePath": "src/cart/optimistic/useOptimisticCart.tsx"
              }
            ],
            "returns": {
              "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
              "description": "A new cart object augmented with optimistic state for `lines` and `totalQuantity`. Each cart line item that is optimistically added includes an `isOptimistic` property. Also if the cart has _any_ optimistic state, a root property `isOptimistic` will be set to `true`.",
              "name": "OptimisticCart<DefaultCart = {\n    lines?: {\n      nodes: Array<{id: string; quantity: number; merchandise: {is: string}}>;\n    };\n  }>",
              "value": "OptimisticCart<DefaultCart = {\n    lines?: {\n      nodes: Array<{id: string; quantity: number; merchandise: {is: string}}>;\n    };\n  }>"
            },
            "value": "export function useOptimisticCart<\n  DefaultCart = {\n    lines?: {\n      nodes: Array<{id: string; quantity: number; merchandise: {is: string}}>;\n    };\n  },\n>(cart?: DefaultCart): OptimisticCart<DefaultCart> {\n  const fetchers = useFetchers();\n\n  if (!fetchers || !fetchers.length) return cart as OptimisticCart<DefaultCart>;\n\n  const optimisticCart = (cart as CartReturn)?.lines\n    ? (structuredClone(cart) as OptimisticCart<DefaultCart>)\n    : ({lines: {nodes: []}} as unknown as OptimisticCart<DefaultCart>);\n\n  const cartLines = optimisticCart.lines.nodes as OptimisticCartLine[];\n\n  let isOptimistic = false;\n\n  for (const {formData} of fetchers) {\n    if (!formData) continue;\n\n    const cartFormData = CartForm.getFormInput(formData);\n\n    if (cartFormData.action === CartForm.ACTIONS.LinesAdd) {\n      for (const input of cartFormData.inputs.lines) {\n        if (!input.selectedVariant) {\n          console.error(\n            '[h2:error:useOptimisticCart] No selected variant was passed in the cart action. Make sure to pass the selected variant if you want to use an optimistic cart',\n          );\n          continue;\n        }\n\n        const existingLine = cartLines.find(\n          (line) =>\n            line.merchandise.id ===\n            (input.selectedVariant as ProductVariant)?.id,\n        );\n\n        isOptimistic = true;\n\n        if (existingLine) {\n          existingLine.quantity =\n            (existingLine.quantity || 1) + (input.quantity || 1);\n          existingLine.isOptimistic = true;\n        } else {\n          cartLines.unshift({\n            id: getOptimisticLineId((input.selectedVariant as any).id),\n            merchandise: input.selectedVariant,\n            isOptimistic: true,\n            quantity: input.quantity || 1,\n          } as CartLine & {isOptimistic?: boolean});\n        }\n      }\n    } else if (cartFormData.action === CartForm.ACTIONS.LinesRemove) {\n      for (const lineId of cartFormData.inputs.lineIds) {\n        const index = cartLines.findIndex((line) => line.id === lineId);\n\n        if (index !== -1) {\n          if (isOptimisticLineId(cartLines[index].id)) {\n            console.error(\n              '[h2:error:useOptimisticCart] Tried to remove an optimistic line that has not been added to the cart yet',\n            );\n            continue;\n          }\n\n          cartLines.splice(index, 1);\n          isOptimistic = true;\n        } else {\n          console.warn(\n            `[h2:warn:useOptimisticCart] Tried to remove line '${lineId}' but it doesn't exist in the cart`,\n          );\n        }\n      }\n    } else if (cartFormData.action === CartForm.ACTIONS.LinesUpdate) {\n      for (const line of cartFormData.inputs.lines) {\n        const index = cartLines.findIndex(\n          (optimisticLine) => line.id === optimisticLine.id,\n        );\n\n        if (index > -1) {\n          if (isOptimisticLineId(cartLines[index].id)) {\n            console.error(\n              '[h2:error:useOptimisticCart] Tried to update an optimistic line that has not been added to the cart yet',\n            );\n            continue;\n          }\n\n          cartLines[index].quantity = line.quantity as number;\n\n          if (cartLines[index].quantity === 0) {\n            cartLines.splice(index, 1);\n          }\n\n          isOptimistic = true;\n        } else {\n          console.warn(\n            `[h2:warn:useOptimisticCart] Tried to update line '${line.id}' but it doesn't exist in the cart`,\n          );\n        }\n      }\n    }\n  }\n\n  if (isOptimistic) {\n    optimisticCart.isOptimistic = isOptimistic;\n  }\n\n  // Calculate the total quantity of the optimistic cart\n  optimisticCart.totalQuantity = cartLines.reduce(\n    (sum, line) => sum + line.quantity,\n    0,\n  );\n\n  return optimisticCart;\n}"
          },
          "DefaultCart": {
            "filePath": "src/analytics-manager/AnalyticsProvider.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DefaultCart",
            "value": "Promise<CartReturn | null> | CartReturn | null",
            "description": ""
          },
          "CartReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartReturn",
            "value": "Cart & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "OptimisticCart": {
            "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticCart",
            "value": "T extends undefined | null\n  ? // This is the null/undefined case, where the cart has yet to be created.\n    // But we still need to provide an optimistic cart object.\n    {\n      isOptimistic?: boolean;\n      lines: {\n        nodes: Array<OptimisticCartLine>;\n      };\n      totalQuantity?: number;\n    } & Omit<PartialDeep<CartReturn>, 'lines'>\n  : Omit<T, 'lines'> & {\n      isOptimistic?: boolean;\n      lines: {\n        nodes: Array<OptimisticCartLine<T>>;\n      };\n      totalQuantity?: number;\n    }",
            "description": ""
          },
          "OptimisticCartLine": {
            "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticCartLine",
            "value": "T extends LikeACart\n  ? T['lines']['nodes'][number] & {isOptimistic?: boolean}\n  : T & {isOptimistic?: boolean}",
            "description": ""
          },
          "LikeACart": {
            "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LikeACart",
            "value": "{\n  lines: {\n    nodes: Array<unknown>;\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/optimistic/useOptimisticCart.tsx",
                "syntaxKind": "PropertySignature",
                "name": "lines",
                "value": "{ nodes: unknown[]; }",
                "description": ""
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "cartAttributesUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of [AttributeInput](/docs/api/storefront/2024-07/input-objects/AttributeInput) and updates attributes to a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartAttributesUpdateDefault} from '@shopify/hydrogen';\n\nconst cartAttributes = cartAttributesUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartAttributes([\n  {\n    key: 'Somekey',\n    value: '1',\n  },\n]);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartAttributesUpdateDefault",
        "description": "",
        "type": "CartAttributesUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartAttributesUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
            "name": "CartAttributesUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
              "description": "",
              "name": "CartAttributesUpdateFunction",
              "value": "CartAttributesUpdateFunction"
            },
            "value": "export function cartAttributesUpdateDefault(\n  options: CartQueryOptions,\n): CartAttributesUpdateFunction {\n  return async (attributes, optionalParams) => {\n    const {cartAttributesUpdate, errors} = await options.storefront.mutate<{\n      cartAttributesUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_ATTRIBUTES_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: optionalParams?.cartId || options.getCartId(),\n        attributes,\n      },\n    });\n    return formatAPIResult(cartAttributesUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartAttributesUpdateFunction": {
            "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
            "name": "CartAttributesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "attributes",
                "description": "",
                "value": "AttributeInput[]",
                "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartAttributesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartAttributesUpdateFunction = (\n  attributes: AttributeInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "AttributeInput": {
            "description": "",
            "name": "AttributeInput",
            "value": "AttributeInput",
            "members": [],
            "override": "[AttributeInput](/docs/api/storefront/2024-07/input-objects/AttributeInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartBuyerIdentityUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an object of [CartBuyerIdentityInput](/docs/api/storefront/2024-07/input-objects/CartBuyerIdentityInput) and updates the buyer identity of a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartBuyerIdentityUpdateDefault} from '@shopify/hydrogen';\n\nconst cartBuyerIdentity = cartBuyerIdentityUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartBuyerIdentity({\n  customerAccessToken: '123',\n});\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartBuyerIdentityUpdateDefault",
        "description": "",
        "type": "CartBuyerIdentityUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartBuyerIdentityUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
            "name": "CartBuyerIdentityUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
              "description": "",
              "name": "CartBuyerIdentityUpdateFunction",
              "value": "CartBuyerIdentityUpdateFunction"
            },
            "value": "export function cartBuyerIdentityUpdateDefault(\n  options: CartQueryOptions,\n): CartBuyerIdentityUpdateFunction {\n  return async (buyerIdentity, optionalParams) => {\n    if (buyerIdentity.companyLocationId && options.customerAccount) {\n      options.customerAccount.UNSTABLE_setBuyer({\n        companyLocationId: buyerIdentity.companyLocationId,\n      });\n    }\n\n    const buyer = options.customerAccount\n      ? await options.customerAccount.UNSTABLE_getBuyer()\n      : undefined;\n\n    const {cartBuyerIdentityUpdate, errors} = await options.storefront.mutate<{\n      cartBuyerIdentityUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_BUYER_IDENTITY_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        buyerIdentity: {\n          ...buyer,\n          ...buyerIdentity,\n        },\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartBuyerIdentityUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartBuyerIdentityUpdateFunction": {
            "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
            "name": "CartBuyerIdentityUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "buyerIdentity",
                "description": "",
                "value": "CartBuyerIdentityInput",
                "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartBuyerIdentityUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartBuyerIdentityUpdateFunction = (\n  buyerIdentity: CartBuyerIdentityInput,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartBuyerIdentityInput": {
            "description": "",
            "name": "CartBuyerIdentityInput",
            "value": "CartBuyerIdentityInput",
            "members": [],
            "override": "[CartBuyerIdentityInput](/docs/api/storefront/2024-07/input-objects/CartBuyerIdentityInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartCreateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an object of [CartInput](/docs/api/storefront/2024-07/input-objects/CartInput) and returns a new cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartCreateDefault} from '@shopify/hydrogen';\n\nconst cartCreate = cartCreateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartCreate({\n  lines: [\n    {\n      merchandiseId: 'gid://shopify/ProductVariant/123456789',\n      quantity: 1,\n    },\n  ],\n});\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartCreateDefault",
        "description": "",
        "type": "CartCreateDefaultGeneratedType",
        "typeDefinitions": {
          "CartCreateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartCreateDefault.ts",
            "name": "CartCreateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartCreateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartCreateDefault.ts",
              "description": "",
              "name": "CartCreateFunction",
              "value": "CartCreateFunction"
            },
            "value": "export function cartCreateDefault(\n  options: CartQueryOptions,\n): CartCreateFunction {\n  return async (input, optionalParams) => {\n    const buyer = options.customerAccount\n      ? await options.customerAccount.UNSTABLE_getBuyer()\n      : undefined;\n    const {cartId, ...restOfOptionalParams} = optionalParams || {};\n    const {buyerIdentity, ...restOfInput} = input;\n    const {cartCreate, errors} = await options.storefront.mutate<{\n      cartCreate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_CREATE_MUTATION(options.cartFragment), {\n      variables: {\n        input: {\n          ...restOfInput,\n          buyerIdentity: {\n            ...buyer,\n            ...buyerIdentity,\n          },\n        },\n        ...restOfOptionalParams,\n      },\n    });\n    return formatAPIResult(cartCreate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartCreateFunction": {
            "filePath": "src/cart/queries/cartCreateDefault.ts",
            "name": "CartCreateFunction",
            "description": "",
            "params": [
              {
                "name": "input",
                "description": "",
                "value": "CartInput",
                "filePath": "src/cart/queries/cartCreateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartCreateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartCreateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartCreateFunction = (\n  input: CartInput,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartInput": {
            "description": "",
            "name": "CartInput",
            "value": "CartInput",
            "members": [],
            "override": "[CartInput](/docs/api/storefront/2024-07/input-objects/CartInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartDiscountCodesUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of strings and adds the discount codes to a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartDiscountCodesUpdateDefault} from '@shopify/hydrogen';\n\nconst cartDiscount = cartDiscountCodesUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartDiscount(['FREE_SHIPPING']);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartDiscountCodesUpdateDefault",
        "description": "",
        "type": "CartDiscountCodesUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartDiscountCodesUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
            "name": "CartDiscountCodesUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
              "description": "",
              "name": "CartDiscountCodesUpdateFunction",
              "value": "CartDiscountCodesUpdateFunction"
            },
            "value": "export function cartDiscountCodesUpdateDefault(\n  options: CartQueryOptions,\n): CartDiscountCodesUpdateFunction {\n  return async (discountCodes, optionalParams) => {\n    // Ensure the discount codes are unique\n    const uniqueCodes = discountCodes.filter((value, index, array) => {\n      return array.indexOf(value) === index;\n    });\n\n    const {cartDiscountCodesUpdate, errors} = await options.storefront.mutate<{\n      cartDiscountCodesUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_DISCOUNT_CODE_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        discountCodes: uniqueCodes,\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartDiscountCodesUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartDiscountCodesUpdateFunction": {
            "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
            "name": "CartDiscountCodesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "discountCodes",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartDiscountCodesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartDiscountCodesUpdateFunction = (\n  discountCodes: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartGetDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that returns a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartGetDefault} from '@shopify/hydrogen';\n\nconst cartGet = cartGetDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartGet();\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartGetDefault",
        "description": "",
        "type": "CartGetDefaultGeneratedType",
        "typeDefinitions": {
          "CartGetDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "name": "CartGetDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "input1",
                "description": "",
                "value": "CartGetOptions",
                "filePath": "src/cart/queries/cartGetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGetDefault.ts",
              "description": "",
              "name": "CartGetFunction",
              "value": "CartGetFunction"
            },
            "value": "export function cartGetDefault({\n  storefront,\n  customerAccount,\n  getCartId,\n  cartFragment,\n}: CartGetOptions): CartGetFunction {\n  return async (cartInput?: CartGetProps) => {\n    const cartId = getCartId();\n\n    if (!cartId) return null;\n\n    const [isCustomerLoggedIn, {cart, errors}] = await Promise.all([\n      customerAccount ? customerAccount.isLoggedIn() : false,\n      storefront.query<{cart: Cart | null}>(CART_QUERY(cartFragment), {\n        variables: {cartId, ...cartInput},\n        cache: storefront.CacheNone(),\n      }),\n    ]);\n\n    if (isCustomerLoggedIn && cart?.checkoutUrl) {\n      const finalCheckoutUrl = new URL(cart.checkoutUrl);\n      finalCheckoutUrl.searchParams.set('logged_in', 'true');\n      cart.checkoutUrl = finalCheckoutUrl.toString();\n    }\n\n    return cart || errors ? formatAPIResult(cart, errors) : null;\n  };\n}"
          },
          "CartGetOptions": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartGetOptions",
            "value": "CartQueryOptions & {\n  /**\n   * The customer account client instance created by [`createCustomerAccountClient`](docs/api/hydrogen/latest/utilities/createcustomeraccountclient).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": ""
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartGetFunction": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "name": "CartGetFunction",
            "description": "",
            "params": [
              {
                "name": "cartInput",
                "description": "",
                "value": "CartGetProps",
                "isOptional": true,
                "filePath": "src/cart/queries/cartGetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGetDefault.ts",
              "description": "",
              "name": "Promise<CartReturn | null>",
              "value": "Promise<CartReturn | null>"
            },
            "value": "export type CartGetFunction = (\n  cartInput?: CartGetProps,\n) => Promise<CartReturn | null>;"
          },
          "CartGetProps": {
            "filePath": "src/cart/queries/cartGetDefault.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartGetProps",
            "value": "{\n  /**\n   * The cart ID.\n   * @default cart.getCartId();\n   */\n  cartId?: string;\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n  /**\n   * The number of cart lines to be returned.\n   * @default 100\n   */\n  numCartLines?: number;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart ID.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              },
              {
                "filePath": "src/cart/queries/cartGetDefault.ts",
                "syntaxKind": "PropertySignature",
                "name": "numCartLines",
                "value": "number",
                "description": "The number of cart lines to be returned.",
                "isOptional": true,
                "defaultValue": "100"
              }
            ]
          },
          "CartReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartReturn",
            "value": "Cart & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartGiftCardCodesUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of strings and adds the gift card codes to a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartGiftCardCodesUpdateDefault} from '@shopify/hydrogen';\n\nconst cartGiftCardCodes = cartGiftCardCodesUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartGiftCardCodes(['GIFT_CARD_CODE_123']);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartGiftCardCodesUpdateDefault",
        "description": "",
        "type": "CartGiftCardCodesUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartGiftCardCodesUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
            "name": "CartGiftCardCodesUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
              "description": "",
              "name": "CartGiftCardCodesUpdateFunction",
              "value": "CartGiftCardCodesUpdateFunction"
            },
            "value": "export function cartGiftCardCodesUpdateDefault(\n  options: CartQueryOptions,\n): CartGiftCardCodesUpdateFunction {\n  return async (giftCardCodes, optionalParams) => {\n    // Ensure the gift card codes are unique\n    const uniqueCodes = giftCardCodes.filter((value, index, array) => {\n      return array.indexOf(value) === index;\n    });\n\n    const {cartGiftCardCodesUpdate, errors} = await options.storefront.mutate<{\n      cartGiftCardCodesUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_GIFT_CARD_CODE_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        giftCardCodes: uniqueCodes,\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartGiftCardCodesUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartGiftCardCodesUpdateFunction": {
            "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
            "name": "CartGiftCardCodesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "giftCardCodes",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartGiftCardCodeUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartGiftCardCodesUpdateFunction = (\n  giftCardCodes: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartLinesAddDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of [CartLineInput](/docs/api/storefront/2024-07/input-objects/CartLineInput) and adds the line items to a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartLinesAddDefault} from '@shopify/hydrogen';\n\nconst cartAdd = cartLinesAddDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartAdd([\n  {\n    merchandiseId: 'gid://shopify/ProductVariant/123456789',\n    quantity: 1,\n  },\n]);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartLinesAddDefault",
        "description": "",
        "type": "CartLinesAddDefaultGeneratedType",
        "typeDefinitions": {
          "CartLinesAddDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartLinesAddDefault.ts",
            "name": "CartLinesAddDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartLinesAddDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesAddDefault.ts",
              "description": "",
              "name": "CartLinesAddFunction",
              "value": "CartLinesAddFunction"
            },
            "value": "export function cartLinesAddDefault(\n  options: CartQueryOptions,\n): CartLinesAddFunction {\n  return async (lines, optionalParams) => {\n    const {cartLinesAdd, errors} = await options.storefront.mutate<{\n      cartLinesAdd: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_LINES_ADD_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        lines,\n        ...optionalParams,\n      },\n    });\n\n    return formatAPIResult(cartLinesAdd, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartLinesAddFunction": {
            "filePath": "src/cart/queries/cartLinesAddDefault.ts",
            "name": "CartLinesAddFunction",
            "description": "",
            "params": [
              {
                "name": "lines",
                "description": "",
                "value": "CartLineInput[]",
                "filePath": "src/cart/queries/cartLinesAddDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesAddDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesAddDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesAddFunction = (\n  lines: Array<CartLineInput>,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartLineInput": {
            "description": "",
            "name": "CartLineInput",
            "value": "CartLineInput",
            "members": [],
            "override": "[CartLineInput](/docs/api/storefront/2024-07/input-objects/CartLineInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartLinesRemoveDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of line ids and removes the line items from a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartLinesRemoveDefault} from '@shopify/hydrogen';\n\nconst cartRemove = cartLinesRemoveDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartRemove(['gid://shopify/CartLine/123456789']);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartLinesRemoveDefault",
        "description": "",
        "type": "CartLinesRemoveDefaultGeneratedType",
        "typeDefinitions": {
          "CartLinesRemoveDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
            "name": "CartLinesRemoveDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartLinesRemoveDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
              "description": "",
              "name": "CartLinesRemoveFunction",
              "value": "CartLinesRemoveFunction"
            },
            "value": "export function cartLinesRemoveDefault(\n  options: CartQueryOptions,\n): CartLinesRemoveFunction {\n  return async (lineIds, optionalParams) => {\n    throwIfLinesAreOptimistic('removeLines', lineIds);\n\n    const {cartLinesRemove, errors} = await options.storefront.mutate<{\n      cartLinesRemove: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_LINES_REMOVE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        lineIds,\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartLinesRemove, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartLinesRemoveFunction": {
            "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
            "name": "CartLinesRemoveFunction",
            "description": "",
            "params": [
              {
                "name": "lineIds",
                "description": "",
                "value": "string[]",
                "filePath": "src/cart/queries/cartLinesRemoveDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesRemoveDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesRemoveDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesRemoveFunction = (\n  lineIds: string[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartLinesUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of [CartLineUpdateInput](/docs/api/storefront/2024-07/input-objects/CartLineUpdateInput) and updates the line items in a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartLinesUpdateDefault} from '@shopify/hydrogen';\n\nconst cartUpdate = cartLinesUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartUpdate([\n  {\n    id: 'gid://shopify/CartLine/123456789',\n    quantity: 2,\n  },\n]);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartLinesUpdateDefault",
        "description": "",
        "type": "CartLinesUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartLinesUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
            "name": "CartLinesUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartLinesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
              "description": "",
              "name": "CartLinesUpdateFunction",
              "value": "CartLinesUpdateFunction"
            },
            "value": "export function cartLinesUpdateDefault(\n  options: CartQueryOptions,\n): CartLinesUpdateFunction {\n  return async (lines, optionalParams) => {\n    throwIfLinesAreOptimistic('updateLines', lines);\n\n    const {cartLinesUpdate, errors} = await options.storefront.mutate<{\n      cartLinesUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_LINES_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        lines,\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartLinesUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartLinesUpdateFunction": {
            "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
            "name": "CartLinesUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "lines",
                "description": "",
                "value": "CartLineUpdateInput[]",
                "filePath": "src/cart/queries/cartLinesUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartLinesUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartLinesUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartLinesUpdateFunction = (\n  lines: CartLineUpdateInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartLineUpdateInput": {
            "description": "",
            "name": "CartLineUpdateInput",
            "value": "CartLineUpdateInput",
            "members": [],
            "override": "[CartLineUpdateInput](/docs/api/storefront/2024-07/input-objects/CartLineUpdateInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartMetafieldDeleteDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts a string key and removes the matching metafield from the cart.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartMetafieldDeleteDefault} from '@shopify/hydrogen';\n\nconst cartDeleteMetafield = cartMetafieldDeleteDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartDeleteMetafield('namespace.key');\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartMetafieldDeleteDefault",
        "description": "",
        "type": "CartMetafieldDeleteDefaultGeneratedType",
        "typeDefinitions": {
          "CartMetafieldDeleteDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
            "name": "CartMetafieldDeleteDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
              "description": "",
              "name": "CartMetafieldDeleteFunction",
              "value": "CartMetafieldDeleteFunction"
            },
            "value": "export function cartMetafieldDeleteDefault(\n  options: CartQueryOptions,\n): CartMetafieldDeleteFunction {\n  return async (key, optionalParams) => {\n    const ownerId = optionalParams?.cartId || options.getCartId();\n    const {cartMetafieldDelete, errors} = await options.storefront.mutate<{\n      cartMetafieldDelete: {\n        userErrors: MetafieldDeleteUserError[];\n      };\n      errors: StorefrontApiErrors;\n    }>(CART_METAFIELD_DELETE_MUTATION(), {\n      variables: {\n        input: {\n          ownerId,\n          key,\n        },\n      },\n    });\n    return formatAPIResult(\n      {\n        cart: {\n          id: ownerId,\n        } as Cart,\n        ...cartMetafieldDelete,\n      },\n      errors,\n    );\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartMetafieldDeleteFunction": {
            "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
            "name": "CartMetafieldDeleteFunction",
            "description": "",
            "params": [
              {
                "name": "key",
                "description": "",
                "value": "string",
                "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldDeleteDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartMetafieldDeleteFunction = (\n  key: Scalars['String']['input'],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartMetafieldsSetDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an array of [CartMetafieldsSetInput](https://shopify.dev/docs/api/storefront/2024-07/input-objects/CartMetafieldsSetInput) without `ownerId` and set the metafields to a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartMetafieldsSetDefault} from '@shopify/hydrogen';\n\nconst cartSetMetafields = cartMetafieldsSetDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartSetMetafields([\n  {\n    key: 'custom.gift',\n    type: 'boolean',\n    value: 'true',\n  },\n]);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartMetafieldsSetDefault",
        "description": "",
        "type": "CartMetafieldsSetDefaultGeneratedType",
        "typeDefinitions": {
          "CartMetafieldsSetDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
            "name": "CartMetafieldsSetDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
              "description": "",
              "name": "CartMetafieldsSetFunction",
              "value": "CartMetafieldsSetFunction"
            },
            "value": "export function cartMetafieldsSetDefault(\n  options: CartQueryOptions,\n): CartMetafieldsSetFunction {\n  return async (metafields, optionalParams) => {\n    const ownerId = optionalParams?.cartId || options.getCartId();\n    const metafieldsWithOwnerId = metafields.map(\n      (metafield: MetafieldWithoutOwnerId) => ({\n        ...metafield,\n        ownerId,\n      }),\n    );\n    const {cartMetafieldsSet, errors} = await options.storefront.mutate<{\n      cartMetafieldsSet: {\n        userErrors: MetafieldsSetUserError[];\n      };\n      errors: StorefrontApiErrors;\n    }>(CART_METAFIELD_SET_MUTATION(), {\n      variables: {metafields: metafieldsWithOwnerId},\n    });\n\n    return formatAPIResult(\n      {\n        cart: {\n          id: ownerId,\n        } as Cart,\n        ...cartMetafieldsSet,\n      },\n      errors,\n    );\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartMetafieldsSetFunction": {
            "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
            "name": "CartMetafieldsSetFunction",
            "description": "",
            "params": [
              {
                "name": "metafields",
                "description": "",
                "value": "MetafieldWithoutOwnerId[]",
                "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartMetafieldsSetDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartMetafieldsSetFunction = (\n  metafields: MetafieldWithoutOwnerId[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "MetafieldWithoutOwnerId": {
            "description": "",
            "name": "MetafieldWithoutOwnerId",
            "value": "MetafieldWithoutOwnerId",
            "members": [],
            "override": "Same as [CartMetafieldsSetInput](https://shopify.dev/docs/api/storefront/2024-07/input-objects/CartMetafieldsSetInput) Storefront API type but without `ownerId`. `ownerId` is always set to the cart id."
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartNoteUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts a string and attaches it as a note to a cart.",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartNoteUpdateDefault} from '@shopify/hydrogen';\n\nconst cartNote = cartNoteUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartNote('This is a note');\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartNoteUpdateDefault",
        "description": "",
        "type": "CartNoteUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartNoteUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
            "name": "CartNoteUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartNoteUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
              "description": "",
              "name": "CartNoteUpdateFunction",
              "value": "CartNoteUpdateFunction"
            },
            "value": "export function cartNoteUpdateDefault(\n  options: CartQueryOptions,\n): CartNoteUpdateFunction {\n  return async (note, optionalParams) => {\n    const {cartNoteUpdate, errors} = await options.storefront.mutate<{\n      cartNoteUpdate: CartQueryData;\n      errors: StorefrontApiErrors;\n    }>(CART_NOTE_UPDATE_MUTATION(options.cartFragment), {\n      variables: {\n        cartId: options.getCartId(),\n        note,\n        ...optionalParams,\n      },\n    });\n    return formatAPIResult(cartNoteUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartNoteUpdateFunction": {
            "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
            "name": "CartNoteUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "note",
                "description": "",
                "value": "string",
                "filePath": "src/cart/queries/cartNoteUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartNoteUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartNoteUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartNoteUpdateFunction = (\n  note: string,\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "cartSelectedDeliveryOptionsUpdateDefault",
    "category": "utilities",
    "subCategory": "cart",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a function that accepts an object of [CartSelectedDeliveryOptionInput](/docs/api/storefront/2024-07/input-objects/CartSelectedDeliveryOptionInput) and updates the selected delivery option of a cart",
    "type": "utility",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {cartSelectedDeliveryOptionsUpdateDefault} from '@shopify/hydrogen';\n\nconst cartDeliveryOption = cartSelectedDeliveryOptionsUpdateDefault({\n  storefront,\n  getCartId,\n});\n\nconst result = await cartDeliveryOption([\n  {\n    deliveryGroupId: '123',\n    deliveryOptionHandle: 'Canada Post',\n  },\n]);\n",
            "language": "js"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "cartSelectedDeliveryOptionsUpdateDefault",
        "description": "",
        "type": "CartSelectedDeliveryOptionsUpdateDefaultGeneratedType",
        "typeDefinitions": {
          "CartSelectedDeliveryOptionsUpdateDefaultGeneratedType": {
            "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
            "name": "CartSelectedDeliveryOptionsUpdateDefaultGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "CartQueryOptions",
                "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
              "description": "",
              "name": "CartSelectedDeliveryOptionsUpdateFunction",
              "value": "CartSelectedDeliveryOptionsUpdateFunction"
            },
            "value": "export function cartSelectedDeliveryOptionsUpdateDefault(\n  options: CartQueryOptions,\n): CartSelectedDeliveryOptionsUpdateFunction {\n  return async (selectedDeliveryOptions, optionalParams) => {\n    const {cartSelectedDeliveryOptionsUpdate, errors} =\n      await options.storefront.mutate<{\n        cartSelectedDeliveryOptionsUpdate: CartQueryData;\n        errors: StorefrontApiErrors;\n      }>(CART_SELECTED_DELIVERY_OPTIONS_UPDATE_MUTATION(options.cartFragment), {\n        variables: {\n          cartId: options.getCartId(),\n          selectedDeliveryOptions,\n          ...optionalParams,\n        },\n      });\n    return formatAPIResult(cartSelectedDeliveryOptionsUpdate, errors);\n  };\n}"
          },
          "CartQueryOptions": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryOptions",
            "value": "{\n  /**\n   * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).\n   */\n  storefront: Storefront;\n  /**\n   * A function that returns the cart ID.\n   */\n  getCartId: () => string | undefined;\n  /**\n   * The cart fragment to override the one used in this query.\n   */\n  cartFragment?: string;\n  /**\n   * The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).\n   */\n  customerAccount?: CustomerAccount;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartFragment",
                "value": "string",
                "description": "The cart fragment to override the one used in this query.",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "The customer account instance created by [`createCustomerAccount`](docs/api/hydrogen/latest/customer/createcustomeraccount).",
                "isOptional": true
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": "A function that returns the cart ID."
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient)."
              }
            ]
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "CartSelectedDeliveryOptionsUpdateFunction": {
            "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
            "name": "CartSelectedDeliveryOptionsUpdateFunction",
            "description": "",
            "params": [
              {
                "name": "selectedDeliveryOptions",
                "description": "",
                "value": "CartSelectedDeliveryOptionInput[]",
                "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts"
              },
              {
                "name": "optionalParams",
                "description": "",
                "value": "CartOptionalInput",
                "isOptional": true,
                "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts"
              }
            ],
            "returns": {
              "filePath": "src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts",
              "description": "",
              "name": "Promise<CartQueryDataReturn>",
              "value": "Promise<CartQueryDataReturn>"
            },
            "value": "export type CartSelectedDeliveryOptionsUpdateFunction = (\n  selectedDeliveryOptions: CartSelectedDeliveryOptionInput[],\n  optionalParams?: CartOptionalInput,\n) => Promise<CartQueryDataReturn>;"
          },
          "CartSelectedDeliveryOptionInput": {
            "description": "",
            "name": "CartSelectedDeliveryOptionInput",
            "value": "CartSelectedDeliveryOptionInput",
            "members": [],
            "override": "[CartSelectedDeliveryOptionInput](/docs/api/storefront/2024-07/input-objects/CartSelectedDeliveryOptionInput) - Storefront API type"
          },
          "CartOptionalInput": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartOptionalInput",
            "value": "{\n  /**\n   * The cart id.\n   * @default cart.getCartId();\n   */\n  cartId?: Scalars['ID']['input'];\n  /**\n   * The country code.\n   * @default storefront.i18n.country\n   */\n  country?: CountryCode;\n  /**\n   * The language code.\n   * @default storefront.i18n.language\n   */\n  language?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "The cart id.",
                "isOptional": true,
                "defaultValue": "cart.getCartId();"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "The country code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.country"
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": "The language code.",
                "isOptional": true,
                "defaultValue": "storefront.i18n.language"
              }
            ]
          },
          "CartQueryDataReturn": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryDataReturn",
            "value": "CartQueryData & {\n  errors?: StorefrontApiErrors;\n}",
            "description": ""
          },
          "CartQueryData": {
            "filePath": "src/cart/queries/cart-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CartQueryData",
            "value": "{\n  cart: Cart;\n  userErrors?:\n    | CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "Cart",
                "description": ""
              },
              {
                "filePath": "src/cart/queries/cart-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userErrors",
                "value": "| CartUserError[]\n    | MetafieldsSetUserError[]\n    | MetafieldDeleteUserError[]",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Cart": {
            "description": "",
            "name": "Cart",
            "value": "Cart",
            "members": [],
            "override": "[Cart](/docs/api/storefront/2024-07/objects/Cart) - Storefront API type"
          },
          "CartUserError": {
            "description": "",
            "name": "CartUserError",
            "value": "CartUserError",
            "members": [],
            "override": "[CartUserError](/docs/api/storefront/2024-07/objects/CartUserError) - Storefront API type"
          },
          "MetafieldsSetUserError": {
            "description": "",
            "name": "MetafieldsSetUserError",
            "value": "MetafieldsSetUserError",
            "members": [],
            "override": "[MetafieldsSetUserError](/docs/api/storefront/2024-07/objects/MetafieldsSetUserError) - Storefront API type"
          },
          "MetafieldDeleteUserError": {
            "description": "",
            "name": "MetafieldDeleteUserError",
            "value": "MetafieldDeleteUserError",
            "members": [],
            "override": "[MetafieldDeleteUserError](/docs/api/storefront/2024-07/objects/MetafieldDeleteUserError) - Storefront API type"
          }
        }
      }
    ]
  },
  {
    "name": "createHydrogenContext",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createHydrogenContext",
        "type": "utility",
        "url": "/docs/api/hydrogen/2024-07/utilities/createhydrogencontext"
      }
    ],
    "description": "\nThe `createHydrogenContext` function creates the context object required to use Hydrogen utilities throughout a Hydrogen project.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {createHydrogenContext} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request, env, executionContext) {\n    const waitUntil = executionContext.waitUntil.bind(executionContext);\n    const [cache, session] = await Promise.all([\n      caches.open('hydrogen'),\n      AppSession.init(request, [env.SESSION_SECRET]),\n    ]);\n\n    /* Create context objects required to use Hydrogen with your credentials and options */\n    const hydrogenContext = createHydrogenContext({\n      /* Environment variables from the fetch function */\n      env,\n      /* Request object from the fetch function */\n      request,\n      /* Cache API instance */\n      cache,\n      /* Runtime utility in serverless environments */\n      waitUntil,\n      session,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({...hydrogenContext}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession {\n  isPending = false;\n\n  static async init(request, secrets) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key, value) {\n    this.session.flash(key, value);\n  }\n\n  unset(key) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key, value) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {createHydrogenContext, type HydrogenSession} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n  type SessionStorage,\n  type Session,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request: Request, env: Env, executionContext: ExecutionContext) {\n    const waitUntil = executionContext.waitUntil.bind(executionContext);\n    const [cache, session] = await Promise.all([\n      caches.open('hydrogen'),\n      AppSession.init(request, [env.SESSION_SECRET]),\n    ]);\n\n    /* Create context objects required to use Hydrogen with your credentials and options */\n    const hydrogenContext = createHydrogenContext({\n      /* Environment variables from the fetch function */\n      env,\n      /* Request object from the fetch function */\n      request,\n      /* Cache API instance */\n      cache,\n      /* Runtime utility in serverless environments */\n      waitUntil,\n      session,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({...hydrogenContext}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession implements HydrogenSession {\n  public isPending = false;\n\n  constructor(\n    private sessionStorage: SessionStorage,\n    private session: Session,\n  ) {}\n\n  static async init(request: Request, secrets: string[]) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key: string) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key: string, value: any) {\n    this.session.flash(key, value);\n  }\n\n  unset(key: string) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key: string, value: any) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "createHydrogenContext(options)",
        "description": "",
        "type": "HydrogenContextOptionsForDocs",
        "typeDefinitions": {
          "HydrogenContextOptionsForDocs": {
            "filePath": "src/createHydrogenContext.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenContextOptionsForDocs",
            "value": "{\n  /* Environment variables from the fetch function */\n  env: TEnv;\n  /* Request object from the fetch function */\n  request: CrossRuntimeRequest;\n  /** An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) */\n  cache?: Cache;\n  /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */\n  waitUntil?: WaitUntil;\n  /** Any cookie implementation. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation.  */\n  session: TSession;\n  /** An object containing a country code and language code */\n  i18n?: TI18n;\n  /** Whether it should print GraphQL errors automatically. Defaults to true */\n  logErrors?: boolean | ((error?: Error) => boolean);\n  /** Storefront client overwrite options. See documentation for createStorefrontClient for more information. */\n  storefront?: {\n    /** Storefront API headers. Default values set from request header.  */\n    headers?: StorefrontHeaders;\n    /** Override the Storefront API version for this query. */\n    apiVersion?: string;\n  };\n  /** Customer Account client overwrite options. See documentation for createCustomerAccountClient for more information. */\n  customerAccount?: {\n    /** Override the version of the API */\n    apiVersion?: string;\n    /** This is the route in your app that authorizes the customer after logging in. Make sure to call `customer.authorize()` within the loader on this route. It defaults to `/account/authorize`. */\n    authUrl?: string;\n    /** Use this method to overwrite the default logged-out redirect behavior. The default handler [throws a redirect](https://remix.run/docs/en/main/utils/redirect#:~:text=!session) to `/account/login` with current path as `return_to` query param. */\n    customAuthStatusHandler?: () => Response | NonNullable<unknown> | null;\n    /** UNSTABLE feature, this will eventually goes away. If true then we will exchange customerAccessToken for storefrontCustomerAccessToken. */\n    unstableB2b?: boolean;\n  };\n  /** Cart handler overwrite options. See documentation for createCartHandler for more information. */\n  cart?: {\n    /** A function that returns the cart id in the form of `gid://shopify/Cart/c1-123`. */\n    getId?: () => string | undefined;\n    /** A function that sets the cart ID. */\n    setId?: (cartId: string) => Headers;\n    /**\n     * The cart query fragment used by `cart.get()`.\n     * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.\n     */\n    queryFragment?: string;\n    /**\n     * The cart mutation fragment used in most mutation requests, except for `setMetafields` and `deleteMetafield`.\n     * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-cart-fragments) in the documentation.\n     */\n    mutateFragment?: string;\n    /**\n     * Define custom methods or override existing methods for your cart API instance.\n     * See the [example usage](/docs/api/hydrogen/2024-07/utilities/createcarthandler#example-custom-methods) in the documentation.\n     */\n    customMethods?: Record<string, Function>;\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache)",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "{ getId?: () => string; setId?: (cartId: string) => Headers; queryFragment?: string; mutateFragment?: string; customMethods?: Record<string, Function>; }",
                "description": "Cart handler overwrite options. See documentation for createCartHandler for more information.",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "{ apiVersion?: string; authUrl?: string; customAuthStatusHandler?: () => {} | Response; unstableB2b?: boolean; }",
                "description": "Customer Account client overwrite options. See documentation for createCustomerAccountClient for more information.",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "env",
                "value": "TEnv",
                "description": ""
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": "An object containing a country code and language code",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "logErrors",
                "value": "boolean | ((error?: Error) => boolean)",
                "description": "Whether it should print GraphQL errors automatically. Defaults to true",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "CrossRuntimeRequest",
                "description": ""
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "TSession",
                "description": "Any cookie implementation. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation."
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "{ headers?: StorefrontHeaders; apiVersion?: string; }",
                "description": "Storefront client overwrite options. See documentation for createStorefrontClient for more information.",
                "isOptional": true
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitUntil",
                "value": "WaitUntil",
                "description": "The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform.",
                "isOptional": true
              }
            ]
          },
          "Headers": {
            "description": "",
            "name": "Headers",
            "value": "Headers",
            "members": [],
            "override": "[Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) - Web API"
          },
          "CrossRuntimeRequest": {
            "filePath": "src/utils/request.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CrossRuntimeRequest",
            "value": "{\n  url?: string;\n  method?: string;\n  headers: {\n    get?: (key: string) => string | null | undefined;\n    [key: string]: any;\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "{ [key: string]: any; get?: (key: string) => string; }",
                "description": ""
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "method",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      },
      {
        "title": "Returns",
        "description": "",
        "type": "HydrogenContext",
        "typeDefinitions": {
          "HydrogenContext": {
            "filePath": "src/createHydrogenContext.ts",
            "name": "HydrogenContext",
            "description": "",
            "members": [
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "TCustomMethods extends CustomMethodsBase ? HydrogenCartCustom<TCustomMethods> : HydrogenCart",
                "description": "A collection of utilities used to interact with the cart."
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccount",
                "value": "CustomerAccount",
                "description": "A GraphQL client for querying the [Customer Account API](https://shopify.dev/docs/api/customer). It also provides methods to authenticate and check if the user is logged in."
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "env",
                "value": "TEnv",
                "description": ""
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "TSession",
                "description": "Any cookie implementation. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation."
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront<TI18n>",
                "description": "A GraphQL client for querying the [Storefront API](https://shopify.dev/docs/api/storefront)."
              },
              {
                "filePath": "src/createHydrogenContext.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitUntil",
                "value": "WaitUntil",
                "description": "The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform.",
                "isOptional": true
              }
            ],
            "value": "export interface HydrogenContext<\n  TSession extends HydrogenSession = HydrogenSession,\n  TCustomMethods extends CustomMethodsBase | undefined = {},\n  TI18n extends I18nBase = I18nBase,\n  TEnv extends HydrogenEnv = Env,\n> {\n  /** A GraphQL client for querying the [Storefront API](https://shopify.dev/docs/api/storefront). */\n  storefront: StorefrontClient<TI18n>['storefront'];\n  /** A GraphQL client for querying the [Customer Account API](https://shopify.dev/docs/api/customer). It also provides methods to authenticate and check if the user is logged in. */\n  customerAccount: CustomerAccount;\n  /** A collection of utilities used to interact with the cart. */\n  cart: TCustomMethods extends CustomMethodsBase\n    ? HydrogenCartCustom<TCustomMethods>\n    : HydrogenCart;\n  /* Request object from the fetch function */\n  env: TEnv;\n  /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */\n  waitUntil?: WaitUntil;\n  /** Any cookie implementation. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation.  */\n  session: TSession;\n}"
          },
          "CustomMethodsBase": {
            "filePath": "src/cart/createCartHandler.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomMethodsBase",
            "value": "Record<string, Function>",
            "description": "",
            "members": []
          },
          "HydrogenCartCustom": {
            "filePath": "src/cart/createCartHandler.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenCartCustom",
            "value": "Omit<HydrogenCart, keyof TCustomMethods> & TCustomMethods",
            "description": ""
          },
          "HydrogenCart": {
            "filePath": "src/cart/createCartHandler.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenCart",
            "value": "{\n  get: ReturnType<typeof cartGetDefault>;\n  getCartId: () => string | undefined;\n  setCartId: (cartId: string) => Headers;\n  create: ReturnType<typeof cartCreateDefault>;\n  addLines: ReturnType<typeof cartLinesAddDefault>;\n  updateLines: ReturnType<typeof cartLinesUpdateDefault>;\n  removeLines: ReturnType<typeof cartLinesRemoveDefault>;\n  updateDiscountCodes: ReturnType<typeof cartDiscountCodesUpdateDefault>;\n  updateGiftCardCodes: ReturnType<typeof cartGiftCardCodesUpdateDefault>;\n  updateBuyerIdentity: ReturnType<typeof cartBuyerIdentityUpdateDefault>;\n  updateNote: ReturnType<typeof cartNoteUpdateDefault>;\n  updateSelectedDeliveryOption: ReturnType<\n    typeof cartSelectedDeliveryOptionsUpdateDefault\n  >;\n  updateAttributes: ReturnType<typeof cartAttributesUpdateDefault>;\n  setMetafields: ReturnType<typeof cartMetafieldsSetDefault>;\n  deleteMetafield: ReturnType<typeof cartMetafieldDeleteDefault>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "addLines",
                "value": "ReturnType<typeof cartLinesAddDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "create",
                "value": "ReturnType<typeof cartCreateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "deleteMetafield",
                "value": "ReturnType<typeof cartMetafieldDeleteDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "get",
                "value": "ReturnType<typeof cartGetDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "getCartId",
                "value": "() => string",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "removeLines",
                "value": "ReturnType<typeof cartLinesRemoveDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "setCartId",
                "value": "(cartId: string) => Headers",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "setMetafields",
                "value": "ReturnType<typeof cartMetafieldsSetDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateAttributes",
                "value": "ReturnType<typeof cartAttributesUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateBuyerIdentity",
                "value": "ReturnType<typeof cartBuyerIdentityUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateDiscountCodes",
                "value": "ReturnType<typeof cartDiscountCodesUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateGiftCardCodes",
                "value": "ReturnType<typeof cartGiftCardCodesUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateLines",
                "value": "ReturnType<typeof cartLinesUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateNote",
                "value": "ReturnType<typeof cartNoteUpdateDefault>",
                "description": ""
              },
              {
                "filePath": "src/cart/createCartHandler.ts",
                "syntaxKind": "PropertySignature",
                "name": "updateSelectedDeliveryOption",
                "value": "ReturnType<\n    typeof cartSelectedDeliveryOptionsUpdateDefault\n  >",
                "description": ""
              }
            ]
          },
          "Headers": {
            "description": "",
            "name": "Headers",
            "value": "Headers",
            "members": [],
            "override": "[Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) - Web API"
          },
          "CustomerAccount": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccount",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountQueries,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      CustomerAccountMutations,\n      RawGqlString\n    >\n  ) => Promise<\n    Omit<\n      CustomerAPIResponse<\n        ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>\n      >,\n      'errors'\n    > & {errors?: JsonGraphQLError[]}\n  >;\n  /** UNSTABLE feature. Set buyer information into session.*/\n  UNSTABLE_setBuyer: (buyer: Buyer) => void;\n  /** UNSTABLE feature. Get buyer token and company location id from session.*/\n  UNSTABLE_getBuyer: () => Promise<Buyer>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)"
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<CustomerAccountMutations[RawGqlString][\"variables\"], never, Omit<CustomerAccountMutations[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountMutations, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>]: CustomerAccountMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountMutations[RawGqlString][\"variables\"], Extract<keyof CustomerAccountMutations[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountMutations, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<CustomerAccountQueries[RawGqlString][\"variables\"], never, Omit<CustomerAccountQueries[RawGqlString][\"variables\"], never>> extends true ? [({} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [{} & ClientVariables<CustomerAccountQueries, RawGqlString, never, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)]: ({ [KeyType in keyof CustomerAccountQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>]: CustomerAccountQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<CustomerAccountQueries[RawGqlString][\"variables\"], Extract<keyof CustomerAccountQueries[RawGqlString][\"variables\"], never>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<Omit<CustomerAPIResponse<ClientReturn<CustomerAccountQueries, RawGqlString, OverrideReturnType>>, \"errors\"> & { errors?: Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">[]; }>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_getBuyer",
                "value": "() => Promise<Partial<BuyerInput>>",
                "description": "UNSTABLE feature. Get buyer token and company location id from session."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "UNSTABLE_setBuyer",
                "value": "(buyer: Partial<BuyerInput>) => void",
                "description": "UNSTABLE feature. Set buyer information into session."
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountMutations": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountMutations",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "CustomerAPIResponse": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAPIResponse",
            "value": "{\n  data: ReturnType;\n  errors: Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>;\n  extensions: {\n    cost: {\n      requestQueryCost: number;\n      actualQueryCakes: number;\n      throttleStatus: {\n        maximumAvailable: number;\n        currentAvailable: number;\n        restoreRate: number;\n      };\n    };\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "ReturnType",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "Array<{\n    message: string;\n    locations?: Array<{line: number; column: number}>;\n    path?: Array<string>;\n    extensions: {code: string};\n  }>",
                "description": ""
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "extensions",
                "value": "{ cost: { requestQueryCost: number; actualQueryCakes: number; throttleStatus: { maximumAvailable: number; currentAvailable: number; restoreRate: number; }; }; }",
                "description": ""
              }
            ]
          },
          "GraphQLError": {
            "filePath": "src/utils/graphql.ts",
            "name": "GraphQLError",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "locations",
                "value": "{ line: number; column: number; }[]",
                "description": "If an error can be associated to a particular point in the requested GraphQL document, it should contain a list of locations."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "path",
                "value": "(string | number)[]",
                "description": "If an error can be associated to a particular field in the GraphQL result, it _must_ contain an entry with the key `path` that details the path of the response field which experienced the error. This allows clients to identify whether a null result is intentional or caused by a runtime error."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertyDeclaration",
                "name": "extensions",
                "value": "{ [key: string]: unknown; }",
                "description": "Reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toString",
                "value": "() => string",
                "description": "Note: `toString()` is internally used by `console.log(...)` / `console.error(...)` when ingesting logs in Oxygen production. Therefore, we want to make sure that the error message is as informative as possible instead of `[object Object]`."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "MethodDeclaration",
                "name": "toJSON",
                "value": "() => Pick<GraphQLError, \"path\" | \"name\" | \"message\" | \"extensions\" | \"locations\" | \"stack\">",
                "description": "Note: toJSON` is internally used by `JSON.stringify(...)`. The most common scenario when this error instance is going to be stringified is when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`. In this situation, we don't want to expose private error information to the browser so we only do it in development."
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "GetAccessor",
                "name": "__@toStringTag@690",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "message",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/utils/graphql.ts",
                "syntaxKind": "PropertySignature",
                "name": "stack",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export class GraphQLError extends Error {\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  locations?: Array<{line: number; column: number}>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  path?: Array<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  extensions?: {[key: string]: unknown};\n\n  constructor(\n    message?: string,\n    options: Pick<\n      GraphQLError,\n      'locations' | 'path' | 'extensions' | 'stack' | 'cause'\n    > & {\n      query?: string;\n      queryVariables?: GenericVariables;\n      requestId?: string | null;\n      clientOperation?: string;\n    } = {},\n  ) {\n    const h2Prefix = options.clientOperation\n      ? `[h2:error:${options.clientOperation}] `\n      : '';\n\n    const enhancedMessage =\n      h2Prefix +\n      message +\n      (options.requestId ? ` - Request ID: ${options.requestId}` : '');\n\n    super(enhancedMessage);\n    this.name = 'GraphQLError';\n    this.extensions = options.extensions;\n    this.locations = options.locations;\n    this.path = options.path;\n    this.stack = options.stack || undefined;\n\n    try {\n      this.cause = JSON.stringify({\n        ...(typeof options.cause === 'object' ? options.cause : {}),\n        requestId: options.requestId,\n        ...(process.env.NODE_ENV === 'development' && {\n          path: options.path,\n          extensions: options.extensions,\n          graphql: h2Prefix &&\n            options.query && {\n              query: options.query,\n              variables: JSON.stringify(options.queryVariables),\n            },\n        }),\n      });\n    } catch {\n      if (options.cause) this.cause = options.cause;\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n\n  /**\n   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`\n   * when ingesting logs in Oxygen production. Therefore, we want to make sure that\n   * the error message is as informative as possible instead of `[object Object]`.\n   */\n  override toString() {\n    let result = `${this.name}: ${this.message}`;\n\n    if (this.path) {\n      try {\n        result += ` | path: ${JSON.stringify(this.path)}`;\n      } catch {}\n    }\n\n    if (this.extensions) {\n      try {\n        result += ` | extensions: ${JSON.stringify(this.extensions)}`;\n      } catch {}\n    }\n\n    result += '\\n';\n\n    if (this.stack) {\n      // Remove the message line from the stack.\n      result += `${this.stack.slice(this.stack.indexOf('\\n') + 1)}\\n`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Note: toJSON` is internally used by `JSON.stringify(...)`.\n   * The most common scenario when this error instance is going to be stringified is\n   * when it's passed to Remix' `json` and `defer` functions: e.g. `defer({promise: storefront.query(...)})`.\n   * In this situation, we don't want to expose private error information to the browser so we only\n   * do it in development.\n   */\n  toJSON() {\n    const formatted: Pick<\n      GraphQLError,\n      'name' | 'message' | 'path' | 'extensions' | 'locations' | 'stack'\n    > = {name: 'Error', message: ''};\n\n    if (process.env.NODE_ENV === 'development') {\n      formatted.name = this.name;\n      formatted.message = 'Development: ' + this.message;\n      if (this.path) formatted.path = this.path;\n      if (this.locations) formatted.locations = this.locations;\n      if (this.extensions) formatted.extensions = this.extensions;\n      // Skip stack on purpose because we don't want to expose it to the browser.\n    }\n\n    return formatted;\n  }\n}"
          },
          "CustomerAccountQueries": {
            "filePath": "src/customer/types.ts",
            "name": "CustomerAccountQueries",
            "description": "",
            "members": [],
            "value": "export interface CustomerAccountQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "createStorefrontClient",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "CacheNone",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachenone"
      },
      {
        "name": "CacheShort",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cacheshort"
      },
      {
        "name": "CacheLong",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachelong"
      },
      {
        "name": "CacheCustom",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/cachecustom"
      },
      {
        "name": "InMemoryCache",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/inmemorycache"
      }
    ],
    "description": "This function extends `createStorefrontClient` from [Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient).\nThe additional arguments enable internationalization (i18n), caching, and other features particular to Remix and Oxygen.\n\nLearn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {createStorefrontClient} from '@shopify/hydrogen';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\nexport default {\n  async fetch(request, env, executionContext) {\n    /* Create a Storefront client with your credentials and options */\n    const {storefront} = createStorefrontClient({\n      /* Cache API instance */\n      cache: await caches.open('hydrogen'),\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Private Storefront API token for your store */\n      privateStorefrontToken: env.PRIVATE_STOREFRONT_API_TOKEN,\n      /* Public Storefront API token for your store */\n      publicStorefrontToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      /* Your store domain: \"{shop}.myshopify.com\" */\n      storeDomain: env.PUBLIC_STORE_DOMAIN,\n      /**\n       * Storefront API headers containing:\n       * - buyerIp: The IP address of the customer.\n       * - requestGroupId: A unique ID to group all the logs for this request.\n       * - cookie: The 'cookie' header from the request.\n       */\n      storefrontHeaders: getStorefrontHeaders(request),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the Storefront client in the Remix context */\n      getLoadContext: () =&gt; ({storefront}),\n    });\n\n    return handleRequest(request);\n  },\n};\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {createStorefrontClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ) {\n    /* Create a Storefront client with your credentials and options */\n    const {storefront} = createStorefrontClient({\n      /* Cache API instance */\n      cache: await caches.open('hydrogen'),\n      /* Runtime utility in serverless environments */\n      waitUntil: (p: Promise&lt;unknown&gt;) =&gt; executionContext.waitUntil(p),\n      /* Private Storefront API token for your store */\n      privateStorefrontToken: env.PRIVATE_STOREFRONT_API_TOKEN,\n      /* Public Storefront API token for your store */\n      publicStorefrontToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      /* Your store domain: \"{shop}.myshopify.com\" */\n      storeDomain: env.PUBLIC_STORE_DOMAIN,\n      /**\n       * Storefront API headers containing:\n       * - buyerIp: The IP address of the customer.\n       * - requestGroupId: A unique ID to group all the logs for this request.\n       * - cookie: The 'cookie' header from the request.\n       */\n      storefrontHeaders: getStorefrontHeaders(request),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the Storefront client in the Remix context */\n      getLoadContext: () =&gt; ({storefront}),\n    });\n\n    return handleRequest(request);\n  },\n};\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Parameters",
        "description": "",
        "type": "CreateStorefrontClientOptions",
        "typeDefinitions": {
          "CreateStorefrontClientOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CreateStorefrontClientOptions",
            "value": "HydrogenClientProps<TI18n> & StorefrontClientProps",
            "description": ""
          },
          "HydrogenClientProps": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenClientProps",
            "value": "{\n  /** Storefront API headers. If on Oxygen, use `getStorefrontHeaders()` */\n  storefrontHeaders?: StorefrontHeaders;\n  /** An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) */\n  cache?: Cache;\n  /** The globally unique identifier for the Shop */\n  storefrontId?: string;\n  /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */\n  waitUntil?: WaitUntil;\n  /** An object containing a country code and language code */\n  i18n?: TI18n;\n  /** Whether it should print GraphQL errors automatically. Defaults to true */\n  logErrors?: boolean | ((error?: Error) => boolean);\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache)",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": "An object containing a country code and language code",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "logErrors",
                "value": "boolean | ((error?: Error) => boolean)",
                "description": "Whether it should print GraphQL errors automatically. Defaults to true",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontHeaders",
                "value": "StorefrontHeaders",
                "description": "Storefront API headers. If on Oxygen, use `getStorefrontHeaders()`",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontId",
                "value": "string",
                "description": "The globally unique identifier for the Shop",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitUntil",
                "value": "WaitUntil",
                "description": "The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform.",
                "isOptional": true
              }
            ]
          }
        }
      },
      {
        "title": "Returns",
        "description": "",
        "type": "CreateStorefrontClientForDocs",
        "typeDefinitions": {
          "CreateStorefrontClientForDocs": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CreateStorefrontClientForDocs",
            "value": "{\n  storefront?: StorefrontForDoc<TI18n>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "StorefrontForDoc<TI18n>",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontForDoc": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontForDoc",
            "value": "{\n  /** The function to run a query on Storefront API. */\n  query?: <TData = any>(\n    query: string,\n    options: StorefrontQueryOptionsForDocs,\n  ) => Promise<TData & StorefrontError>;\n  /** The function to run a mutation on Storefront API. */\n  mutate?: <TData = any>(\n    mutation: string,\n    options: StorefrontMutationOptionsForDocs,\n  ) => Promise<TData & StorefrontError>;\n  /** The cache instance passed in from the `createStorefrontClient` argument. */\n  cache?: Cache;\n  /** Re-export of [`CacheNone`](/docs/api/hydrogen/2024-07/utilities/cachenone). */\n  CacheNone?: typeof CacheNone;\n  /** Re-export of [`CacheLong`](/docs/api/hydrogen/2024-07/utilities/cachelong). */\n  CacheLong?: typeof CacheLong;\n  /** Re-export of [`CacheShort`](/docs/api/hydrogen/2024-07/utilities/cacheshort). */\n  CacheShort?: typeof CacheShort;\n  /** Re-export of [`CacheCustom`](/docs/api/hydrogen/2024-07/utilities/cachecustom). */\n  CacheCustom?: typeof CacheCustom;\n  /** Re-export of [`generateCacheControlHeader`](/docs/api/hydrogen/2024-07/utilities/generatecachecontrolheader). */\n  generateCacheControlHeader?: typeof generateCacheControlHeader;\n  /** Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint. See [`getPublicTokenHeaders` in Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=%27graphql%27.-,getPublicTokenHeaders,-(props%3F%3A) for more details. */\n  getPublicTokenHeaders?: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  /** Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint for API calls made from a server. See [`getPrivateTokenHeaders` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=storefrontApiVersion-,getPrivateTokenHeaders,-(props%3F%3A) for more details.*/\n  getPrivateTokenHeaders?: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  /** Creates the fully-qualified URL to your myshopify.com domain. See [`getShopifyDomain` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=StorefrontClientReturn-,getShopifyDomain,-(props%3F%3A) for more details. */\n  getShopifyDomain?: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint. See [`getStorefrontApiUrl` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=storeDomain-,getStorefrontApiUrl,-(props%3F%3A) for more details.*/\n  getApiUrl?: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  /** The `i18n` object passed in from the `createStorefrontClient` argument. */\n  i18n?: TI18n;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "The cache instance passed in from the `createStorefrontClient` argument.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": "Re-export of [`CacheCustom`](/docs/api/hydrogen/2024-07/utilities/cachecustom).",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": "Re-export of [`CacheLong`](/docs/api/hydrogen/2024-07/utilities/cachelong).",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": "Re-export of [`CacheNone`](/docs/api/hydrogen/2024-07/utilities/cachenone).",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": "Re-export of [`CacheShort`](/docs/api/hydrogen/2024-07/utilities/cacheshort).",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": "Re-export of [`generateCacheControlHeader`](/docs/api/hydrogen/2024-07/utilities/generatecachecontrolheader).",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint. See [`getStorefrontApiUrl` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=storeDomain-,getStorefrontApiUrl,-(props%3F%3A) for more details.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": "Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint for API calls made from a server. See [`getPrivateTokenHeaders` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=storefrontApiVersion-,getPrivateTokenHeaders,-(props%3F%3A) for more details.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": "Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint. See [`getPublicTokenHeaders` in Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=%27graphql%27.-,getPublicTokenHeaders,-(props%3F%3A) for more details.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": "Creates the fully-qualified URL to your myshopify.com domain. See [`getShopifyDomain` in  Hydrogen React](/docs/api/hydrogen-react/2024-07/utilities/createstorefrontclient#:~:text=StorefrontClientReturn-,getShopifyDomain,-(props%3F%3A) for more details.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": "The `i18n` object passed in from the `createStorefrontClient` argument.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<TData = any>(mutation: string, options: StorefrontMutationOptionsForDocs) => Promise<TData & StorefrontError>",
                "description": "The function to run a mutation on Storefront API.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<TData = any>(query: string, options: StorefrontQueryOptionsForDocs) => Promise<TData & StorefrontError>",
                "description": "The function to run a query on Storefront API.",
                "isOptional": true
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutationOptionsForDocs": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontMutationOptionsForDocs",
            "value": "{\n  /** The variables for the GraphQL mutation statement. */\n  variables?: Record<string, unknown>;\n  /** Additional headers for this query. */\n  headers?: HeadersInit;\n  /** Override the Storefront API version for this query. */\n  storefrontApiVersion?: string;\n  /** The name of the query for debugging in the Subrequest Profiler. */\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "The name of the query for debugging in the Subrequest Profiler.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "Additional headers for this query.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "Override the Storefront API version for this query.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "Record<string, unknown>",
                "description": "The variables for the GraphQL mutation statement.",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueryOptionsForDocs": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptionsForDocs",
            "value": "{\n  /** The variables for the GraphQL query statement. */\n  variables?: Record<string, unknown>;\n  /** The cache strategy for this query. Default to max-age=1, stale-while-revalidate=86399. */\n  cache?: CachingStrategy;\n  /** Additional headers for this query. */\n  headers?: HeadersInit;\n  /** Override the Storefront API version for this query. */\n  storefrontApiVersion?: string;\n  /** The name of the query for debugging in the Subrequest Profiler. */\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "CachingStrategy",
                "description": "The cache strategy for this query. Default to max-age=1, stale-while-revalidate=86399.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "The name of the query for debugging in the Subrequest Profiler.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "Additional headers for this query.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "Override the Storefront API version for this query.",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "Record<string, unknown>",
                "description": "The variables for the GraphQL query statement.",
                "isOptional": true
              }
            ]
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Script",
    "category": "components",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createContentSecurityPolicy",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createcontentsecuritypolicy"
      },
      {
        "name": "useNonce",
        "type": "hooks",
        "url": "/docs/api/hydrogen/2024-07/hooks/usenonce"
      }
    ],
    "description": "Use the `Script` component to add third-party scripts to your app. It automatically adds a nonce attribute from your [content security policy](/docs/custom-storefronts/hydrogen/content-security-policy). If you load a script that directly modifies the DOM, you are likely to have hydration errors. Use the `waitForHydration` prop to load the script after the page hydrates.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {useNonce, Script} from '@shopify/hydrogen';\nexport default function App() {\n  const nonce = useNonce();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        {/* Note you don't need to pass a nonce to the script component \n        because it's automatically added */}\n        &lt;Script src=\"https://some-custom-script.js\" /&gt;\n        {/* For security, nonce is not supported with `waitForHydration`.\n        Instead you need to add the domain of the script directly to your\n        Content Securitiy Policy directives. */}\n        &lt;Script\n          waitForHydration\n          src=\"https://domain.com/script-that-modifies-dom.js\"\n        /&gt;\n        &lt;ScrollRestoration nonce={nonce} /&gt;\n        &lt;Scripts nonce={nonce} /&gt;\n        &lt;LiveReload nonce={nonce} /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {useNonce, Script} from '@shopify/hydrogen';\nexport default function App() {\n  const nonce = useNonce();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        {/* Note you don't need to pass a nonce to the script component \n        because it's automatically added */}\n        &lt;Script src=\"https://some-custom-script.js\" /&gt;\n        {/* For security, nonce is not supported with `waitForHydration`.\n        Instead you need to add the domain of the script directly to your\n        Content Securitiy Policy directives. */}\n        &lt;Script\n          waitForHydration\n          src=\"https://domain.com/script-that-modifies-dom.js\"\n        /&gt;\n        &lt;ScrollRestoration nonce={nonce} /&gt;\n        &lt;Scripts nonce={nonce} /&gt;\n        &lt;LiveReload nonce={nonce} /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "ScriptProps",
        "typeDefinitions": {
          "ScriptProps": {
            "filePath": "src/csp/Script.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ScriptProps",
            "value": "HydrogenScriptProps & ScriptAttributes",
            "description": ""
          },
          "HydrogenScriptProps": {
            "filePath": "src/csp/Script.tsx",
            "name": "HydrogenScriptProps",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "waitForHydration",
                "value": "boolean",
                "description": "Wait to load the script until after the page hydrates. This prevents hydration errors for scripts that modify the DOM. Note: For security, `nonce` is not supported when using `waitForHydration`. Instead you need to add the domain of the script directly to your [Content Securitiy Policy directives](https://shopify.dev/docs/storefronts/headless/hydrogen/content-security-policy#step-3-customize-the-content-security-policy).",
                "isOptional": true
              }
            ],
            "value": "interface HydrogenScriptProps {\n  /** Wait to load the script until after the page hydrates. This prevents hydration errors for scripts that modify the DOM. Note: For security, `nonce` is not supported when using `waitForHydration`. Instead you need to add the domain of the script directly to your [Content Securitiy Policy directives](https://shopify.dev/docs/storefronts/headless/hydrogen/content-security-policy#step-3-customize-the-content-security-policy).*/\n  waitForHydration?: boolean;\n}"
          },
          "ScriptAttributes": {
            "filePath": "src/csp/Script.tsx",
            "name": "ScriptAttributes",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "about",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "accessKey",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-activedescendant",
                "value": "string | undefined",
                "description": "Identifies the currently active element when DOM focus is on a composite widget, textbox, group, or application.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-atomic",
                "value": "Booleanish | undefined",
                "description": "Indicates whether assistive technologies will present all, or only parts of, the changed region based on the change notifications defined by the aria-relevant attribute.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-autocomplete",
                "value": "'none' | 'inline' | 'list' | 'both' | undefined",
                "description": "Indicates whether inputting text could trigger display of one or more predictions of the user's intended value for an input and specifies how predictions would be presented if they are made.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-braillelabel",
                "value": "string | undefined",
                "description": "Defines a string value that labels the current element, which is intended to be converted into Braille.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-brailleroledescription",
                "value": "string | undefined",
                "description": "Defines a human-readable, author-localized abbreviated description for the role of an element, which is intended to be converted into Braille.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-busy",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-checked",
                "value": "boolean | 'false' | 'mixed' | 'true' | undefined",
                "description": "Indicates the current \"checked\" state of checkboxes, radio buttons, and other widgets.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colcount",
                "value": "number | undefined",
                "description": "Defines the total number of columns in a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colindex",
                "value": "number | undefined",
                "description": "Defines an element's column index or position with respect to the total number of columns within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colindextext",
                "value": "string | undefined",
                "description": "Defines a human readable text alternative of aria-colindex.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colspan",
                "value": "number | undefined",
                "description": "Defines the number of columns spanned by a cell or gridcell within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-controls",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) whose contents or presence are controlled by the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-current",
                "value": "boolean | 'false' | 'true' | 'page' | 'step' | 'location' | 'date' | 'time' | undefined",
                "description": "Indicates the element that represents the current item within a container or set of related elements.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-describedby",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) that describes the object.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-description",
                "value": "string | undefined",
                "description": "Defines a string value that describes or annotates the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-details",
                "value": "string | undefined",
                "description": "Identifies the element that provides a detailed, extended description for the object.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-disabled",
                "value": "Booleanish | undefined",
                "description": "Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-dropeffect",
                "value": "'none' | 'copy' | 'execute' | 'link' | 'move' | 'popup' | undefined",
                "description": "Indicates what functions can be performed when a dragged object is released on the drop target.",
                "isOptional": true,
                "deprecationMessage": "in ARIA 1.1"
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-errormessage",
                "value": "string | undefined",
                "description": "Identifies the element that provides an error message for the object.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-expanded",
                "value": "Booleanish | undefined",
                "description": "Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-flowto",
                "value": "string | undefined",
                "description": "Identifies the next element (or elements) in an alternate reading order of content which, at the user's discretion, allows assistive technology to override the general default of reading in document source order.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-grabbed",
                "value": "Booleanish | undefined",
                "description": "Indicates an element's \"grabbed\" state in a drag-and-drop operation.",
                "isOptional": true,
                "deprecationMessage": "in ARIA 1.1"
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-haspopup",
                "value": "boolean | 'false' | 'true' | 'menu' | 'listbox' | 'tree' | 'grid' | 'dialog' | undefined",
                "description": "Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-hidden",
                "value": "Booleanish | undefined",
                "description": "Indicates whether the element is exposed to an accessibility API.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-invalid",
                "value": "boolean | 'false' | 'true' | 'grammar' | 'spelling' | undefined",
                "description": "Indicates the entered value does not conform to the format expected by the application.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-keyshortcuts",
                "value": "string | undefined",
                "description": "Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-label",
                "value": "string | undefined",
                "description": "Defines a string value that labels the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-labelledby",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) that labels the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-level",
                "value": "number | undefined",
                "description": "Defines the hierarchical level of an element within a structure.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-live",
                "value": "'off' | 'assertive' | 'polite' | undefined",
                "description": "Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-modal",
                "value": "Booleanish | undefined",
                "description": "Indicates whether an element is modal when displayed.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-multiline",
                "value": "Booleanish | undefined",
                "description": "Indicates whether a text box accepts multiple lines of input or only a single line.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-multiselectable",
                "value": "Booleanish | undefined",
                "description": "Indicates that the user may select more than one item from the current selectable descendants.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-orientation",
                "value": "'horizontal' | 'vertical' | undefined",
                "description": "Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-owns",
                "value": "string | undefined",
                "description": "Identifies an element (or elements) in order to define a visual, functional, or contextual parent/child relationship between DOM elements where the DOM hierarchy cannot be used to represent the relationship.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-placeholder",
                "value": "string | undefined",
                "description": "Defines a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-posinset",
                "value": "number | undefined",
                "description": "Defines an element's number or position in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-pressed",
                "value": "boolean | 'false' | 'mixed' | 'true' | undefined",
                "description": "Indicates the current \"pressed\" state of toggle buttons.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-readonly",
                "value": "Booleanish | undefined",
                "description": "Indicates that the element is not editable, but is otherwise operable.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-relevant",
                "value": "'additions' | 'additions removals' | 'additions text' | 'all' | 'removals' | 'removals additions' | 'removals text' | 'text' | 'text additions' | 'text removals' | undefined",
                "description": "Indicates what notifications the user agent will trigger when the accessibility tree within a live region is modified.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-required",
                "value": "Booleanish | undefined",
                "description": "Indicates that user input is required on the element before a form may be submitted.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-roledescription",
                "value": "string | undefined",
                "description": "Defines a human-readable, author-localized description for the role of an element.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowcount",
                "value": "number | undefined",
                "description": "Defines the total number of rows in a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowindex",
                "value": "number | undefined",
                "description": "Defines an element's row index or position with respect to the total number of rows within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowindextext",
                "value": "string | undefined",
                "description": "Defines a human readable text alternative of aria-rowindex.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowspan",
                "value": "number | undefined",
                "description": "Defines the number of rows spanned by a cell or gridcell within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-selected",
                "value": "Booleanish | undefined",
                "description": "Indicates the current \"selected\" state of various widgets.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-setsize",
                "value": "number | undefined",
                "description": "Defines the number of items in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-sort",
                "value": "'none' | 'ascending' | 'descending' | 'other' | undefined",
                "description": "Indicates if items in a table or grid are sorted in ascending or descending order.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuemax",
                "value": "number | undefined",
                "description": "Defines the maximum allowed value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuemin",
                "value": "number | undefined",
                "description": "Defines the minimum allowed value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuenow",
                "value": "number | undefined",
                "description": "Defines the current value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuetext",
                "value": "string | undefined",
                "description": "Defines the human readable text alternative of aria-valuenow for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "async",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoCapitalize",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoCorrect",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoFocus",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoSave",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "charSet",
                "value": "string | undefined",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Deprecated"
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "ReactNode | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "className",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "color",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "content",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "contentEditable",
                "value": "Booleanish | \"inherit\" | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "contextMenu",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crossOrigin",
                "value": "CrossOrigin",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "dangerouslySetInnerHTML",
                "value": "{\n            // Should be InnerHTML['innerHTML'].\n            // But unfortunately we're mixing renderer-specific type declarations.\n            __html: string | TrustedHTML;\n        } | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "datatype",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "defaultChecked",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "defaultValue",
                "value": "string | number | ReadonlyArray<string> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "defer",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "dir",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "draggable",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hidden",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inlist",
                "value": "any",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputMode",
                "value": "'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search' | undefined",
                "description": "Hints at the type of data that might be entered by the user while editing the element or its contents",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "integrity",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "is",
                "value": "string | undefined",
                "description": "Specify that a standard HTML element should behave like a defined custom built-in element",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemID",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemProp",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemRef",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemScope",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemType",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "lang",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "noModule",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "nonce",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAbort",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAbortCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationEnd",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationEndCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationIteration",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationIterationCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationStart",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationStartCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAuxClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAuxClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBeforeInput",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBeforeInputCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBlur",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBlurCapture",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlay",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayThrough",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayThroughCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onChange",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onChangeCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionEnd",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionEndCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionStart",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionStartCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionUpdate",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionUpdateCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onContextMenu",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onContextMenuCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCopy",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCopyCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCut",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCutCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDoubleClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDoubleClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDrag",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnd",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEndCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnter",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnterCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragExit",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragExitCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragLeave",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragLeaveCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragOver",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragOverCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragStart",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragStartCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDrop",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDropCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDurationChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDurationChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEmptied",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEmptiedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEncrypted",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEncryptedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEnded",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEndedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onError",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onErrorCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onFocus",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onFocusCapture",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onGotPointerCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onGotPointerCaptureCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInput",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInputCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInvalid",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInvalidCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyDown",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyDownCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyPress",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Deprecated"
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyPressCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Deprecated"
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyUp",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyUpCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoad",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedData",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedDataCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedMetadata",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedMetadataCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadStart",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadStartCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLostPointerCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLostPointerCaptureCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseDown",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseDownCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseEnter",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseLeave",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseMove",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseMoveCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOut",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOutCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOver",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOverCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseUp",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseUpCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPaste",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPasteCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPause",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPauseCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlay",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlayCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlaying",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlayingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerCancel",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerCancelCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerDown",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerDownCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerEnter",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerEnterCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerLeave",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerLeaveCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerMove",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerMoveCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOut",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOutCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOver",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOverCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerUp",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerUpCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onProgress",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onProgressCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onRateChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onRateChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onReset",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResetCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResize",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResizeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onScroll",
                "value": "UIEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onScrollCapture",
                "value": "UIEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeeked",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeekedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeeking",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeekingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSelect",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSelectCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onStalled",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onStalledCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSubmit",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSubmitCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSuspend",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSuspendCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTimeUpdate",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTimeUpdateCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchCancel",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchCancelCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchEnd",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchEndCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchMove",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchMoveCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchStart",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchStartCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTransitionEnd",
                "value": "TransitionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTransitionEndCapture",
                "value": "TransitionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVolumeChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVolumeChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWaiting",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWaitingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWheel",
                "value": "WheelEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWheelCapture",
                "value": "WheelEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "placeholder",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "prefix",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "property",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "radioGroup",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "referrerPolicy",
                "value": "HTMLAttributeReferrerPolicy | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "rel",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "resource",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "results",
                "value": "number | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "rev",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "role",
                "value": "AriaRole | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "security",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "slot",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "spellCheck",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "src",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "style",
                "value": "CSSProperties | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "suppressContentEditableWarning",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "suppressHydrationWarning",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "tabIndex",
                "value": "number | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "translate",
                "value": "'yes' | 'no' | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "typeof",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "unselectable",
                "value": "'on' | 'off' | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/Script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "vocab",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "interface ScriptAttributes extends ScriptHTMLAttributes<HTMLScriptElement> {}"
          }
        }
      }
    ]
  },
  {
    "name": "createContentSecurityPolicy",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "useNonce",
        "type": "hooks",
        "url": "/docs/api/hydrogen/2024-07/hooks/usenonce"
      },
      {
        "name": "Script",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/script"
      }
    ],
    "description": "Create a [content security policy](/docs/custom-storefronts/hydrogen/content-security-policy) to secure your application. The default content security policy includes exclusions for cdn.shopify.com and a script nonce.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {RemixServer} from '@remix-run/react';\nimport isbot from 'isbot';\nimport {renderToReadableStream} from 'react-dom/server';\nimport {createContentSecurityPolicy} from '@shopify/hydrogen';\n\nexport default async function handleRequest(\n  request,\n  responseStatusCode,\n  responseHeaders,\n  remixContext,\n) {\n  const {nonce, header, NonceProvider} = createContentSecurityPolicy({\n    // pass a custom directive to load content from a third party domain\n    styleSrc: [\n      \"'self'\",\n      'https://cdn.shopify.com',\n      'https://some-custom-css.cdn',\n    ],\n  });\n  const body = await renderToReadableStream(\n    &lt;NonceProvider&gt;\n      &lt;RemixServer context={remixContext} url={request.url} /&gt;\n    &lt;/NonceProvider&gt;,\n    {\n      nonce,\n      signal: request.signal,\n      onError(error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n        responseStatusCode = 500;\n      },\n    },\n  );\n\n  if (isbot(request.headers.get('user-agent'))) {\n    await body.allReady;\n  }\n\n  responseHeaders.set('Content-Type', 'text/html');\n  responseHeaders.set('Content-Security-Policy', header);\n\n  return new Response(body, {\n    headers: responseHeaders,\n    status: responseStatusCode,\n  });\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import type {EntryContext} from '@shopify/remix-oxygen';\nimport {RemixServer} from '@remix-run/react';\nimport isbot from 'isbot';\nimport {renderToReadableStream} from 'react-dom/server';\nimport {createContentSecurityPolicy} from '@shopify/hydrogen';\n\nexport default async function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext,\n) {\n  const {nonce, header, NonceProvider} = createContentSecurityPolicy({\n    // pass a custom directive to load content from a third party domain\n    styleSrc: [\n      \"'self'\",\n      'https://cdn.shopify.com',\n      'https://some-custom-css.cdn',\n    ],\n  });\n  const body = await renderToReadableStream(\n    &lt;NonceProvider&gt;\n      &lt;RemixServer context={remixContext} url={request.url} /&gt;\n    &lt;/NonceProvider&gt;,\n    {\n      nonce,\n      signal: request.signal,\n      onError(error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n        responseStatusCode = 500;\n      },\n    },\n  );\n\n  if (isbot(request.headers.get('user-agent'))) {\n    await body.allReady;\n  }\n\n  responseHeaders.set('Content-Type', 'text/html');\n  responseHeaders.set('Content-Security-Policy', header);\n\n  return new Response(body, {\n    headers: responseHeaders,\n    status: responseStatusCode,\n  });\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "CreateContentSecurityPolicyGeneratedType",
        "typeDefinitions": {
          "CreateContentSecurityPolicyGeneratedType": {
            "filePath": "src/csp/csp.ts",
            "name": "CreateContentSecurityPolicyGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "CreateContentSecurityPolicy & ShopProp",
                "isOptional": true,
                "filePath": "src/csp/csp.ts"
              }
            ],
            "returns": {
              "filePath": "src/csp/csp.ts",
              "description": "",
              "name": "ContentSecurityPolicy",
              "value": "ContentSecurityPolicy"
            },
            "value": "export function createContentSecurityPolicy(\n  props?: CreateContentSecurityPolicy & ShopProp,\n): ContentSecurityPolicy {\n  const nonce = generateNonce();\n  const header = createCSPHeader(nonce, props);\n\n  const Provider = ({children}: {children: ReactNode}) => {\n    return createElement(NonceProvider, {value: nonce}, children);\n  };\n\n  return {\n    nonce,\n    header,\n    NonceProvider: Provider,\n  };\n}"
          },
          "CreateContentSecurityPolicy": {
            "filePath": "src/csp/csp.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CreateContentSecurityPolicy",
            "value": "{\n  defaultSrc?: DirectiveValues;\n  scriptSrc?: DirectiveValues;\n  scriptSrcElem?: DirectiveValues;\n  styleSrc?: DirectiveValues;\n  imgSrc?: DirectiveValues;\n  connectSrc?: DirectiveValues;\n  fontSrc?: DirectiveValues;\n  objectSrc?: DirectiveValues;\n  mediaSrc?: DirectiveValues;\n  frameSrc?: DirectiveValues;\n  sandbox?: DirectiveValues;\n  reportUri?: DirectiveValues;\n  childSrc?: DirectiveValues;\n  formAction?: DirectiveValues;\n  frameAncestors?: DirectiveValues;\n  pluginTypes?: DirectiveValues;\n  baseUri?: DirectiveValues;\n  reportTo?: DirectiveValues;\n  workerSrc?: DirectiveValues;\n  manifestSrc?: DirectiveValues;\n  prefetchSrc?: DirectiveValues;\n  navigateTo?: DirectiveValues;\n  upgradeInsecureRequests?: boolean;\n  blockAllMixedContent?: boolean;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "baseUri",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "blockAllMixedContent",
                "value": "boolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "childSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "connectSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "defaultSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "fontSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "formAction",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "frameAncestors",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "frameSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "imgSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "manifestSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "mediaSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigateTo",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "objectSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "pluginTypes",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "prefetchSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "reportTo",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "reportUri",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "sandbox",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "scriptSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "scriptSrcElem",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "styleSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "upgradeInsecureRequests",
                "value": "boolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "workerSrc",
                "value": "DirectiveValues",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "DirectiveValues": {
            "filePath": "src/csp/csp.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DirectiveValues",
            "value": "string[] | string | boolean",
            "description": ""
          },
          "ShopProp": {
            "filePath": "src/csp/csp.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopProp",
            "value": "{\n  /** Shop specific configurations */\n  shop?: ShopifyDomains;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "shop",
                "value": "ShopifyDomains",
                "description": "Shop specific configurations",
                "isOptional": true
              }
            ]
          },
          "ShopifyDomains": {
            "filePath": "src/csp/csp.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyDomains",
            "value": "{\n  /** The production shop checkout domain url.  */\n  checkoutDomain?: string;\n  /** The production shop domain url. */\n  storeDomain?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "checkoutDomain",
                "value": "string",
                "description": "The production shop checkout domain url.",
                "isOptional": true
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "storeDomain",
                "value": "string",
                "description": "The production shop domain url.",
                "isOptional": true
              }
            ]
          },
          "ContentSecurityPolicy": {
            "filePath": "src/csp/csp.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ContentSecurityPolicy",
            "value": "{\n  /** A randomly generated nonce string that should be passed to any custom `script` element */\n  nonce: string;\n  /** The content security policy header */\n  header: string;\n  NonceProvider: ComponentType<{children: ReactNode}>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "header",
                "value": "string",
                "description": "The content security policy header"
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "nonce",
                "value": "string",
                "description": "A randomly generated nonce string that should be passed to any custom `script` element"
              },
              {
                "filePath": "src/csp/csp.ts",
                "syntaxKind": "PropertySignature",
                "name": "NonceProvider",
                "value": "ComponentType<{children: ReactNode}>",
                "description": ""
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "useNonce",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createContentSecurityPolicy",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/createcontentsecuritypolicy"
      },
      {
        "name": "Script",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/script"
      }
    ],
    "description": "The `useNonce` hook returns the [content security policy](/docs/custom-storefronts/hydrogen/content-security-policy) nonce. Use the hook to manually add a nonce to third party scripts. The `Script` component automatically does this for you. Note, the nonce should never be available in the client, and should always return undefined in the browser.",
    "type": "hook",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {useNonce} from '@shopify/hydrogen';\n\nexport default function App() {\n  const nonce = useNonce();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        &lt;ScrollRestoration nonce={nonce} /&gt;\n        &lt;Scripts nonce={nonce} /&gt;\n        &lt;LiveReload nonce={nonce} /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {useNonce} from '@shopify/hydrogen';\n\nexport default function App() {\n  const nonce = useNonce();\n\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        &lt;ScrollRestoration nonce={nonce} /&gt;\n        &lt;Scripts nonce={nonce} /&gt;\n        &lt;LiveReload nonce={nonce} /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "UseNonceGeneratedType",
        "typeDefinitions": {
          "UseNonceGeneratedType": {
            "filePath": "src/csp/csp.ts",
            "name": "UseNonceGeneratedType",
            "description": "",
            "params": [],
            "returns": {
              "filePath": "src/csp/csp.ts",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "useNonce = () => useContext(NonceContext)"
          }
        }
      }
    ]
  },
  {
    "name": "useCustomerPrivacy",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [],
    "description": "A hook that loads the [Customer Privacy API](/docs/api/customer-privacy).\n\nYou can get the customer privacy instance with `getCustomerPrivacy()`.\n\nYou can also listen to a `document` event for `shopifyCustomerPrivacyApiLoaded`. It will be emitted when the Customer Privacy API is loaded.",
    "type": "hook",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useCustomerPrivacy} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function MyComponent() {\n  const {customerPrivacy, privacyBanner = null} = useCustomerPrivacy({\n    storefrontAccessToken: '12345',\n    checkoutDomain: 'checkout.example.com',\n    onVisitorConsentCollected: (consent) =&gt; {\n      console.log('Visitor consent collected:', consent);\n    },\n  });\n\n  useEffect(() =&gt; {\n    if (customerPrivacy) {\n      // check if user has marketing consent\n      console.log(\n        'User marketing consent:',\n        customerPrivacy.analyticsProcessingAllowed(),\n      );\n\n      // or set tracking consent\n      customerPrivacy.setTrackingConsent(\n        {\n          marketing: true,\n          analytics: true,\n          preferences: true,\n          sale_of_data: true,\n        },\n        (data) =&gt; {\n          if (data?.error) {\n            console.error('Error setting tracking consent:', data.error);\n            return;\n          }\n          console.log('Tracking consent set');\n        },\n      );\n    }\n\n    if (privacyBanner) {\n      privacyBanner.loadBanner();\n\n      // or show banner with specific locale and country\n      // privacyBanner.loadBanner({locale: 'FR', country: 'CA'});\n\n      // or show consent preferences banner\n      // privacyBanner.showPreferences()\n\n      // or show consent preferences banner with specific locale and country\n      // privacyBanner.showPreferences({locale: 'FR', country: 'CA'});\n    }\n  }, [customerPrivacy, privacyBanner]);\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  type VisitorConsentCollected,\n  useCustomerPrivacy,\n} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function MyComponent() {\n  const {customerPrivacy, privacyBanner = null} = useCustomerPrivacy({\n    storefrontAccessToken: '12345',\n    checkoutDomain: 'checkout.example.com',\n    onVisitorConsentCollected: (consent: VisitorConsentCollected) =&gt; {\n      console.log('Visitor consent collected:', consent);\n    },\n  });\n\n  useEffect(() =&gt; {\n    if (customerPrivacy) {\n      // check if user has marketing consent\n      console.log(\n        'User marketing consent:',\n        customerPrivacy.analyticsProcessingAllowed(),\n      );\n\n      // or set tracking consent\n      customerPrivacy.setTrackingConsent(\n        {\n          marketing: true,\n          analytics: true,\n          preferences: true,\n          sale_of_data: true,\n        },\n        (data) =&gt; {\n          if (data?.error) {\n            console.error('Error setting tracking consent:', data.error);\n            return;\n          }\n          console.log('Tracking consent set');\n        },\n      );\n    }\n\n    if (privacyBanner) {\n      privacyBanner.loadBanner();\n\n      // or show banner with specific locale and country\n      // privacyBanner.loadBanner({locale: 'FR', country: 'CA'});\n\n      // or show consent preferences banner\n      // privacyBanner.showPreferences()\n\n      // or show consent preferences banner with specific locale and country\n      // privacyBanner.showPreferences({locale: 'FR', country: 'CA'});\n    }\n  }, [customerPrivacy, privacyBanner]);\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "",
        "description": "",
        "type": "UseCustomerPrivacyGeneratedType",
        "typeDefinitions": {
          "UseCustomerPrivacyGeneratedType": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "name": "UseCustomerPrivacyGeneratedType",
            "description": "",
            "params": [
              {
                "name": "props",
                "description": "",
                "value": "CustomerPrivacyApiProps",
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx"
              }
            ],
            "returns": {
              "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function useCustomerPrivacy(props: CustomerPrivacyApiProps) {\n  const {\n    withPrivacyBanner = true,\n    onVisitorConsentCollected,\n    onReady,\n    ...consentConfig\n  } = props;\n\n  // Load the Shopify customer privacy API with or without the privacy banner\n  // NOTE: We no longer use the status because we need `ready` to be not when the script is loaded\n  // but instead when both `privacyBanner` (optional) and customerPrivacy are loaded in the window\n  useLoadScript(withPrivacyBanner ? CONSENT_API_WITH_BANNER : CONSENT_API, {\n    attributes: {\n      id: 'customer-privacy-api',\n    },\n  });\n\n  const {observing, setLoaded} = useApisLoaded({\n    withPrivacyBanner,\n    onLoaded: onReady,\n  });\n\n  const config = useMemo(() => {\n    const {checkoutDomain, storefrontAccessToken} = consentConfig;\n\n    if (!checkoutDomain) logMissingConfig('checkoutDomain');\n    if (!storefrontAccessToken) logMissingConfig('storefrontAccessToken');\n\n    // validate that the storefront access token is not a server API token\n    if (\n      storefrontAccessToken.startsWith('shpat_') ||\n      storefrontAccessToken.length !== 32\n    ) {\n      // eslint-disable-next-line no-console\n      console.error(\n        `[h2:error:useCustomerPrivacy] It looks like you passed a private access token, make sure to use the public token`,\n      );\n    }\n\n    const config: CustomerPrivacyConsentConfig = {\n      checkoutRootDomain: checkoutDomain,\n      storefrontAccessToken,\n      storefrontRootDomain: parseStoreDomain(checkoutDomain),\n      country: consentConfig.country,\n      locale: consentConfig.locale,\n    };\n\n    return config;\n  }, [consentConfig, parseStoreDomain, logMissingConfig]);\n\n  // settings event listeners for visitorConsentCollected\n  useEffect(() => {\n    const consentCollectedHandler = (\n      event: CustomEvent<VisitorConsentCollected>,\n    ) => {\n      if (onVisitorConsentCollected) {\n        onVisitorConsentCollected(event.detail);\n      }\n    };\n\n    document.addEventListener(\n      'visitorConsentCollected',\n      consentCollectedHandler,\n    );\n\n    return () => {\n      document.removeEventListener(\n        'visitorConsentCollected',\n        consentCollectedHandler,\n      );\n    };\n  }, [onVisitorConsentCollected]);\n\n  // monitor when the `privacyBanner` is in the window and override it's methods with config\n  // pre-applied versions\n  useEffect(() => {\n    if (!withPrivacyBanner || observing.current.privacyBanner) return;\n    observing.current.privacyBanner = true;\n\n    let customPrivacyBanner: PrivacyBanner | undefined = undefined;\n\n    const privacyBannerWatcher = {\n      configurable: true,\n      get() {\n        return customPrivacyBanner;\n      },\n      set(value: unknown) {\n        if (\n          typeof value === 'object' &&\n          value !== null &&\n          'showPreferences' in value &&\n          'loadBanner' in value\n        ) {\n          const privacyBanner = value as PrivacyBanner;\n\n          // auto load the banner if applicable\n          privacyBanner.loadBanner(config);\n\n          // overwrite the privacyBanner methods\n          customPrivacyBanner = overridePrivacyBannerMethods({\n            privacyBanner,\n            config,\n          });\n\n          // set the loaded state for the privacyBanner\n          setLoaded.privacyBanner();\n          emitCustomerPrivacyApiLoaded();\n        }\n      },\n    };\n\n    Object.defineProperty(window, 'privacyBanner', privacyBannerWatcher);\n  }, [\n    withPrivacyBanner,\n    config,\n    overridePrivacyBannerMethods,\n    setLoaded.privacyBanner,\n  ]);\n\n  // monitor when the Shopify.customerPrivacy is added to the window and override the\n  // setTracking consent method with the config pre-applied\n  useEffect(() => {\n    if (observing.current.customerPrivacy) return;\n    observing.current.customerPrivacy = true;\n\n    let customCustomerPrivacy: CustomerPrivacy | null = null;\n    let customShopify: {customerPrivacy: CustomerPrivacy} | undefined | object =\n      undefined;\n\n    // monitor for when window.Shopify = {} is first set\n    Object.defineProperty(window, 'Shopify', {\n      configurable: true,\n      get() {\n        return customShopify;\n      },\n      set(value: unknown) {\n        // monitor for when window.Shopify = {} is first set\n        if (\n          typeof value === 'object' &&\n          value !== null &&\n          Object.keys(value).length === 0\n        ) {\n          customShopify = value as object;\n\n          // monitor for when window.Shopify.customerPrivacy is set\n          Object.defineProperty(window.Shopify, 'customerPrivacy', {\n            configurable: true,\n            get() {\n              return customCustomerPrivacy;\n            },\n            set(value: unknown) {\n              if (\n                typeof value === 'object' &&\n                value !== null &&\n                'setTrackingConsent' in value\n              ) {\n                const customerPrivacy = value as CustomerPrivacy;\n\n                // overwrite the tracking consent method\n                customCustomerPrivacy = {\n                  ...customerPrivacy,\n                  setTrackingConsent: overrideCustomerPrivacySetTrackingConsent(\n                    {customerPrivacy, config},\n                  ),\n                };\n\n                customShopify = {\n                  ...customShopify,\n                  customerPrivacy: customCustomerPrivacy,\n                };\n\n                setLoaded.customerPrivacy();\n                emitCustomerPrivacyApiLoaded();\n              }\n            },\n          });\n        }\n      },\n    });\n  }, [\n    config,\n    overrideCustomerPrivacySetTrackingConsent,\n    setLoaded.customerPrivacy,\n  ]);\n\n  // return the customerPrivacy and privacyBanner (optional) modified APIs\n  const result = {\n    customerPrivacy: getCustomerPrivacy(),\n  } as {\n    customerPrivacy: CustomerPrivacy | null;\n    privacyBanner?: PrivacyBanner | null;\n  };\n\n  if (withPrivacyBanner) {\n    result.privacyBanner = getPrivacyBanner();\n  }\n\n  return result;\n}"
          },
          "CustomerPrivacyApiProps": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerPrivacyApiProps",
            "value": "{\n  /** The production shop checkout domain url.  */\n  checkoutDomain: string;\n  /** The storefront access token for the shop. */\n  storefrontAccessToken: string;\n  /** Whether to load the Shopify privacy banner as configured in Shopify admin. Defaults to true. */\n  withPrivacyBanner?: boolean;\n  /** Country code for the shop. */\n  country?: CountryCode;\n  /** Language code for the shop. */\n  locale?: LanguageCode;\n  /** Callback to be called when visitor consent is collected. */\n  onVisitorConsentCollected?: (consent: VisitorConsentCollected) => void;\n  /** Callback to be call when customer privacy api is ready. */\n  onReady?: () => void;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "checkoutDomain",
                "value": "string",
                "description": "The production shop checkout domain url."
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": "Country code for the shop.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "locale",
                "value": "LanguageCode",
                "description": "Language code for the shop.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onReady",
                "value": "() => void",
                "description": "Callback to be call when customer privacy api is ready.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVisitorConsentCollected",
                "value": "(consent: VisitorConsentCollected) => void",
                "description": "Callback to be called when visitor consent is collected.",
                "isOptional": true
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storefrontAccessToken",
                "value": "string",
                "description": "The storefront access token for the shop."
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withPrivacyBanner",
                "value": "boolean",
                "description": "Whether to load the Shopify privacy banner as configured in Shopify admin. Defaults to true.",
                "isOptional": true
              }
            ]
          },
          "VisitorConsentCollected": {
            "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VisitorConsentCollected",
            "value": "{\n  analyticsAllowed: boolean;\n  firstPartyMarketingAllowed: boolean;\n  marketingAllowed: boolean;\n  preferencesAllowed: boolean;\n  saleOfDataAllowed: boolean;\n  thirdPartyMarketingAllowed: boolean;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "analyticsAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "firstPartyMarketingAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "marketingAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "preferencesAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "saleOfDataAllowed",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/customer-privacy/ShopifyCustomerPrivacy.tsx",
                "syntaxKind": "PropertySignature",
                "name": "thirdPartyMarketingAllowed",
                "value": "boolean",
                "description": ""
              }
            ]
          }
        }
      }
    ],
    "examples": {
      "description": "Example usage with `useAnalytics`:",
      "exampleGroups": [
        {
          "title": "getCustomerPrivacy",
          "examples": [
            {
              "description": "Returns the value of `window.Shopify.customerPrivacy` if it exists.",
              "codeblock": {
                "title": "",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {getCustomerPrivacy} from '@shopify/hydrogen';\nimport {useEffect} from 'react';\n\nexport function MyComponent() {\n  useEffect(() =&gt; {\n    const customerPrivacy = getCustomerPrivacy();\n    if (customerPrivacy) {\n      console.log('Customer privacy:', customerPrivacy);\n    }\n  }, []);\n}\n",
                    "language": "js"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "createCustomerAccountClient",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "createStorefrontClient",
        "type": "utility",
        "url": "/docs/api/hydrogen/2024-07/utilities/createstorefrontclient"
      }
    ],
    "description": "\nThe `createCustomerAccountClient` function creates a GraphQL client for querying the [Customer Account API](https://shopify.dev/docs/api/customer). It also provides methods to authenticate and check if the user is logged in.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {createCustomerAccountClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request, env, executionContext) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API token for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession {\n  isPending = false;\n\n  static async init(request, secrets) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key, value) {\n    this.session.flash(key, value);\n  }\n\n  unset(key) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key, value) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {\n  createCustomerAccountClient,\n  type HydrogenSession,\n} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n  type SessionStorage,\n  type Session,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API client ID for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession implements HydrogenSession {\n  public isPending = false;\n\n  constructor(\n    private sessionStorage: SessionStorage,\n    private session: Session,\n  ) {}\n\n  static async init(request: Request, secrets: string[]) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key: string) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key: string, value: any) {\n    this.session.flash(key, value);\n  }\n\n  unset(key: string) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key: string, value: any) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "createCustomerAccountClient(options)",
        "description": "",
        "type": "CustomerAccountOptions",
        "typeDefinitions": {
          "CustomerAccountOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccountOptions",
            "value": "{\n  /** The client requires a session to persist the auth and refresh token. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation.  */\n  session: HydrogenSession;\n  /** Unique UUID prefixed with `shp_` associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. Mock.shop doesn't automatically supply customerAccountId. Use `npx shopify hydrogen env pull` to link your store credentials. */\n  customerAccountId: string;\n  /** The account URL associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. Mock.shop doesn't automatically supply customerAccountUrl. Use `npx shopify hydrogen env pull` to link your store credentials. */\n  customerAccountUrl: string;\n  /** Override the version of the API */\n  customerApiVersion?: string;\n  /** The object for the current Request. It should be provided by your platform. */\n  request: CrossRuntimeRequest;\n  /** The waitUntil function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */\n  waitUntil?: WaitUntil;\n  /** This is the route in your app that authorizes the customer after logging in. Make sure to call `customer.authorize()` within the loader on this route. It defaults to `/account/authorize`. */\n  authUrl?: string;\n  /** Use this method to overwrite the default logged-out redirect behavior. The default handler [throws a redirect](https://remix.run/docs/en/main/utils/redirect#:~:text=!session) to `/account/login` with current path as `return_to` query param. */\n  customAuthStatusHandler?: () => DataFunctionValue;\n  /** Whether it should print GraphQL errors automatically. Defaults to true */\n  logErrors?: boolean | ((error?: Error) => boolean);\n  /** UNSTABLE feature, this will eventually goes away. If true then we will exchange customerAccessToken for storefrontCustomerAccessToken. */\n  unstableB2b?: boolean;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authUrl",
                "value": "string",
                "description": "This is the route in your app that authorizes the customer after logging in. Make sure to call `customer.authorize()` within the loader on this route. It defaults to `/account/authorize`.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customAuthStatusHandler",
                "value": "() => DataFunctionValue",
                "description": "Use this method to overwrite the default logged-out redirect behavior. The default handler [throws a redirect](https://remix.run/docs/en/main/utils/redirect#:~:text=!session) to `/account/login` with current path as `return_to` query param.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccountId",
                "value": "string",
                "description": "Unique UUID prefixed with `shp_` associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. Mock.shop doesn't automatically supply customerAccountId. Use `npx shopify hydrogen env pull` to link your store credentials."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerAccountUrl",
                "value": "string",
                "description": "The account URL associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. Mock.shop doesn't automatically supply customerAccountUrl. Use `npx shopify hydrogen env pull` to link your store credentials."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerApiVersion",
                "value": "string",
                "description": "Override the version of the API",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logErrors",
                "value": "boolean | ((error?: Error) => boolean)",
                "description": "Whether it should print GraphQL errors automatically. Defaults to true",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "CrossRuntimeRequest",
                "description": "The object for the current Request. It should be provided by your platform."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "session",
                "value": "HydrogenSession",
                "description": "The client requires a session to persist the auth and refresh token. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation."
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "unstableB2b",
                "value": "boolean",
                "description": "UNSTABLE feature, this will eventually goes away. If true then we will exchange customerAccessToken for storefrontCustomerAccessToken.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitUntil",
                "value": "WaitUntil",
                "description": "The waitUntil function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform.",
                "isOptional": true
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "CrossRuntimeRequest": {
            "filePath": "src/utils/request.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CrossRuntimeRequest",
            "value": "{\n  url?: string;\n  method?: string;\n  headers: {\n    get?: (key: string) => string | null | undefined;\n    [key: string]: any;\n  };\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "{ [key: string]: any; get?: (key: string) => string; }",
                "description": ""
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "method",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/utils/request.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      },
      {
        "title": "Returns",
        "description": "",
        "type": "CustomerAccountForDocs",
        "typeDefinitions": {
          "CustomerAccountForDocs": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccountForDocs",
            "value": "{\n  /** Start the OAuth login flow. This function should be called and returned from a Remix action.\n   * It redirects the customer to a Shopify login domain. It also defined the final path the customer\n   * lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is\n   * automatically setup unless `customAuthStatusHandler` option is in use)\n   *\n   * @param options.uiLocales - The displayed language of the login page. Only support for the following languages:\n   * `en`, `fr`, `cs`, `da`, `de`, `es`, `fi`, `it`, `ja`, `ko`, `nb`, `nl`, `pl`, `pt-BR`, `pt-PT`,\n   * `sv`, `th`, `tr`, `vi`, `zh-CN`, `zh-TW`. If supplied any other language code, it will default to `en`.\n   * */\n  login?: (options?: LoginOptions) => Promise<Response>;\n  /** On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin. */\n  authorize?: () => Promise<Response>;\n  /** Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed. */\n  isLoggedIn?: () => Promise<boolean>;\n  /** Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option. */\n  handleAuthStatus?: () => void | DataFunctionValue;\n  /** Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed. */\n  getAccessToken?: () => Promise<string | undefined>;\n  /** Creates the fully-qualified URL to your store's GraphQL endpoint.*/\n  getApiUrl?: () => string;\n  /** Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.\n   *\n   * @param options.postLogoutRedirectUri - The url to redirect customer to after logout, should be a relative URL. This url will need to included in Customer Account API's application setup for logout URI. The default value is current app origin, which is automatically setup in admin when using `--customer-account-push` flag with dev.\n   * */\n  logout?: (options?: LogoutOptions) => Promise<Response>;\n  /** Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query. */\n  query?: <TData = any>(\n    query: string,\n    options: CustomerAccountQueryOptionsForDocs,\n  ) => Promise<TData>;\n  /** Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation. */\n  mutate?: <TData = any>(\n    mutation: string,\n    options: CustomerAccountQueryOptionsForDocs,\n  ) => Promise<TData>;\n}",
            "description": "Below are types meant for documentation only. Ensure it stay in sync with the type above.",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "authorize",
                "value": "() => Promise<Response>",
                "description": "On successful login, the customer redirects back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings in admin.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getAccessToken",
                "value": "() => Promise<string>",
                "description": "Returns CustomerAccessToken if the customer is logged in. It also run a expiry check and does a token refresh if needed.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "() => string",
                "description": "Creates the fully-qualified URL to your store's GraphQL endpoint.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "handleAuthStatus",
                "value": "() => void | DataFunctionValue",
                "description": "Check for a not logged in customer and redirect customer to login page. The redirect can be overwritten with `customAuthStatusHandler` option.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "isLoggedIn",
                "value": "() => Promise<boolean>",
                "description": "Returns if the customer is logged in. It also checks if the access token is expired and refreshes it if needed.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "login",
                "value": "(options?: LoginOptions) => Promise<Response>",
                "description": "Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the customer to a Shopify login domain. It also defined the final path the customer lands on at the end of the oAuth flow with the value of the `return_to` query param. (This is automatically setup unless `customAuthStatusHandler` option is in use)",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "logout",
                "value": "(options?: LogoutOptions) => Promise<Response>",
                "description": "Logout the customer by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. The path app should redirect to after logout can be setup in Customer Account API settings in admin.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<TData = any>(mutation: string, options: CustomerAccountQueryOptionsForDocs) => Promise<TData>",
                "description": "Execute a GraphQL mutation against the Customer Account API. This method execute `handleAuthStatus()` ahead of mutation.",
                "isOptional": true
              },
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<TData = any>(query: string, options: CustomerAccountQueryOptionsForDocs) => Promise<TData>",
                "description": "Execute a GraphQL query against the Customer Account API. This method execute `handleAuthStatus()` ahead of query.",
                "isOptional": true
              }
            ]
          },
          "DataFunctionValue": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "DataFunctionValue",
            "value": "Response | NonNullable<unknown> | null",
            "description": ""
          },
          "LoginOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoginOptions",
            "value": "{\n  uiLocales?: LanguageCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uiLocales",
                "value": "LanguageCode",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "LogoutOptions": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LogoutOptions",
            "value": "{\n  postLogoutRedirectUri?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "postLogoutRedirectUri",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "CustomerAccountQueryOptionsForDocs": {
            "filePath": "src/customer/types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomerAccountQueryOptionsForDocs",
            "value": "{\n  /** The variables for the GraphQL statement. */\n  variables?: Record<string, unknown>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/customer/types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variables",
                "value": "Record<string, unknown>",
                "description": "The variables for the GraphQL statement.",
                "isOptional": true
              }
            ]
          }
        }
      }
    ],
    "examples": {
      "description": "Examples of how to opt out of default logged-out redirect",
      "exampleGroups": [
        {
          "title": "Customized logged-out behavior for the entire application",
          "examples": [
            {
              "description": "Throw error instead of redirect",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {createCustomerAccountClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n} from '@shopify/remix-oxygen';\n\n// In server.ts\nexport default {\n  async fetch(request, env, executionContext) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    function customAuthStatusHandler() {\n      return new Response('Customer is not login', {\n        status: 401,\n      });\n    }\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API client ID for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n      customAuthStatusHandler,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession {\n  isPending = false;\n\n  static async init(request, secrets) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key, value) {\n    this.session.flash(key, value);\n  }\n\n  unset(key) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key, value) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n\n/////////////////////////////////\n// In a route\nimport {\n  useLoaderData,\n  useRouteError,\n  isRouteErrorResponse,\n  useLocation,\n} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\n\nexport async function loader({context}) {\n  const {data} = await context.customerAccount.query(`#graphql\n    query getCustomer {\n      customer {\n        firstName\n        lastName\n      }\n    }\n    `);\n\n  return json({customer: data.customer});\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  const location = useLocation();\n\n  if (isRouteErrorResponse(error)) {\n    if (error.status == 401) {\n      return (\n        &lt;a\n          href={`/account/login?${new URLSearchParams({\n            return_to: location.pathname,\n          }).toString()}`}\n        &gt;\n          Login\n        &lt;/a&gt;\n      );\n    }\n  }\n}\n\n// this should be an default export\nexport function Route() {\n  const {customer} = useLoaderData();\n\n  return (\n    &lt;div style={{marginTop: 24}}&gt;\n      {customer ? (\n        &lt;&gt;\n          &lt;div style={{marginBottom: 24}}&gt;\n            &lt;b&gt;\n              Welcome {customer.firstName} {customer.lastName}\n            &lt;/b&gt;\n          &lt;/div&gt;\n        &lt;/&gt;\n      ) : null}\n    &lt;/div&gt;\n  );\n}\n",
                    "language": "jsx"
                  },
                  {
                    "title": "TypeScript",
                    "code": "import {\n  createCustomerAccountClient,\n  type HydrogenSession,\n} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n  type SessionStorage,\n  type Session,\n} from '@shopify/remix-oxygen';\n\n// In server.ts\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    function customAuthStatusHandler() {\n      return new Response('Customer is not login', {\n        status: 401,\n      });\n    }\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API client ID for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n      customAuthStatusHandler,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({session, customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession implements HydrogenSession {\n  public isPending = false;\n\n  constructor(\n    private sessionStorage: SessionStorage,\n    private session: Session,\n  ) {}\n\n  static async init(request: Request, secrets: string[]) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key: string) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key: string, value: any) {\n    this.session.flash(key, value);\n  }\n\n  unset(key: string) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key: string, value: any) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n\n// In env.d.ts\nimport type {CustomerAccount, HydrogenSessionData} from '@shopify/hydrogen';\ndeclare module '@shopify/remix-oxygen' {\n  /**\n   * Declare local additions to the Remix loader context.\n   */\n  interface AppLoadContext {\n    customerAccount: CustomerAccount;\n    session: AppSession;\n  }\n\n  /**\n   * Declare local additions to the Remix session data.\n   */\n  interface SessionData extends HydrogenSessionData {}\n}\n\n/////////////////////////////////\n// In a route\nimport {\n  useLoaderData,\n  useRouteError,\n  isRouteErrorResponse,\n  useLocation,\n} from '@remix-run/react';\nimport {type LoaderFunctionArgs, json} from '@shopify/remix-oxygen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const {data} = await context.customerAccount.query&lt;{\n    customer: {firstName: string; lastName: string};\n  }&gt;(`#graphql\n    query getCustomer {\n      customer {\n        firstName\n        lastName\n      }\n    }\n    `);\n\n  return json({customer: data.customer});\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  const location = useLocation();\n\n  if (isRouteErrorResponse(error)) {\n    if (error.status == 401) {\n      return (\n        &lt;a\n          href={`/account/login?${new URLSearchParams({\n            return_to: location.pathname,\n          }).toString()}`}\n        &gt;\n          Login\n        &lt;/a&gt;\n      );\n    }\n  }\n}\n\n// this should be an default export\nexport function Route() {\n  const {customer} = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;div style={{marginTop: 24}}&gt;\n      {customer ? (\n        &lt;&gt;\n          &lt;div style={{marginBottom: 24}}&gt;\n            &lt;b&gt;\n              Welcome {customer.firstName} {customer.lastName}\n            &lt;/b&gt;\n          &lt;/div&gt;\n        &lt;/&gt;\n      ) : null}\n    &lt;/div&gt;\n  );\n}\n",
                    "language": "tsx"
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "Opt out of logged-out behavior for a single route",
          "examples": [
            {
              "description": "Handle logged-out ahead of query",
              "codeblock": {
                "title": "Example",
                "tabs": [
                  {
                    "title": "JavaScript",
                    "code": "import {createCustomerAccountClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n} from '@shopify/remix-oxygen';\n\n// In server.ts\nexport default {\n  async fetch(request, env, executionContext) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    function customAuthStatusHandler() {\n      return new Response('Customer is not login', {\n        status: 401,\n      });\n    }\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API client ID for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n      customAuthStatusHandler,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession {\n  isPending = false;\n\n  static async init(request, secrets) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key, value) {\n    this.session.flash(key, value);\n  }\n\n  unset(key) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key, value) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n\n/////////////////////////////////\n// In a route\nimport {\n  useLoaderData,\n  useRouteError,\n  isRouteErrorResponse,\n  useLocation,\n} from '@remix-run/react';\nimport {json} from '@shopify/remix-oxygen';\n\nexport async function loader({context}) {\n  if (!(await context.customerAccount.isLoggedIn())) {\n    throw new Response('Customer is not login', {\n      status: 401,\n    });\n  }\n\n  const {data} = await context.customerAccount.query(\n    `#graphql\n    query getCustomer {\n      customer {\n        firstName\n        lastName\n      }\n    }\n    `,\n  );\n\n  return json({customer: data.customer});\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  const location = useLocation();\n\n  if (isRouteErrorResponse(error)) {\n    if (error.status == 401) {\n      return (\n        &lt;a\n          href={`/account/login?${new URLSearchParams({\n            return_to: location.pathname,\n          }).toString()}`}\n        &gt;\n          Login\n        &lt;/a&gt;\n      );\n    }\n  }\n}\n\n// this should be an default export\nexport function Route() {\n  const {customer} = useLoaderData();\n\n  return (\n    &lt;div style={{marginTop: 24}}&gt;\n      {customer ? (\n        &lt;&gt;\n          &lt;div style={{marginBottom: 24}}&gt;\n            &lt;b&gt;\n              Welcome {customer.firstName} {customer.lastName}\n            &lt;/b&gt;\n          &lt;/div&gt;\n        &lt;/&gt;\n      ) : null}\n    &lt;/div&gt;\n  );\n}\n",
                    "language": "jsx"
                  },
                  {
                    "title": "TypeScript",
                    "code": "import {\n  createCustomerAccountClient,\n  type HydrogenSession,\n} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  createCookieSessionStorage,\n  type SessionStorage,\n  type Session,\n} from '@shopify/remix-oxygen';\n\n// In server.ts\nexport default {\n  async fetch(\n    request: Request,\n    env: Record&lt;string, string&gt;,\n    executionContext: ExecutionContext,\n  ) {\n    const session = await AppSession.init(request, [env.SESSION_SECRET]);\n\n    function customAuthStatusHandler() {\n      return new Response('Customer is not login', {\n        status: 401,\n      });\n    }\n\n    /* Create a Customer API client with your credentials and options */\n    const customerAccount = createCustomerAccountClient({\n      /* Runtime utility in serverless environments */\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      /* Public Customer Account API client ID for your store */\n      customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_ID,\n      /* Public account URL for your store */\n      customerAccountUrl: env.PUBLIC_CUSTOMER_ACCOUNT_URL,\n      request,\n      session,\n      customAuthStatusHandler,\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n      /* Inject the customer account client in the Remix context */\n      getLoadContext: () =&gt; ({customerAccount}),\n    });\n\n    const response = await handleRequest(request);\n\n    if (session.isPending) {\n      response.headers.set('Set-Cookie', await session.commit());\n    }\n\n    return response;\n  },\n};\n\nclass AppSession implements HydrogenSession {\n  public isPending = false;\n\n  constructor(\n    private sessionStorage: SessionStorage,\n    private session: Session,\n  ) {}\n\n  static async init(request: Request, secrets: string[]) {\n    const storage = createCookieSessionStorage({\n      cookie: {\n        name: 'session',\n        httpOnly: true,\n        path: '/',\n        sameSite: 'lax',\n        secrets,\n      },\n    });\n\n    const session = await storage.getSession(request.headers.get('Cookie'));\n\n    return new this(storage, session);\n  }\n\n  get(key: string) {\n    return this.session.get(key);\n  }\n\n  destroy() {\n    return this.sessionStorage.destroySession(this.session);\n  }\n\n  flash(key: string, value: any) {\n    this.session.flash(key, value);\n  }\n\n  unset(key: string) {\n    this.isPending = true;\n    this.session.unset(key);\n  }\n\n  set(key: string, value: any) {\n    this.isPending = true;\n    this.session.set(key, value);\n  }\n\n  commit() {\n    this.isPending = false;\n    return this.sessionStorage.commitSession(this.session);\n  }\n}\n\n/////////////////////////////////\n// In a route\nimport {\n  useLoaderData,\n  useRouteError,\n  isRouteErrorResponse,\n  useLocation,\n} from '@remix-run/react';\nimport {type LoaderFunctionArgs, json} from '@shopify/remix-oxygen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  if (!(await context.customerAccount.isLoggedIn())) {\n    throw new Response('Customer is not login', {\n      status: 401,\n    });\n  }\n\n  const {data} = await context.customerAccount.query(\n    `#graphql\n    query getCustomer {\n      customer {\n        firstName\n        lastName\n      }\n    }\n    `,\n  );\n\n  return json({customer: data.customer});\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  const location = useLocation();\n\n  if (isRouteErrorResponse(error)) {\n    if (error.status == 401) {\n      return (\n        &lt;a\n          href={`/account/login?${new URLSearchParams({\n            return_to: location.pathname,\n          }).toString()}`}\n        &gt;\n          Login\n        &lt;/a&gt;\n      );\n    }\n  }\n}\n\n// this should be an default export\nexport function Route() {\n  const {customer} = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;div style={{marginTop: 24}}&gt;\n      {customer ? (\n        &lt;&gt;\n          &lt;div style={{marginBottom: 24}}&gt;\n            &lt;b&gt;\n              Welcome {customer.firstName} {customer.lastName}\n            &lt;/b&gt;\n          &lt;/div&gt;\n        &lt;/&gt;\n      ) : null}\n    &lt;/div&gt;\n  );\n}\n",
                    "language": "tsx"
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "name": "OptimisticInput",
    "category": "components",
    "isVisualComponent": false,
    "related": [],
    "description": "Creates a form input for optimistic UI updates. Use `useOptimisticData` to update the UI with the latest optimistic data.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {CartForm, OptimisticInput, useOptimisticData} from '@shopify/hydrogen';\n\nexport default function Cart({line}) {\n  const optimisticId = line.id;\n  const optimisticData = useOptimisticData(optimisticId);\n\n  return (\n    &lt;div\n      style={{\n        // Hide the line item if the optimistic data action is remove\n        // Do not remove the form from the DOM\n        display: optimisticData?.action === 'remove' ? 'none' : 'block',\n      }}\n    &gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{\n          lineIds: [line.id],\n        }}\n      &gt;\n        &lt;button type=\"submit\"&gt;Remove&lt;/button&gt;\n        &lt;OptimisticInput id={optimisticId} data={{action: 'remove'}} /&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {CartForm, OptimisticInput, useOptimisticData} from '@shopify/hydrogen';\nimport {CartLine} from '@shopify/hydrogen-react/storefront-api-types';\n\ntype OptimisticData = {\n  action: string;\n};\n\nexport default function Cart({line}: {line: CartLine}) {\n  const optimisticId = line.id;\n  const optimisticData = useOptimisticData&lt;OptimisticData&gt;(optimisticId);\n\n  return (\n    &lt;div\n      style={{\n        // Hide the line item if the optimistic data action is remove\n        // Do not remove the form from the DOM\n        display: optimisticData?.action === 'remove' ? 'none' : 'block',\n      }}\n    &gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{\n          lineIds: [line.id],\n        }}\n      &gt;\n        &lt;button type=\"submit\"&gt;Remove&lt;/button&gt;\n        &lt;OptimisticInput id={optimisticId} data={{action: 'remove'}} /&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "OptimisticInputProps",
        "typeDefinitions": {
          "OptimisticInputProps": {
            "filePath": "src/optimistic-ui/optimistic-ui.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticInputProps",
            "value": "{\n  /**\n   * A unique identifier for the optimistic input. Use the same identifier in `useOptimisticData`\n   * to retrieve the optimistic data from actions.\n   */\n  id: string;\n  /**\n   * The data to be stored in the optimistic input. Use for creating an optimistic successful state\n   * of this form action.\n   */\n  data: Record<string, unknown>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/optimistic-ui/optimistic-ui.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "Record<string, unknown>",
                "description": "The data to be stored in the optimistic input. Use for creating an optimistic successful state of this form action."
              },
              {
                "filePath": "src/optimistic-ui/optimistic-ui.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string",
                "description": "A unique identifier for the optimistic input. Use the same identifier in `useOptimisticData` to retrieve the optimistic data from actions."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "useOptimisticData",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [],
    "description": "Gets the latest optimistic data with matching optimistic id from actions. Use `OptimisticInput` to accept optimistic data in forms.",
    "type": "component",
    "defaultExample": {
      "description": "This is the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {CartForm, OptimisticInput, useOptimisticData} from '@shopify/hydrogen';\n\nexport default function Cart({line}) {\n  const optimisticId = line.id;\n  const optimisticData = useOptimisticData(optimisticId);\n\n  return (\n    &lt;div\n      style={{\n        // Hide the line item if the optimistic data action is remove\n        // Do not remove the form from the DOM\n        display: optimisticData?.action === 'remove' ? 'none' : 'block',\n      }}\n    &gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{\n          lineIds: [line.id],\n        }}\n      &gt;\n        &lt;button type=\"submit\"&gt;Remove&lt;/button&gt;\n        &lt;OptimisticInput id={optimisticId} data={{action: 'remove'}} /&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {CartForm, OptimisticInput, useOptimisticData} from '@shopify/hydrogen';\nimport {CartLine} from '@shopify/hydrogen-react/storefront-api-types';\n\ntype OptimisticData = {\n  action: string;\n};\n\nexport default function Cart({line}: {line: CartLine}) {\n  const optimisticId = line.id;\n  const optimisticData = useOptimisticData&lt;OptimisticData&gt;(optimisticId);\n\n  return (\n    &lt;div\n      style={{\n        // Hide the line item if the optimistic data action is remove\n        // Do not remove the form from the DOM\n        display: optimisticData?.action === 'remove' ? 'none' : 'block',\n      }}\n    &gt;\n      &lt;CartForm\n        route=\"/cart\"\n        action={CartForm.ACTIONS.LinesRemove}\n        inputs={{\n          lineIds: [line.id],\n        }}\n      &gt;\n        &lt;button type=\"submit\"&gt;Remove&lt;/button&gt;\n        &lt;OptimisticInput id={optimisticId} data={{action: 'remove'}} /&gt;\n      &lt;/CartForm&gt;\n    &lt;/div&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "UseOptimisticDataGeneratedType",
        "typeDefinitions": {
          "UseOptimisticDataGeneratedType": {
            "filePath": "src/optimistic-ui/optimistic-ui.tsx",
            "name": "UseOptimisticDataGeneratedType",
            "description": "",
            "params": [
              {
                "name": "identifier",
                "description": "",
                "value": "string",
                "filePath": "src/optimistic-ui/optimistic-ui.tsx"
              }
            ],
            "returns": {
              "filePath": "src/optimistic-ui/optimistic-ui.tsx",
              "description": "",
              "name": "",
              "value": ""
            },
            "value": "export function useOptimisticData<T>(identifier: string) {\n  const fetchers = useFetchers();\n  const data: Record<string, unknown> = {};\n\n  for (const {formData} of fetchers) {\n    if (formData?.get('optimistic-identifier') === identifier) {\n      try {\n        if (formData.has('optimistic-data')) {\n          const dataInForm: unknown = JSON.parse(\n            String(formData.get('optimistic-data')),\n          );\n          Object.assign(data, dataInForm);\n        }\n      } catch {\n        // do nothing\n      }\n    }\n  }\n  return data as T;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "Pagination",
    "category": "components",
    "isVisualComponent": false,
    "related": [
      {
        "name": "getPaginationVariables",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/getpaginationvariables"
      }
    ],
    "description": "The [Storefront API uses cursors](https://shopify.dev/docs/api/usage/pagination-graphql) to paginate through lists of data and the `<Pagination />` component makes it easy to paginate data from the Storefront API. It is important for pagination state to be maintained in the URL, so that the user can navigate to a product and return back to the same scrolled position in a list. It is also important that the list state is shareable via URL. The `<Pagination>` component provides a render prop with properties to load more elements into your list.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {Pagination, getPaginationVariables} from '@shopify/hydrogen';\nimport {useLoaderData, Link} from '@remix-run/react';\n\nexport async function loader({request, context: {storefront}}) {\n  const variables = getPaginationVariables(request, {pageBy: 8});\n\n  const data = await storefront.query(ALL_PRODUCTS_QUERY, {\n    variables,\n  });\n\n  return json({products: data.products});\n}\n\nexport default function List() {\n  const {products} = useLoaderData();\n\n  return (\n    &lt;Pagination connection={products}&gt;\n      {({nodes, PreviousLink, NextLink}) =&gt; (\n        &lt;&gt;\n          &lt;PreviousLink&gt;Previous&lt;/PreviousLink&gt;\n          &lt;div&gt;\n            {nodes.map((product) =&gt; (\n              &lt;Link key={product.id} to={`/products/${product.handle}`}&gt;\n                {product.title}\n              &lt;/Link&gt;\n            ))}\n          &lt;/div&gt;\n          &lt;NextLink&gt;Next&lt;/NextLink&gt;\n        &lt;/&gt;\n      )}\n    &lt;/Pagination&gt;\n  );\n}\n\nconst ALL_PRODUCTS_QUERY = `#graphql\n  query AllProducts(\n    $country: CountryCode\n    $language: LanguageCode\n    $first: Int\n    $last: Int\n    $startCursor: String\n    $endCursor: String\n  ) @inContext(country: $country, language: $language) {\n    products(first: $first, last: $last, before: $startCursor, after: $endCursor) {\n      nodes { id\n        title\n        handle\n      }\n      pageInfo {\n        hasPreviousPage\n        hasNextPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n`;\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {Pagination, getPaginationVariables} from '@shopify/hydrogen';\nimport {useLoaderData, Link} from '@remix-run/react';\nimport {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport async function loader({\n  request,\n  context: {storefront},\n}: LoaderFunctionArgs) {\n  const variables = getPaginationVariables(request, {pageBy: 8});\n\n  const data = await storefront.query&lt;{products: ProductConnection}&gt;(\n    ALL_PRODUCTS_QUERY,\n    {\n      variables,\n    },\n  );\n\n  return json({products: data.products});\n}\n\nexport default function List() {\n  const {products} = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;Pagination connection={products}&gt;\n      {({nodes, NextLink, PreviousLink}) =&gt; (\n        &lt;&gt;\n          &lt;PreviousLink&gt;Previous&lt;/PreviousLink&gt;\n          &lt;div&gt;\n            {nodes.map((product) =&gt; (\n              &lt;Link key={product.id} to={`/products/${product.handle}`}&gt;\n                {product.title}\n              &lt;/Link&gt;\n            ))}\n          &lt;/div&gt;\n          &lt;NextLink&gt;Next&lt;/NextLink&gt;\n        &lt;/&gt;\n      )}\n    &lt;/Pagination&gt;\n  );\n}\n\nconst ALL_PRODUCTS_QUERY = `#graphql\n  query AllProducts(\n    $country: CountryCode\n    $language: LanguageCode\n    $first: Int\n    $last: Int\n    $startCursor: String\n    $endCursor: String\n  ) @inContext(country: $country, language: $language) {\n    products(first: $first, last: $last, before: $startCursor, after: $endCursor) {\n      nodes { id\n        title\n        handle\n      }\n      pageInfo {\n        hasPreviousPage\n        hasNextPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n`;\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "PaginationProps",
        "typeDefinitions": {
          "PaginationProps": {
            "filePath": "src/pagination/Pagination.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PaginationProps",
            "value": "{\n  /** The response from `storefront.query` for a paginated request. Make sure the query is passed pagination variables and that the query has `pageInfo` with `hasPreviousPage`, `hasNextpage`, `startCursor`, and `endCursor` defined. */\n  connection: Connection<NodesType>;\n  /** A render prop that includes pagination data and helpers. */\n  children: PaginationRenderProp<NodesType>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "PaginationRenderProp<NodesType>",
                "description": "A render prop that includes pagination data and helpers."
              },
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "connection",
                "value": "Connection<NodesType>",
                "description": "The response from `storefront.query` for a paginated request. Make sure the query is passed pagination variables and that the query has `pageInfo` with `hasPreviousPage`, `hasNextpage`, `startCursor`, and `endCursor` defined."
              }
            ]
          },
          "PaginationRenderProp": {
            "filePath": "src/pagination/Pagination.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "PaginationRenderProp",
            "value": "FC<PaginationInfo<NodesType>>",
            "description": "",
            "members": [
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "contextTypes",
                "value": "ValidationMap<any> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "defaultProps",
                "value": "Partial<P> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/pagination/Pagination.ts",
                "syntaxKind": "PropertySignature",
                "name": "propTypes",
                "value": "WeakValidationMap<P> | undefined",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "Connection": {
            "filePath": "src/pagination/Pagination.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Connection",
            "value": "{\n      nodes: Array<NodesType>;\n      pageInfo: PageInfo;\n    } | {\n      edges: Array<{\n        node: NodesType;\n      }>;\n      pageInfo: PageInfo;\n    }",
            "description": ""
          }
        }
      }
    ]
  },
  {
    "name": "getPaginationVariables",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "Pagination",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/pagination"
      }
    ],
    "description": "The `getPaginationVariables` function is used with the [`<Pagination>`](/docs/api/hydrogen/components/pagnination) component to generate the variables needed to fetch paginated data from the Storefront API. The returned variables should be used within your storefront GraphQL query.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {json} from '@shopify/remix-oxygen';\nimport {Pagination, getPaginationVariables} from '@shopify/hydrogen';\nimport {useLoaderData, Link} from '@remix-run/react';\n\nexport async function loader({request, context: {storefront}}) {\n  const variables = getPaginationVariables(request, {pageBy: 8});\n\n  const data = await storefront.query(ALL_PRODUCTS_QUERY, {\n    variables,\n  });\n\n  return json({products: data.products});\n}\n\nexport default function List() {\n  const {products} = useLoaderData();\n\n  return (\n    &lt;Pagination connection={products}&gt;\n      {({nodes, PreviousLink, NextLink}) =&gt; (\n        &lt;&gt;\n          &lt;PreviousLink&gt;Previous&lt;/PreviousLink&gt;\n          &lt;div&gt;\n            {nodes.map((product) =&gt; (\n              &lt;Link key={product.id} to={`/products/${product.handle}`}&gt;\n                {product.title}\n              &lt;/Link&gt;\n            ))}\n          &lt;/div&gt;\n          &lt;NextLink&gt;Next&lt;/NextLink&gt;\n        &lt;/&gt;\n      )}\n    &lt;/Pagination&gt;\n  );\n}\n\nconst ALL_PRODUCTS_QUERY = `#graphql\n  query AllProducts(\n    $country: CountryCode\n    $language: LanguageCode\n    $first: Int\n    $last: Int\n    $startCursor: String\n    $endCursor: String\n  ) @inContext(country: $country, language: $language) {\n    products(first: $first, last: $last, before: $startCursor, after: $endCursor) {\n      nodes { id\n        title\n        handle\n      }\n      pageInfo {\n        hasPreviousPage\n        hasNextPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n`;\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {Pagination, getPaginationVariables} from '@shopify/hydrogen';\nimport {useLoaderData, Link} from '@remix-run/react';\nimport {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport async function loader({\n  request,\n  context: {storefront},\n}: LoaderFunctionArgs) {\n  const variables = getPaginationVariables(request, {pageBy: 8});\n\n  const data = await storefront.query&lt;{products: ProductConnection}&gt;(\n    ALL_PRODUCTS_QUERY,\n    {\n      variables,\n    },\n  );\n\n  return json({products: data.products});\n}\n\nexport default function List() {\n  const {products} = useLoaderData&lt;typeof loader&gt;();\n\n  return (\n    &lt;Pagination connection={products}&gt;\n      {({nodes, NextLink, PreviousLink}) =&gt; (\n        &lt;&gt;\n          &lt;PreviousLink&gt;Previous&lt;/PreviousLink&gt;\n          &lt;div&gt;\n            {nodes.map((product) =&gt; (\n              &lt;Link key={product.id} to={`/products/${product.handle}`}&gt;\n                {product.title}\n              &lt;/Link&gt;\n            ))}\n          &lt;/div&gt;\n          &lt;NextLink&gt;Next&lt;/NextLink&gt;\n        &lt;/&gt;\n      )}\n    &lt;/Pagination&gt;\n  );\n}\n\nconst ALL_PRODUCTS_QUERY = `#graphql\n  query AllProducts(\n    $country: CountryCode\n    $language: LanguageCode\n    $first: Int\n    $last: Int\n    $startCursor: String\n    $endCursor: String\n  ) @inContext(country: $country, language: $language) {\n    products(first: $first, last: $last, before: $startCursor, after: $endCursor) {\n      nodes { id\n        title\n        handle\n      }\n      pageInfo {\n        hasPreviousPage\n        hasNextPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n`;\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "GetPaginationVariablesGeneratedType",
        "typeDefinitions": {
          "GetPaginationVariablesGeneratedType": {
            "filePath": "src/pagination/Pagination.ts",
            "name": "GetPaginationVariablesGeneratedType",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "The request object passed to your Remix loader function.",
                "value": "Request",
                "filePath": "src/pagination/Pagination.ts"
              },
              {
                "name": "options",
                "description": "Options for how to configure the pagination variables. Includes the ability to change how many nodes are within each page.",
                "value": "{ pageBy: number; }",
                "isOptional": true,
                "defaultValue": "{pageBy: 20}",
                "filePath": "src/pagination/Pagination.ts"
              }
            ],
            "returns": {
              "filePath": "src/pagination/Pagination.ts",
              "description": "Variables to be used with the `storefront.query` function",
              "name": "",
              "value": ""
            },
            "value": "export function getPaginationVariables(\n  request: Request,\n  options: {pageBy: number} = {pageBy: 20},\n) {\n  if (typeof request?.url === 'undefined') {\n    throw new Error(\n      'getPaginationVariables must be called with the Request object passed to your loader function',\n    );\n  }\n\n  const {pageBy} = options;\n  const searchParams = new URLSearchParams(new URL(request.url).search);\n\n  const cursor = searchParams.get('cursor') ?? undefined;\n  const direction =\n    searchParams.get('direction') === 'previous' ? 'previous' : 'next';\n  const isPrevious = direction === 'previous';\n\n  const prevPage = {\n    last: pageBy,\n    startCursor: cursor ?? null,\n  };\n\n  const nextPage = {\n    first: pageBy,\n    endCursor: cursor ?? null,\n  };\n\n  const variables = isPrevious ? prevPage : nextPage;\n\n  return variables;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "VariantSelector",
    "category": "components",
    "isVisualComponent": true,
    "related": [
      {
        "name": "getSelectedProductOptions",
        "type": "utilities",
        "url": "/docs/api/hydrogen/2024-07/utilities/getselectedproductoptions"
      }
    ],
    "description": "The `VariantSelector` component helps you build a form for selecting available variants of a product. It is important for variant selection state to be maintained in the URL, so that the user can navigate to a product and return back to the same variant selection. It is also important that the variant selection state is shareable via URL. The `VariantSelector` component provides a render prop that renders for each product option.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {VariantSelector} from '@shopify/hydrogen';\nimport {Link} from '@remix-run/react';\n\nconst ProductForm = ({product}) =&gt; {\n  return (\n    &lt;VariantSelector\n      handle={product.handle}\n      options={product.options}\n      variants={product.variants}\n    &gt;\n      {({option}) =&gt; (\n        &lt;&gt;\n          &lt;div&gt;{option.name}&lt;/div&gt;\n          &lt;div&gt;\n            {option.values.map(\n              ({value, isAvailable, to, isActive, variant}) =&gt; (\n                &lt;Link\n                  to={to}\n                  prefetch=\"intent\"\n                  className={\n                    isActive ? 'active' : isAvailable ? '' : 'opacity-80'\n                  }\n                &gt;\n                  {value}\n                  &lt;br /&gt;\n                  {variant && `SKU: ${variant.sku}`}\n                &lt;/Link&gt;\n              ),\n            )}\n          &lt;/div&gt;\n        &lt;/&gt;\n      )}\n    &lt;/VariantSelector&gt;\n  );\n};\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {VariantSelector} from '@shopify/hydrogen';\nimport type {Product} from '@shopify/hydrogen/storefront-api-types';\nimport {Link} from '@remix-run/react';\n\nconst ProductForm = ({product}: {product: Product}) =&gt; {\n  return (\n    &lt;VariantSelector\n      handle={product.handle}\n      options={product.options}\n      variants={product.variants}\n    &gt;\n      {({option}) =&gt; (\n        &lt;&gt;\n          &lt;div&gt;{option.name}&lt;/div&gt;\n          &lt;div&gt;\n            {option.values.map(\n              ({value, isAvailable, to, isActive, variant}) =&gt; (\n                &lt;Link\n                  to={to}\n                  prefetch=\"intent\"\n                  className={\n                    isActive ? 'active' : isAvailable ? '' : 'opacity-80'\n                  }\n                &gt;\n                  {value}\n                  &lt;br /&gt;\n                  {variant && `SKU: ${variant.sku}`}\n                &lt;/Link&gt;\n              ),\n            )}\n          &lt;/div&gt;\n        &lt;/&gt;\n      )}\n    &lt;/VariantSelector&gt;\n  );\n};\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "VariantSelectorProps",
        "typeDefinitions": {
          "VariantSelectorProps": {
            "filePath": "src/product/VariantSelector.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VariantSelectorProps",
            "value": "{\n  /** The product handle for all of the variants */\n  handle: string;\n  /** Product options from the [Storefront API](/docs/api/storefront/2024-07/objects/ProductOption). Make sure both `name` and `values` are apart of your query. */\n  options: Array<PartialDeep<ProductOption>> | undefined;\n  /** Product variants from the [Storefront API](/docs/api/storefront/2024-07/objects/ProductVariant). You only need to pass this prop if you want to show product availability. If a product option combination is not found within `variants`, it is assumed to be available. Make sure to include `availableForSale` and `selectedOptions.name` and `selectedOptions.value`. */\n  variants?:\n    | PartialDeep<ProductVariantConnection>\n    | Array<PartialDeep<ProductVariant>>;\n  /** By default all products are under /products. Use this prop to provide a custom path. */\n  productPath?: string;\n  /** Should the VariantSelector wait to update until after the browser navigates to a variant. */\n  waitForNavigation?: boolean;\n  children: ({option}: {option: VariantOption}) => ReactNode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "({ option }: { option: VariantOption; }) => ReactNode",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "handle",
                "value": "string",
                "description": "The product handle for all of the variants"
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "options",
                "value": "Array<PartialDeep<ProductOption>> | undefined",
                "description": "Product options from the [Storefront API](/docs/api/storefront/2024-07/objects/ProductOption). Make sure both `name` and `values` are apart of your query."
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "productPath",
                "value": "string",
                "description": "By default all products are under /products. Use this prop to provide a custom path.",
                "isOptional": true
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "variants",
                "value": "| PartialDeep<ProductVariantConnection>\n    | Array<PartialDeep<ProductVariant>>",
                "description": "Product variants from the [Storefront API](/docs/api/storefront/2024-07/objects/ProductVariant). You only need to pass this prop if you want to show product availability. If a product option combination is not found within `variants`, it is assumed to be available. Make sure to include `availableForSale` and `selectedOptions.name` and `selectedOptions.value`.",
                "isOptional": true
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "waitForNavigation",
                "value": "boolean",
                "description": "Should the VariantSelector wait to update until after the browser navigates to a variant.",
                "isOptional": true
              }
            ]
          },
          "VariantOption": {
            "filePath": "src/product/VariantSelector.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VariantOption",
            "value": "{\n  name: string;\n  value?: string;\n  values: Array<VariantOptionValue>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "values",
                "value": "Array<VariantOptionValue>",
                "description": ""
              }
            ]
          },
          "VariantOptionValue": {
            "filePath": "src/product/VariantSelector.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VariantOptionValue",
            "value": "{\n  value: string;\n  isAvailable: boolean;\n  to: string;\n  search: string;\n  isActive: boolean;\n  variant?: PartialDeep<ProductVariant>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "isActive",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "isAvailable",
                "value": "boolean",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "search",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "to",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "value",
                "value": "string",
                "description": ""
              },
              {
                "filePath": "src/product/VariantSelector.ts",
                "syntaxKind": "PropertySignature",
                "name": "variant",
                "value": "PartialDeep<ProductVariant>",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getSelectedProductOptions",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "VariantSelector",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/variantselector"
      }
    ],
    "description": "The `getSelectedProductOptions` returns the selected options from the Request search parameters. The selected options can then be easily passed to your GraphQL query with [`variantBySelectedOptions`](https://shopify.dev/docs/api/storefront/2024-07/objects/product#field-product-variantbyselectedoptions).",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {getSelectedProductOptions} from '@shopify/hydrogen';\nimport {json} from '@shopify/remix-oxygen';\n\nexport async function loader({request, params, context}) {\n  const selectedOptions = getSelectedProductOptions(request);\n\n  const {product} = await context.storefront.query(PRODUCT_QUERY, {\n    variables: {\n      handle: params.productHandle,\n      selectedOptions,\n    },\n  });\n\n  return json({product});\n}\n\nconst PRODUCT_QUERY = `#graphql\n  query Product($handle: String!, $selectedOptions: [SelectedOptionInput!]!) {\n    product(handle: $handle) {\n      title\n      description\n      options {\n        name\n        values \n      }\n      selectedVariant: variantBySelectedOptions(selectedOptions: $selectedOptions, ignoreUnknownOptions: true, caseInsensitiveMatch: true) {\n        ...ProductVariantFragment\n      }\n    }\n  }\n`;\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {getSelectedProductOptions} from '@shopify/hydrogen';\nimport {json, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\n\nexport async function loader({request, params, context}: LoaderFunctionArgs) {\n  const selectedOptions = getSelectedProductOptions(request);\n\n  const {product} = await context.storefront.query(PRODUCT_QUERY, {\n    variables: {\n      handle: params.productHandle,\n      selectedOptions,\n    },\n  });\n\n  return json({product});\n}\n\nconst PRODUCT_QUERY = `#graphql\n  query Product($handle: String!, $selectedOptions: [SelectedOptionInput!]!) {\n    product(handle: $handle) {\n      title\n      description\n      options {\n        name\n        values \n      }\n      selectedVariant: variantBySelectedOptions(selectedOptions: $selectedOptions, ignoreUnknownOptions: true, caseInsensitiveMatch: true) {\n        ...ProductVariantFragment\n      }\n    }\n  }\n`;\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "GetSelectedProductOptions",
        "typeDefinitions": {
          "GetSelectedProductOptions": {
            "filePath": "src/product/VariantSelector.ts",
            "name": "GetSelectedProductOptions",
            "description": "",
            "params": [
              {
                "name": "request",
                "description": "",
                "value": "Request",
                "filePath": "src/product/VariantSelector.ts"
              }
            ],
            "returns": {
              "filePath": "src/product/VariantSelector.ts",
              "description": "",
              "name": "SelectedOptionInput[]",
              "value": "SelectedOptionInput[]"
            },
            "value": "type GetSelectedProductOptions = (request: Request) => SelectedOptionInput[];"
          }
        }
      }
    ]
  },
  {
    "name": "useOptimisticVariant",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [
      {
        "name": "VariantSelector",
        "type": "components",
        "url": "/docs/api/hydrogen/2024-07/components/variantselector"
      },
      {
        "name": "useOptimisticCart",
        "type": "hooks",
        "url": "/docs/api/hydrogen/2024-07/hooks/useoptimisticcart"
      }
    ],
    "description": "The `useOptimisticVariant` takes an existing product variant, processes a pending navigation to another product variant, and returns the data of the destination variant. This makes switching product options immediate.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {defer} from '@remix-run/server-runtime';\nimport {useOptimisticVariant} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  return defer({\n    product: await context.storefront.query('/** product query **/'),\n    // Note that variants does not need to be awaited to be used by `useOptimisticVariant`\n    variants: context.storefront.query('/** variants query **/'),\n  });\n}\n\nfunction Product() {\n  const {product, variants} = useLoaderData();\n\n  // The selectedVariant optimistically changes during page\n  // transitions with one of the preloaded product variants\n  const selectedVariant = useOptimisticVariant(\n    product.selectedVariant,\n    variants,\n  );\n\n  // @ts-ignore\n  return &lt;ProductMain selectedVariant={selectedVariant} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {useLoaderData} from '@remix-run/react';\nimport {defer, LoaderFunctionArgs} from '@remix-run/server-runtime';\nimport {useOptimisticVariant} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  return defer({\n    product: await context.storefront.query('/** product query */'),\n    // Note that variants does not need to be awaited to be used by `useOptimisticVariant`\n    variants: context.storefront.query('/** variants query */'),\n  });\n}\n\nfunction Product() {\n  const {product, variants} = useLoaderData&lt;typeof loader&gt;();\n\n  // The selectedVariant optimistically changes during page\n  // transitions with one of the preloaded product variants\n  const selectedVariant = useOptimisticVariant(\n    product.selectedVariant,\n    variants,\n  );\n\n  // @ts-ignore\n  return &lt;ProductMain selectedVariant={selectedVariant} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "UseOptimisticVariantGeneratedType",
        "typeDefinitions": {
          "UseOptimisticVariantGeneratedType": {
            "filePath": "src/product/useOptimisticVariant.ts",
            "name": "UseOptimisticVariantGeneratedType",
            "description": "",
            "params": [
              {
                "name": "selectedVariant",
                "description": "The `selectedVariant` field queried with `variantBySelectedOptions`.",
                "value": "SelectedVariant",
                "filePath": "src/product/useOptimisticVariant.ts"
              },
              {
                "name": "variants",
                "description": "The available product variants for the product. This can be an array of variants, a promise that resolves to an array of variants, or an object with a `product` key that contains the variants.",
                "value": "Variants",
                "filePath": "src/product/useOptimisticVariant.ts"
              }
            ],
            "returns": {
              "filePath": "src/product/useOptimisticVariant.ts",
              "description": "A new product object where the `selectedVariant` property is set to the variant that matches the current URL search params. If no variant is found, the original product object is returned. The `isOptimistic` property is set to `true` if the `selectedVariant` has been optimistically changed.",
              "name": "OptimisticVariant<SelectedVariant = OptimisticVariantInput>",
              "value": "OptimisticVariant<SelectedVariant = OptimisticVariantInput>"
            },
            "value": "export function useOptimisticVariant<\n  SelectedVariant = OptimisticVariantInput,\n  Variants = OptimisticProductVariants,\n>(\n  selectedVariant: SelectedVariant,\n  variants: Variants,\n): OptimisticVariant<SelectedVariant> {\n  const navigation = useNavigation();\n  const [resolvedVariants, setResolvedVariants] = useState<\n    Array<PartialDeep<ProductVariant>>\n  >([]);\n\n  useEffect(() => {\n    Promise.resolve(variants)\n      .then((productWithVariants) => {\n        if (productWithVariants) {\n          setResolvedVariants(\n            productWithVariants instanceof Array\n              ? productWithVariants\n              : (productWithVariants as PartialDeep<ProductVariant>).product\n                  ?.variants?.nodes || [],\n          );\n        }\n      })\n      .catch((error) => {\n        reportError(\n          new Error(\n            '[h2:error:useOptimisticVariant] An error occurred while resolving the variants for the optimistic product hook.',\n            {\n              cause: error,\n            },\n          ),\n        );\n      });\n  }, [variants]);\n\n  if (navigation.state === 'loading') {\n    const queryParams = new URLSearchParams(navigation.location.search);\n    let reportedError = false;\n\n    // Find matching variant\n    const matchingVariant = resolvedVariants.find((variant) => {\n      if (!variant.selectedOptions) {\n        if (!reportedError) {\n          reportedError = true;\n          reportError(\n            new Error(\n              '[h2:error:useOptimisticVariant] The optimistic product hook requires your product query to include variants with the selectedOptions field.',\n            ),\n          );\n        }\n        return false;\n      }\n\n      return variant.selectedOptions.every((option) => {\n        return queryParams.get(option.name) === option.value;\n      });\n    });\n\n    if (matchingVariant) {\n      return {\n        ...matchingVariant,\n        isOptimistic: true,\n      } as OptimisticVariant<SelectedVariant>;\n    }\n  }\n\n  return selectedVariant as OptimisticVariant<SelectedVariant>;\n}"
          },
          "OptimisticVariant": {
            "filePath": "src/product/useOptimisticVariant.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticVariant",
            "value": "T & {\n  isOptimistic?: boolean;\n}",
            "description": ""
          },
          "OptimisticVariantInput": {
            "filePath": "src/product/useOptimisticVariant.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "OptimisticVariantInput",
            "value": "PartialDeep<ProductVariant>",
            "description": "",
            "members": []
          }
        }
      }
    ]
  },
  {
    "name": "graphiqlLoader",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "This function creates an instance of [GraphiQL](https://graphql.org/swapi-graphql) in your Hydrogen app when running on a development server. This enables you to explore, write, and test GraphQL queries using your store's live data from the Storefront API. You can visit the GraphiQL app at your storefront route /graphiql. Learn more about [using GraphiQL in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/graphiql).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {graphiqlLoader} from '@shopify/hydrogen';\nimport {redirect} from '@shopify/remix-oxygen';\n\nexport async function loader(args) {\n  if (process.env.NODE_ENV === 'development') {\n    return graphiqlLoader(args);\n  }\n\n  return redirect('/');\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {graphiqlLoader} from '@shopify/hydrogen';\nimport {redirect, type LoaderFunctionArgs} from '@shopify/remix-oxygen';\n\nexport async function loader(args: LoaderFunctionArgs) {\n  if (process.env.NODE_ENV === 'development') {\n    return graphiqlLoader(args);\n  }\n\n  return redirect('/');\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "GraphiQLLoader",
        "typeDefinitions": {
          "GraphiQLLoader": {
            "filePath": "src/routing/graphiql.ts",
            "name": "GraphiQLLoader",
            "description": "",
            "params": [
              {
                "name": "args",
                "description": "",
                "value": "LoaderFunctionArgs",
                "filePath": "src/routing/graphiql.ts"
              }
            ],
            "returns": {
              "filePath": "src/routing/graphiql.ts",
              "description": "",
              "name": "Promise<Response>",
              "value": "Promise<Response>"
            },
            "value": "type GraphiQLLoader = (args: LoaderFunctionArgs) => Promise<Response>;"
          }
        }
      }
    ]
  },
  {
    "name": "storefrontRedirect",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "Queries the Storefront API to see if there is any redirect [created for the current route](https://help.shopify.com/en/manual/online-store/menus-and-links/url-redirect) and performs it. Otherwise, it returns the response passed in the parameters. Useful for conditionally redirecting after a 404 response.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {storefrontRedirect, createStorefrontClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request, env, executionContext) {\n    const {storefront} = createStorefrontClient({\n      cache: await caches.open('hydrogen'),\n      waitUntil: (p) =&gt; executionContext.waitUntil(p),\n      privateStorefrontToken: env.PRIVATE_STOREFRONT_API_TOKEN,\n      publicStorefrontToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      storeDomain: env.PUBLIC_STORE_DOMAIN,\n      storefrontHeaders: getStorefrontHeaders(request),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n    });\n\n    const response = await handleRequest(request);\n\n    if (response.status === 404) {\n      /**\n       * Check for redirects only when there's a 404 from\n       * the app. If the redirect doesn't exist, then\n       * `storefrontRedirect` will pass through the 404\n       * response.\n       */\n      return storefrontRedirect({request, response, storefront});\n    }\n\n    return response;\n  },\n};\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {storefrontRedirect, createStorefrontClient} from '@shopify/hydrogen';\nimport * as remixBuild from '@remix-run/dev/server-build';\nimport {\n  createRequestHandler,\n  getStorefrontHeaders,\n} from '@shopify/remix-oxygen';\n\nexport default {\n  async fetch(request: Request, env: Env, executionContext: ExecutionContext) {\n    const {storefront} = createStorefrontClient({\n      cache: await caches.open('hydrogen'),\n      waitUntil: (p: Promise&lt;unknown&gt;) =&gt; executionContext.waitUntil(p),\n      privateStorefrontToken: env.PRIVATE_STOREFRONT_API_TOKEN,\n      publicStorefrontToken: env.PUBLIC_STOREFRONT_API_TOKEN,\n      storeDomain: env.PUBLIC_STORE_DOMAIN,\n      storefrontHeaders: getStorefrontHeaders(request),\n    });\n\n    const handleRequest = createRequestHandler({\n      build: remixBuild,\n      mode: process.env.NODE_ENV,\n    });\n\n    const response = await handleRequest(request);\n\n    if (response.status === 404) {\n      /**\n       * Check for redirects only when there's a 404 from\n       * the app. If the redirect doesn't exist, then\n       * `storefrontRedirect` will pass through the 404\n       * response.\n       */\n      return storefrontRedirect({request, response, storefront});\n    }\n\n    return response;\n  },\n};\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Arguments",
        "description": "",
        "type": "StorefrontRedirectGeneratedType",
        "typeDefinitions": {
          "StorefrontRedirectGeneratedType": {
            "filePath": "src/routing/redirect.ts",
            "name": "StorefrontRedirectGeneratedType",
            "description": "Queries the Storefront API to see if there is any redirect created for the current route and performs it. Otherwise, it returns the response passed in the parameters. Useful for conditionally redirecting after a 404 response.",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "StorefrontRedirect",
                "filePath": "src/routing/redirect.ts"
              }
            ],
            "returns": {
              "filePath": "src/routing/redirect.ts",
              "description": "",
              "name": "Promise<Response>",
              "value": "Promise<Response>"
            },
            "value": "export async function storefrontRedirect(\n  options: StorefrontRedirect,\n): Promise<Response> {\n  const {\n    storefront,\n    request,\n    noAdminRedirect,\n    matchQueryParams,\n    response = new Response('Not Found', {status: 404}),\n  } = options;\n\n  const url = new URL(request.url);\n  const {pathname, searchParams} = url;\n  const isSoftNavigation = searchParams.has('_data');\n\n  searchParams.delete('redirect');\n  searchParams.delete('return_to');\n  searchParams.delete('_data');\n\n  const redirectFrom = (\n    matchQueryParams ? url.toString().replace(url.origin, '') : pathname\n  ).toLowerCase();\n\n  if (url.pathname === '/admin' && !noAdminRedirect) {\n    return createRedirectResponse(\n      `${storefront.getShopifyDomain()}/admin`,\n      isSoftNavigation,\n      searchParams,\n      matchQueryParams,\n    );\n  }\n\n  try {\n    const {urlRedirects} = await storefront.query<{\n      urlRedirects: UrlRedirectConnection;\n    }>(REDIRECT_QUERY, {\n      // The admin doesn't allow redirects to have a\n      // trailing slash, so strip them all off\n      variables: {query: 'path:' + redirectFrom.replace(/\\/+$/, '')},\n    });\n\n    const location = urlRedirects?.edges?.[0]?.node?.target;\n\n    if (location) {\n      return createRedirectResponse(\n        location,\n        isSoftNavigation,\n        searchParams,\n        matchQueryParams,\n      );\n    }\n\n    const redirectTo = getRedirectUrl(request.url);\n\n    if (redirectTo) {\n      return createRedirectResponse(\n        redirectTo,\n        isSoftNavigation,\n        searchParams,\n        matchQueryParams,\n      );\n    }\n  } catch (error) {\n    console.error(\n      `Failed to fetch redirects from Storefront API for route ${redirectFrom}`,\n      error,\n    );\n  }\n\n  return response;\n}"
          },
          "StorefrontRedirect": {
            "filePath": "src/routing/redirect.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontRedirect",
            "value": "{\n  /** The [Storefront client](/docs/api/hydrogen/2024-07/utilities/createstorefrontclient) instance */\n  storefront: Storefront<I18nBase>;\n  /** The [MDN Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that was passed to the `server.ts` request handler. */\n  request: Request;\n  /** The [MDN Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object created by `handleRequest` */\n  response?: Response;\n  /** By default the `/admin` route is redirected to the Shopify Admin page for the current storefront. Disable this redirect by passing `true`. */\n  noAdminRedirect?: boolean;\n  /** By default, query parameters are not used to match redirects. Set this to `true` if you'd like redirects to be query parameter sensitive */\n  matchQueryParams?: boolean;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/routing/redirect.ts",
                "syntaxKind": "PropertySignature",
                "name": "matchQueryParams",
                "value": "boolean",
                "description": "By default, query parameters are not used to match redirects. Set this to `true` if you'd like redirects to be query parameter sensitive",
                "isOptional": true
              },
              {
                "filePath": "src/routing/redirect.ts",
                "syntaxKind": "PropertySignature",
                "name": "noAdminRedirect",
                "value": "boolean",
                "description": "By default the `/admin` route is redirected to the Shopify Admin page for the current storefront. Disable this redirect by passing `true`.",
                "isOptional": true
              },
              {
                "filePath": "src/routing/redirect.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "Request",
                "description": "The [MDN Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that was passed to the `server.ts` request handler."
              },
              {
                "filePath": "src/routing/redirect.ts",
                "syntaxKind": "PropertySignature",
                "name": "response",
                "value": "Response",
                "description": "The [MDN Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object created by `handleRequest`",
                "isOptional": true
              },
              {
                "filePath": "src/routing/redirect.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront<I18nBase>",
                "description": "The [Storefront client](/docs/api/hydrogen/2024-07/utilities/createstorefrontclient) instance"
              }
            ]
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          },
          "I18nBase": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "I18nBase",
            "value": "{\n  language: LanguageCode;\n  country: CountryCode;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "country",
                "value": "CountryCode",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "LanguageCode",
                "description": ""
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getSeoMeta",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "Generate a [Remix meta array](https://remix.run/docs/en/main/route/meta) from one or more SEO configuration objects. Pass SEO configuration for the parent route(s) and the current route to preserve meta data for all active routes. Similar to [`Object.assign()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), each property is overwritten based on the object order. The exception is `jsonLd`, which is preserved so that each route has it's own independent jsonLd meta data. Learn more about [how SEO works in Hydrogen](https://shopify.dev/docs/custom-storefronts/hydrogen/seo).",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {getSeoMeta} from '@shopify/hydrogen';\n\nexport async function loader({context}) {\n  const {shop} = await context.storefront.query(`\n    query layout {\n      shop {\n        name\n        description\n      }\n    }\n  `);\n\n  return {\n    seo: {\n      title: shop.title,\n      description: shop.description,\n    },\n  };\n}\n\nexport const meta = ({data, matches}) =&gt; {\n  // Pass one or more arguments, preserving properties from parent routes\n  return getSeoMeta(matches[0].data.seo, data.seo);\n};\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {MetaFunction} from '@remix-run/react';\nimport {LoaderFunctionArgs} from '@remix-run/server-runtime';\nimport {getSeoMeta} from '@shopify/hydrogen';\n\nexport async function loader({context}: LoaderFunctionArgs) {\n  const {shop} = await context.storefront.query(`\n    query layout {\n      shop {\n        name\n        description\n      }\n    }\n  `);\n\n  return {\n    seo: {\n      title: shop.title,\n      description: shop.description,\n    },\n  };\n}\n\nexport const meta: MetaFunction&lt;typeof loader&gt; = ({data, matches}) =&gt; {\n  // Pass one or more arguments, preserving properties from parent routes\n  return getSeoMeta((matches as any)[0].data.seo, data!.seo);\n};\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "getSeoMeta",
        "description": "",
        "type": "GetSeoMetaTypeForDocs",
        "typeDefinitions": {
          "GetSeoMetaTypeForDocs": {
            "filePath": "src/seo/getSeoMeta.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "GetSeoMetaTypeForDocs",
            "value": "{\n  /** `getSeoMeta` takes an arbitrary number of configuration object parameters. Values in each object are overwritten based on the object order. \\`jsonLd\\` properties are preserved between each configuration object. */\n  seoInputs: SeoConfig[];\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/getSeoMeta.ts",
                "syntaxKind": "PropertySignature",
                "name": "seoInputs",
                "value": "SeoConfig[]",
                "description": "`getSeoMeta` takes an arbitrary number of configuration object parameters. Values in each object are overwritten based on the object order. \\`jsonLd\\` properties are preserved between each configuration object."
              }
            ]
          },
          "SeoConfig": {
            "filePath": "src/seo/generate-seo-tags.ts",
            "name": "SeoConfig",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "alternates",
                "value": "LanguageAlternate | LanguageAlternate[]",
                "description": "The `alternates` property is used to specify the language and geographical targeting when you have multiple versions of the same page in different languages. The `url` property tells search engines about these variations and helps them to serve the correct version to their users.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "{\n  alternates: [\n    {\n      language: 'en-US',\n      url: 'https://hydrogen.shop/en-us',\n      default: true,\n    },\n    {\n      language: 'fr-CA',\n      url: 'https://hydrogen.shop/fr-ca',\n    },\n  ]\n}",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "description",
                "value": "Maybe<string>",
                "description": "The description of the page. This is used in the `name=\"description\"` meta tag as well as the `og:description` meta tag.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "handle",
                "value": "Maybe<string>",
                "description": "The handle is used to generate the `twitter:site` and `twitter:creator` meta tags. Include the `@` symbol in the handle.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "{\n  handle: '@shopify'\n}",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "jsonLd",
                "value": "WithContext<Thing> | WithContext<Thing>[]",
                "description": "The `jsonLd` property is used to generate the `application/ld+json` script tag. This is used to provide structured data to search engines. The value should be an object that conforms to the schema.org spec. The `type` property should be the type of schema you are using. The `type` property is required and should be one of the following:\n\n- `Product`\n- `ItemList`\n- `Organization`\n- `WebSite`\n- `WebPage`\n- `BlogPosting`\n- `Thing`\n\nThe value is validated via [schema-dts](https://www.npmjs.com/package/schema-dts)",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "{\n  jsonLd: {\n    '@context': 'https://schema.org',\n    '@type': 'Product',\n    name: 'My Product',\n    image: 'https://hydrogen.shop/image.jpg',\n    description: 'A product that is great',\n    sku: '12345',\n    mpn: '12345',\n    brand: {\n      '@type': 'Thing',\n      name: 'My Brand',\n    },\n    aggregateRating: {\n      '@type': 'AggregateRating',\n      ratingValue: '4.5',\n      reviewCount: '100',\n    },\n    offers: {\n      '@type': 'Offer',\n      priceCurrency: 'USD',\n      price: '100',\n      priceValidUntil: '2020-11-05',\n      itemCondition: 'https://schema.org/NewCondition',\n      availability: 'https://schema.org/InStock',\n      seller: {\n        '@type': 'Organization',\n        name: 'My Brand',\n      },\n    },\n  }\n}",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "media",
                "value": "| Maybe<string>\n    | Partial<SeoMedia>\n    | (Partial<SeoMedia> | Maybe<string>)[]",
                "description": "The media associated with the given page (images, videos, etc). If you pass a string, it will be used as the `og:image` meta tag. If you pass an object or an array of objects, that will be used to generate `og:<type of media>` meta tags. The `url` property should be the URL of the media. The `height` and `width` properties are optional and should be the height and width of the media. The `altText` property is optional and should be a description of the media.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "{\n  media: [\n    {\n      url: 'https://example.com/image.jpg',\n      type: 'image',\n      height: '400',\n      width: '400',\n      altText: 'A custom snowboard with an alpine color pallet.',\n    }\n  ]\n}",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "robots",
                "value": "RobotsOptions",
                "description": "The `robots` property is used to specify the robots meta tag. This is used to tell search engines which pages should be indexed and which should not.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "Maybe<string>",
                "description": "The `title` HTML element defines the document's title that is shown in a browser's title bar or a page's tab. It only contains text; tags within the element are ignored.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "titleTemplate",
                "value": "Maybe<string> | null",
                "description": "Generate the title from a template that includes a `%s` placeholder for the title.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "{\n  title: 'My Page',\n  titleTemplate: 'My Site - %s',\n}",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "Maybe<string>",
                "description": "The canonical URL of the page. This is used to tell search engines which URL is the canonical version of a page. This is useful when you have multiple URLs that point to the same page. The value here will be used in the `rel=\"canonical\"` link tag as well as the `og:url` meta tag.",
                "isOptional": true
              }
            ],
            "value": "export interface SeoConfig {\n  /**\n   * The `title` HTML element defines the document's title that is shown in a browser's title bar or a page's tab. It\n   * only contains text; tags within the element are ignored.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title\n   */\n  title?: Maybe<string>;\n  /**\n   * Generate the title from a template that includes a `%s` placeholder for the title.\n   *\n   * @example\n   * ```js\n   * {\n   *   title: 'My Page',\n   *   titleTemplate: 'My Site - %s',\n   * }\n   * ```\n   */\n  titleTemplate?: Maybe<string> | null;\n  /**\n   * The media associated with the given page (images, videos, etc). If you pass a string, it will be used as the\n   * `og:image` meta tag. If you pass an object or an array of objects, that will be used to generate `og:<type of\n   * media>` meta tags. The `url` property should be the URL of the media. The `height` and `width` properties are\n   * optional and should be the height and width of the media. The `altText` property is optional and should be a\n   * description of the media.\n   *\n   * @example\n   * ```js\n   * {\n   *   media: [\n   *     {\n   *       url: 'https://example.com/image.jpg',\n   *       type: 'image',\n   *       height: '400',\n   *       width: '400',\n   *       altText: 'A custom snowboard with an alpine color pallet.',\n   *     }\n   *   ]\n   * }\n   * ```\n   *\n   */\n  media?:\n    | Maybe<string>\n    | Partial<SeoMedia>\n    | (Partial<SeoMedia> | Maybe<string>)[];\n  /**\n   * The description of the page. This is used in the `name=\"description\"` meta tag as well as the `og:description` meta\n   * tag.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\n   */\n  description?: Maybe<string>;\n  /**\n   * The canonical URL of the page. This is used to tell search engines which URL is the canonical version of a page.\n   * This is useful when you have multiple URLs that point to the same page. The value here will be used in the\n   * `rel=\"canonical\"` link tag as well as the `og:url` meta tag.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link\n   */\n  url?: Maybe<string>;\n  /**\n   * The handle is used to generate the `twitter:site` and `twitter:creator` meta tags. Include the `@` symbol in the\n   * handle.\n   *\n   * @example\n   * ```js\n   * {\n   *   handle: '@shopify'\n   * }\n   * ```\n   */\n  handle?: Maybe<string>;\n  /**\n   * The `jsonLd` property is used to generate the `application/ld+json` script tag. This is used to provide structured\n   * data to search engines. The value should be an object that conforms to the schema.org spec. The `type` property\n   * should be the type of schema you are using. The `type` property is required and should be one of the following:\n   *\n   * - `Product`\n   * - `ItemList`\n   * - `Organization`\n   * - `WebSite`\n   * - `WebPage`\n   * - `BlogPosting`\n   * - `Thing`\n   *\n   * The value is validated via [schema-dts](https://www.npmjs.com/package/schema-dts)\n   *\n   * @example\n   * ```js\n   * {\n   *   jsonLd: {\n   *     '@context': 'https://schema.org',\n   *     '@type': 'Product',\n   *     name: 'My Product',\n   *     image: 'https://hydrogen.shop/image.jpg',\n   *     description: 'A product that is great',\n   *     sku: '12345',\n   *     mpn: '12345',\n   *     brand: {\n   *       '@type': 'Thing',\n   *       name: 'My Brand',\n   *     },\n   *     aggregateRating: {\n   *       '@type': 'AggregateRating',\n   *       ratingValue: '4.5',\n   *       reviewCount: '100',\n   *     },\n   *     offers: {\n   *       '@type': 'Offer',\n   *       priceCurrency: 'USD',\n   *       price: '100',\n   *       priceValidUntil: '2020-11-05',\n   *       itemCondition: 'https://schema.org/NewCondition',\n   *       availability: 'https://schema.org/InStock',\n   *       seller: {\n   *         '@type': 'Organization',\n   *         name: 'My Brand',\n   *       },\n   *     },\n   *   }\n   * }\n   * ```\n   *\n   * @see https://schema.org/docs/schemas.html\n   * @see https://developers.google.com/search/docs/guides/intro-structured-data\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n   *\n   */\n  jsonLd?: WithContext<Thing> | WithContext<Thing>[];\n  /**\n   * The `alternates` property is used to specify the language and geographical targeting when you have multiple\n   * versions of the same page in different languages. The `url` property tells search engines about these variations\n   * and helps them to serve the correct version to their users.\n   *\n   * @example\n   * ```js\n   * {\n   *   alternates: [\n   *     {\n   *       language: 'en-US',\n   *       url: 'https://hydrogen.shop/en-us',\n   *       default: true,\n   *     },\n   *     {\n   *       language: 'fr-CA',\n   *       url: 'https://hydrogen.shop/fr-ca',\n   *     },\n   *   ]\n   * }\n   * ```\n   *\n   * @see https://support.google.com/webmasters/answer/189077?hl=en\n   */\n  alternates?: LanguageAlternate | LanguageAlternate[];\n  /**\n   * The `robots` property is used to specify the robots meta tag. This is used to tell search engines which pages\n   * should be indexed and which should not.\n   *\n   * @see https://developers.google.com/search/reference/robots_meta_tag\n   */\n  robots?: RobotsOptions;\n}"
          },
          "LanguageAlternate": {
            "filePath": "src/seo/generate-seo-tags.ts",
            "name": "LanguageAlternate",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "default",
                "value": "boolean",
                "description": "Whether the alternate page is the default page. This will add the `x-default` attribution to the language code.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "language",
                "value": "string",
                "description": "Language code for the alternate page. This is used to generate the hreflang meta tag property."
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "The url of the alternate page. This is used to generate the hreflang meta tag property."
              }
            ],
            "value": "export interface LanguageAlternate {\n  /**\n   * Language code for the alternate page. This is used to generate the hreflang meta tag property.\n   */\n  language: string;\n  /**\n   * Whether the alternate page is the default page. This will add the `x-default` attribution to the language code.\n   */\n  default?: boolean;\n  /**\n   * The url of the alternate page. This is used to generate the hreflang meta tag property.\n   */\n  url: string;\n}"
          },
          "SeoMedia": {
            "filePath": "src/seo/generate-seo-tags.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SeoMedia",
            "value": "{\n  /**\n   * Used to generate og:<type of media> meta tag\n   */\n  type: 'image' | 'video' | 'audio';\n  /**\n   * The url value populates both url and secure_url and is used to infer the og:<type of media>:type meta tag.\n   */\n  url: Maybe<string> | undefined;\n  /**\n   * The height in pixels of the media. This is used to generate the og:<type of media>:height meta tag.\n   */\n  height: Maybe<number> | undefined;\n  /**\n   * The width in pixels of the media. This is used to generate the og:<type of media>:width meta tag.\n   */\n  width: Maybe<number> | undefined;\n  /**\n   * The alt text for the media. This is used to generate the og:<type of media>:alt meta tag.\n   */\n  altText: Maybe<string> | undefined;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "altText",
                "value": "Maybe<string> | undefined",
                "description": "The alt text for the media. This is used to generate the og:<type of media>:alt meta tag."
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "height",
                "value": "Maybe<number> | undefined",
                "description": "The height in pixels of the media. This is used to generate the og:<type of media>:height meta tag."
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "type",
                "value": "'image' | 'video' | 'audio'",
                "description": "Used to generate og:<type of media> meta tag"
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "Maybe<string> | undefined",
                "description": "The url value populates both url and secure_url and is used to infer the og:<type of media>:type meta tag."
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "width",
                "value": "Maybe<number> | undefined",
                "description": "The width in pixels of the media. This is used to generate the og:<type of media>:width meta tag."
              }
            ]
          },
          "RobotsOptions": {
            "filePath": "src/seo/generate-seo-tags.ts",
            "name": "RobotsOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxImagePreview",
                "value": "'none' | 'standard' | 'large'",
                "description": "Set the maximum size of an image preview for this page in a search results Can be one of the following:\n\n- `none` - No image preview is to be shown.\n- `standard` - A default image preview may be shown.\n- `large` - A larger image preview, up to the width of the viewport, may be shown.\n\nIf no value is specified a default image preview size is used.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxSnippet",
                "value": "number",
                "description": "A number representing the maximum of amount characters to use as a textual snippet for a search result. This value can also be set to one of the following special values:\n\n- 0 - No snippet is to be shown. Equivalent to nosnippet.\n- 1 - The Search engine will choose the snippet length that it believes is most effective to help users discover   your content and direct users to your site\n- -1 - No limit on the number of characters that can be shown in the snippet.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxVideoPreview",
                "value": "number",
                "description": "The maximum number of seconds for videos on this page to show in search results. This value can also be set to one of the following special values:\n\n- 0 - A static image may be used with the `maxImagePreview` setting.\n- 1 - There is no limit to the size of the video preview.\n\nThis applies to all forms of search results (at Google: web search, Google Images, Google Videos, Discover, Assistant).",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noArchive",
                "value": "boolean",
                "description": "Do not show a cached link in search results.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noFollow",
                "value": "boolean",
                "description": "Do not follow the links on this page.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noImageIndex",
                "value": "boolean",
                "description": "Do not index images on this page.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noIndex",
                "value": "boolean",
                "description": "Do not show this page, media, or resource in search results.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noSnippet",
                "value": "boolean",
                "description": "Do not show a text snippet or video preview in the search results for this page.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "noTranslate",
                "value": "boolean",
                "description": "Do not offer translation of this page in search results.",
                "isOptional": true
              },
              {
                "filePath": "src/seo/generate-seo-tags.ts",
                "syntaxKind": "PropertySignature",
                "name": "unavailableAfter",
                "value": "string",
                "description": "Do not show this page in search results after the specified date/time.",
                "isOptional": true
              }
            ],
            "value": "export interface RobotsOptions {\n  /**\n   * Set the maximum size of an image preview for this page in a search results Can be one of the following:\n   *\n   * - `none` - No image preview is to be shown.\n   * - `standard` - A default image preview may be shown.\n   * - `large` - A larger image preview, up to the width of the viewport, may be shown.\n   *\n   * If no value is specified a default image preview size is used.\n   */\n  maxImagePreview?: 'none' | 'standard' | 'large';\n  /**\n   * A number representing the maximum of amount characters to use as a textual snippet for a search result. This value\n   * can also be set to one of the following special values:\n   *\n   * - 0 - No snippet is to be shown. Equivalent to nosnippet.\n   * - 1 - The Search engine will choose the snippet length that it believes is most effective to help users discover\n   *   your content and direct users to your site\n   * - -1 - No limit on the number of characters that can be shown in the snippet.\n   */\n  maxSnippet?: number;\n  /**\n   * The maximum number of seconds for videos on this page to show in search results. This value can also be set to one\n   * of the following special values:\n   *\n   * - 0 - A static image may be used with the `maxImagePreview` setting.\n   * - 1 - There is no limit to the size of the video preview.\n   *\n   * This applies to all forms of search results (at Google: web search, Google Images, Google Videos, Discover,\n   * Assistant).\n   */\n  maxVideoPreview?: number;\n  /**\n   * Do not show a cached link in search results.\n   */\n  noArchive?: boolean;\n  /**\n   * Do not follow the links on this page.\n   *\n   * @see https://developers.google.com/search/docs/advanced/guidelines/qualify-outbound-links\n   */\n  noFollow?: boolean;\n  /**\n   * Do not index images on this page.\n   */\n  noImageIndex?: boolean;\n  /**\n   * Do not show this page, media, or resource in search results.\n   */\n  noIndex?: boolean;\n  /**\n   * Do not show a text snippet or video preview in the search results for this page.\n   */\n  noSnippet?: boolean;\n  /**\n   * Do not offer translation of this page in search results.\n   */\n  noTranslate?: boolean;\n  /**\n   * Do not show this page in search results after the specified date/time.\n   */\n  unavailableAfter?: string;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "Seo",
    "category": "components",
    "isVisualComponent": false,
    "related": [],
    "description": "The `<Seo />` component renders SEO meta tags in the document `head`. Add the `<Seo />` to your `root.jsx` before the `<Meta />` and `<Link />` components. SEO metadata is set on a per-route basis using Remix [loader functions](https://remix.run/docs/en/v1/guides/data-loading). Learn more about [how SEO works in Hydrogen](https://shopify.dev/docs/custom-storefronts/hydrogen/seo).\n  \n  **Note: the Seo component is deprecated** - Use [getSeoMeta](/docs/api/hydrogen/utilities/getseometa) to migrate.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Seo} from '@shopify/hydrogen';\nimport {\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\n\nexport default function App() {\n  /** ... */\n  return (\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        {/* Add &lt;Seo /&gt; before &lt;Meta /&gt; and &lt;Link /&gt; */}\n        &lt;Seo /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        &lt;ScrollRestoration /&gt;\n        &lt;Scripts /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import {Seo} from '@shopify/hydrogen';\nimport {\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\n\nexport default function App() {\n  /** ... */\n  return (\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;meta charSet=\"utf-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /&gt;\n        {/* Add &lt;Seo /&gt; before &lt;Meta /&gt; and &lt;Link /&gt; */}\n        &lt;Seo /&gt;\n        &lt;Meta /&gt;\n        &lt;Links /&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;Outlet /&gt;\n        &lt;ScrollRestoration /&gt;\n        &lt;Scripts /&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "SeoProps",
        "typeDefinitions": {
          "SeoProps": {
            "filePath": "src/seo/seo.ts",
            "name": "SeoProps",
            "description": "",
            "members": [
              {
                "filePath": "src/seo/seo.ts",
                "syntaxKind": "PropertySignature",
                "name": "debug",
                "value": "boolean",
                "description": "Enable debug mode that prints SEO properties for route in the console",
                "isOptional": true
              }
            ],
            "value": "interface SeoProps {\n  /** Enable debug mode that prints SEO properties for route in the console */\n  debug?: boolean;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "getSitemap",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "getSitemapIndex",
        "type": "utilities",
        "url": "/api/hydrogen/utilities/getSitemapIndex"
      }
    ],
    "description": "> Caution:\n> This component is in an unstable pre-release state and may have breaking changes in a future release.\n\nGenerate a sitemap for a specific resource type. Returns a standard Response object.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {unstable__getSitemap as getSitemap} from '@shopify/hydrogen';\n\nexport async function loader({request, params, context: {storefront}}) {\n  const response = await getSitemap({\n    storefront,\n    request,\n    params,\n    // The locales to include in the sitemap\n    locales: ['EN-US', 'EN-CA', 'FR-CA'],\n    // A function to generate a link for a given resource\n    getLink: ({type, baseUrl, handle, locale}) =&gt; {\n      if (!locale) return `${baseUrl}/${type}/${handle}`;\n      return `${baseUrl}/${locale}/${type}/${handle}`;\n    },\n  });\n\n  // Set any custom headers on the sitemap response\n  response.headers.set('Cache-Control', `max-age=${60 * 60 * 24}`);\n\n  return response;\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import type {LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {unstable__getSitemap as getSitemap} from '@shopify/hydrogen';\n\nexport async function loader({\n  request,\n  params,\n  context: {storefront},\n}: LoaderFunctionArgs) {\n  const response = await getSitemap({\n    storefront,\n    request,\n    params,\n    // The locales to include in the sitemap\n    locales: ['EN-US', 'EN-CA', 'FR-CA'],\n    // A function to generate a link for a given resource\n    getLink: ({type, baseUrl, handle, locale}) =&gt; {\n      if (!locale) return `${baseUrl}/${type}/${handle}`;\n      return `${baseUrl}/${locale}/${type}/${handle}`;\n    },\n  });\n\n  // Set any custom headers on the sitemap response\n  response.headers.set('Cache-Control', `max-age=${60 * 60 * 24}`);\n\n  return response;\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "getSitemap",
        "description": "",
        "type": "GetSitemapGeneratedType",
        "typeDefinitions": {
          "GetSitemapGeneratedType": {
            "filePath": "src/sitemap/sitemap.ts",
            "name": "GetSitemapGeneratedType",
            "description": "Generate a sitemap for a specific resource type.",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "GetSiteMapOptions",
                "filePath": "src/sitemap/sitemap.ts"
              }
            ],
            "returns": {
              "filePath": "src/sitemap/sitemap.ts",
              "description": "",
              "name": "Promise<Response>",
              "value": "Promise<Response>"
            },
            "value": "export async function getSitemap(\n  options: GetSiteMapOptions,\n): Promise<Response> {\n  const {\n    storefront,\n    request,\n    params,\n    getLink,\n    locales = [],\n    getChangeFreq,\n    noItemsFallback = '/',\n  } = options;\n\n  if (!params)\n    throw new Error(\n      '[h2:sitemap:error] Remix params object is required to generate a sitemap',\n    );\n\n  if (!request || !request.url)\n    throw new Error('A request object is required to generate a sitemap');\n\n  if (!storefront || !storefront.query)\n    throw new Error('A storefront client is required to generate a index');\n\n  if (!getLink)\n    throw new Error(\n      'A `getLink` function to generate each resource is required to build a sitemap',\n    );\n\n  if (!params.type || !params.page)\n    throw new Response('No data found', {status: 404});\n\n  const type = params.type as keyof typeof QUERIES;\n\n  const query = QUERIES[type];\n\n  if (!query) throw new Response('Not found', {status: 404});\n\n  const data = await storefront.query(query, {\n    variables: {\n      page: parseInt(params.page, 10),\n    },\n    storefrontApiVersion: 'unstable',\n  });\n\n  const baseUrl = new URL(request.url).origin;\n  let body: string = '';\n\n  if (!data?.sitemap?.resources?.items?.length) {\n    body =\n      SITEMAP_PREFIX +\n      `\\n  <url><loc>${baseUrl + noItemsFallback}</loc></url>\\n` +\n      SITEMAP_SUFFIX;\n  } else {\n    body =\n      SITEMAP_PREFIX +\n      data.sitemap.resources.items\n        .map((item: {handle: string; updatedAt: string; type?: string}) => {\n          return renderUrlTag({\n            getChangeFreq,\n            url: getLink({\n              type: item.type ?? type,\n              baseUrl,\n              handle: item.handle,\n            }),\n            type,\n            getLink,\n            updatedAt: item.updatedAt,\n            handle: item.handle,\n            metaobjectType: item.type,\n            locales,\n            baseUrl,\n          });\n        })\n        .join('\\n') +\n      SITEMAP_SUFFIX;\n  }\n\n  return new Response(body, {\n    headers: {\n      'Content-Type': 'application/xml',\n      'Cache-Control': `max-age=${60 * 60 * 24}`,\n    },\n  });\n}"
          },
          "GetSiteMapOptions": {
            "filePath": "src/sitemap/sitemap.ts",
            "name": "GetSiteMapOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "getChangeFreq",
                "value": "(options: { type: string; handle: string; }) => string",
                "description": "Optionally customize the changefreq property for each URL",
                "isOptional": true
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "getLink",
                "value": "(options: { type: string; baseUrl: string; handle?: string; locale?: string; }) => string",
                "description": "A function that produces a canonical url for a resource. It is called multiple times for each locale supported by the app."
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "locales",
                "value": "string[]",
                "description": "An array of locales to generate alternate tags",
                "isOptional": true
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "noItemsFallback",
                "value": "string",
                "description": "If the sitemap has no links, fallback to rendering a link to the homepage. This prevents errors in Google's search console. Defaults to `/`.",
                "isOptional": true
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "params",
                "value": "Params<string>",
                "description": "The params object from Remix"
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "Request",
                "description": "A Remix Request object"
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The Storefront API Client from Hydrogen"
              }
            ],
            "value": "interface GetSiteMapOptions {\n  /** The params object from Remix */\n  params: LoaderFunctionArgs['params'];\n  /** The Storefront API Client from Hydrogen */\n  storefront: Storefront;\n  /** A Remix Request object */\n  request: Request;\n  /** A function that produces a canonical url for a resource. It is called multiple times for each locale supported by the app. */\n  getLink: (options: {\n    type: string | SITEMAP_INDEX_TYPE;\n    baseUrl: string;\n    handle?: string;\n    locale?: string;\n  }) => string;\n  /** An array of locales to generate alternate tags */\n  locales?: string[];\n  /** Optionally customize the changefreq property for each URL */\n  getChangeFreq?: (options: {\n    type: string | SITEMAP_INDEX_TYPE;\n    handle: string;\n  }) => string;\n  /** If the sitemap has no links, fallback to rendering a link to the homepage. This prevents errors in Google's search console. Defaults to `/`.  */\n  noItemsFallback?: string;\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getSitemapIndex",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "getSitemap",
        "type": "utilities",
        "url": "/api/hydrogen/utilities/getSitemap"
      }
    ],
    "description": "> Caution:\n> This component is in an unstable pre-release state and may have breaking changes in a future release.\n\nGenerate a sitemap index that links to separate child sitemaps for different resource types. Returns a standard Response object.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {unstable__getSitemapIndex as getSitemapIndex} from '@shopify/hydrogen';\n\nexport async function loader({request, context: {storefront}}) {\n  const response = await getSitemapIndex({\n    storefront,\n    request,\n    types: [\n      'products',\n      'pages',\n      'collections',\n      'metaObjects',\n      'articles',\n      'blogs',\n    ],\n  });\n\n  // Set any custom headers on the sitemap response\n  response.headers.set('Cache-Control', `max-age=${60 * 60 * 24}`);\n\n  return response;\n}\n",
            "language": "js"
          },
          {
            "title": "TypeScript",
            "code": "import type {LoaderFunctionArgs} from '@shopify/remix-oxygen';\nimport {unstable__getSitemapIndex as getSitemapIndex} from '@shopify/hydrogen';\n\nexport async function loader({\n  request,\n  context: {storefront},\n}: LoaderFunctionArgs) {\n  const response = await getSitemapIndex({\n    storefront,\n    request,\n    types: [\n      'products',\n      'pages',\n      'collections',\n      'metaObjects',\n      'articles',\n      'blogs',\n    ],\n  });\n\n  // Set any custom headers on the sitemap response\n  response.headers.set('Cache-Control', `max-age=${60 * 60 * 24}`);\n\n  return response;\n}\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "getSitemapIndex",
        "description": "",
        "type": "GetSitemapIndexGeneratedType",
        "typeDefinitions": {
          "GetSitemapIndexGeneratedType": {
            "filePath": "src/sitemap/sitemap.ts",
            "name": "GetSitemapIndexGeneratedType",
            "description": "Generate a sitemap index that links to separate sitemaps for each resource type. Returns a standard Response object.",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "SitemapIndexOptions",
                "filePath": "src/sitemap/sitemap.ts"
              }
            ],
            "returns": {
              "filePath": "src/sitemap/sitemap.ts",
              "description": "",
              "name": "Promise<Response>",
              "value": "Promise<Response>"
            },
            "value": "export async function getSitemapIndex(\n  options: SitemapIndexOptions,\n): Promise<Response> {\n  const {\n    storefront,\n    request,\n    types = [\n      'products',\n      'pages',\n      'collections',\n      'metaObjects',\n      'articles',\n      'blogs',\n    ],\n    customChildSitemaps = [],\n  } = options;\n\n  if (!request || !request.url)\n    throw new Error('A request object is required to generate a sitemap index');\n\n  if (!storefront || !storefront.query)\n    throw new Error(\n      'A storefront client is required to generate a sitemap index',\n    );\n\n  const data = await storefront.query(SITEMAP_INDEX_QUERY, {\n    storefrontApiVersion: 'unstable',\n  });\n\n  if (!data) {\n    throw new Response('No data found', {status: 404});\n  }\n\n  const baseUrl = new URL(request.url).origin;\n\n  const body =\n    SITEMAP_INDEX_PREFIX +\n    types\n      .map((type) => {\n        if (!data[type]) {\n          throw new Error(\n            `[h2:sitemap:error] No data found for type ${type}. Check types passed to \\`getSitemapIndex\\``,\n          );\n        }\n        return getSiteMapLinks(type, data[type].pagesCount.count, baseUrl);\n      })\n      .join('\\n') +\n    customChildSitemaps\n      .map(\n        (url) =>\n          '  <sitemap><loc>' +\n          (baseUrl + (url.startsWith('/') ? url : '/' + url)) +\n          '</loc></sitemap>',\n      )\n      .join('\\n') +\n    SITEMAP_INDEX_SUFFIX;\n\n  return new Response(body, {\n    headers: {\n      'Content-Type': 'application/xml',\n      'Cache-Control': `max-age=${60 * 60 * 24}`,\n    },\n  });\n}"
          },
          "SitemapIndexOptions": {
            "filePath": "src/sitemap/sitemap.ts",
            "name": "SitemapIndexOptions",
            "description": "",
            "members": [
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "customChildSitemaps",
                "value": "string[]",
                "description": "Add a URL to a custom child sitemap",
                "isOptional": true
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "request",
                "value": "Request",
                "description": "A Remix Request object"
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefront",
                "value": "Storefront",
                "description": "The Storefront API Client from Hydrogen"
              },
              {
                "filePath": "src/sitemap/sitemap.ts",
                "syntaxKind": "PropertySignature",
                "name": "types",
                "value": "SITEMAP_INDEX_TYPE[]",
                "description": "The types of pages to include in the sitemap index.",
                "isOptional": true
              }
            ],
            "value": "interface SitemapIndexOptions {\n  /** The Storefront API Client from Hydrogen */\n  storefront: Storefront;\n  /** A Remix Request object */\n  request: Request;\n  /** The types of pages to include in the sitemap index. */\n  types?: SITEMAP_INDEX_TYPE[];\n  /** Add a URL to a custom child sitemap */\n  customChildSitemaps?: string[];\n}"
          },
          "Storefront": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Storefront",
            "value": "{\n  query: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    query: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontQueries,\n      RawGqlString,\n      StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, 'cache'>,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  mutate: <\n    OverrideReturnType extends any = never,\n    RawGqlString extends string = string,\n  >(\n    mutation: RawGqlString,\n    ...options: ClientVariablesInRestParams<\n      StorefrontMutations,\n      RawGqlString,\n      StorefrontCommonExtraParams,\n      AutoAddedVariableNames\n    >\n  ) => Promise<\n    ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> &\n      StorefrontError\n  >;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  i18n: TI18n;\n}",
            "description": "Interface to interact with the Storefront API.",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "cache",
                "value": "Cache",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheCustom",
                "value": "(overrideOptions: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheLong",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheNone",
                "value": "() => NoStoreStrategy",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "CacheShort",
                "value": "(overrideOptions?: AllCacheOptions) => AllCacheOptions",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "generateCacheControlHeader",
                "value": "(cacheOptions: AllCacheOptions) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getApiUrl",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storefrontApiVersion\" | \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPrivateTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"privateStorefrontToken\"> & { buyerIp?: string; }) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getPublicTokenHeaders",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"contentType\">> & Pick<StorefrontClientProps, \"publicStorefrontToken\">) => Record<string, string>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "getShopifyDomain",
                "value": "(props?: Partial<Pick<StorefrontClientProps, \"storeDomain\">>) => string",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "i18n",
                "value": "TI18n",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "mutate",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(mutation: RawGqlString, ...options: IsOptionalVariables<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & ClientVariables<StorefrontMutations, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontMutations[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontMutations[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontMutations[RawGqlString][\"variables\"], Extract<keyof StorefrontMutations[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontMutations, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "query",
                "value": "<OverrideReturnType extends unknown = never, RawGqlString extends string = string>(query: RawGqlString, ...options: IsOptionalVariables<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames, Omit<StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>> extends true ? [(StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>)?] : [StorefrontCommonExtraParams & Pick<StorefrontQueryOptions, \"cache\"> & ClientVariables<StorefrontQueries, RawGqlString, AutoAddedVariableNames, \"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }, Record<\"variables\", RawGqlString extends never ? { [KeyType in keyof ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)]: ({ [KeyType in keyof StorefrontQueries[RawGqlString][\"variables\"] as Filter<KeyType, Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>]: StorefrontQueries[RawGqlString][\"variables\"][KeyType]; } & Partial<Pick<StorefrontQueries[RawGqlString][\"variables\"], Extract<keyof StorefrontQueries[RawGqlString][\"variables\"], AutoAddedVariableNames>>>)[KeyType]; } : { readonly [variable: string]: unknown; }>>]) => Promise<ClientReturn<StorefrontQueries, RawGqlString, OverrideReturnType> & StorefrontError>",
                "description": ""
              }
            ]
          },
          "AllCacheOptions": {
            "filePath": "src/cache/strategies.ts",
            "name": "AllCacheOptions",
            "description": "Override options for a cache strategy.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ],
            "value": "export interface AllCacheOptions {\n  /**\n   * The caching mode, generally `public`, `private`, or `no-store`.\n   */\n  mode?: string;\n  /**\n   * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).\n   */\n  maxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).\n   */\n  sMaxAge?: number;\n  /**\n   * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).\n   */\n  staleIfError?: number;\n}"
          },
          "NoStoreStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "NoStoreStrategy",
            "value": "{\n  mode: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": ""
              }
            ]
          },
          "StorefrontMutations": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontMutations",
            "description": "Maps all the mutations found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontMutations {\n  // Example of how a generated mutation type looks like:\n  // '#graphql mutation m1 {...}': {return: M1Mutation; variables: M1MutationVariables};\n}"
          },
          "AutoAddedVariableNames": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "AutoAddedVariableNames",
            "value": "'country' | 'language'",
            "description": ""
          },
          "StorefrontCommonExtraParams": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontCommonExtraParams",
            "value": "{\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n  displayName?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "displayName",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "headers",
                "value": "HeadersInit",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontApiVersion",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontError",
            "value": "{\n  errors?: StorefrontApiErrors;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/storefront.ts",
                "syntaxKind": "PropertySignature",
                "name": "errors",
                "value": "StorefrontApiErrors",
                "description": "",
                "isOptional": true
              }
            ]
          },
          "StorefrontApiErrors": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontApiErrors",
            "value": "JsonGraphQLError[] | undefined",
            "description": ""
          },
          "JsonGraphQLError": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "JsonGraphQLError",
            "value": "ReturnType<GraphQLError['toJSON']>",
            "description": "",
            "members": []
          },
          "StorefrontQueries": {
            "filePath": "src/storefront.ts",
            "name": "StorefrontQueries",
            "description": "Maps all the queries found in the project to variables and return types.",
            "members": [],
            "value": "export interface StorefrontQueries {\n  // Example of how a generated query type looks like:\n  // '#graphql query q1 {...}': {return: Q1Query; variables: Q1QueryVariables};\n}"
          },
          "StorefrontQueryOptions": {
            "filePath": "src/storefront.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "StorefrontQueryOptions",
            "value": "StorefrontCommonExtraParams & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n}",
            "description": ""
          },
          "CachingStrategy": {
            "filePath": "src/cache/strategies.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CachingStrategy",
            "value": "AllCacheOptions",
            "description": "Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.",
            "members": [
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "maxAge",
                "value": "number",
                "description": "The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "mode",
                "value": "string",
                "description": "The caching mode, generally `public`, `private`, or `no-store`.",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "sMaxAge",
                "value": "number",
                "description": "Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleIfError",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).",
                "isOptional": true
              },
              {
                "filePath": "src/cache/strategies.ts",
                "syntaxKind": "PropertySignature",
                "name": "staleWhileRevalidate",
                "value": "number",
                "description": "Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Image",
    "category": "components",
    "subCategory": "media",
    "isVisualComponent": false,
    "related": [
      {
        "name": "MediaFile",
        "type": "component",
        "url": "/api/hydrogen/components/mediafile"
      }
    ],
    "description": "The `Image` component renders an image for the Storefront API's\n[Image object](https://shopify.dev/api/storefront/reference/common-objects/image) by using the `data` prop. You can [customize this component](https://shopify.dev/api/hydrogen/components#customizing-hydrogen-components) using passthrough props.\n\nImages default to being responsive automatically (`width: 100%, height: auto`), and expect an `aspectRatio` prop, which ensures your image doesn't create any layout shift. For fixed-size images, you can set `width` to an exact value, and a `srcSet` with 1x, 2x, and 3x DPI variants will automatically be generated for you.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Image} from '@shopify/hydrogen';\n\n// An example query\nconst IMAGE_QUERY = `#graphql\n  query {\n    product {\n      featuredImage {\n        altText\n        url\n        height\n        width\n      }\n    }\n  }\n`;\n\nexport default function ProductImage({product}) {\n  if (!product.featuredImage) {\n    return null;\n  }\n\n  return (\n    &lt;Image\n      data={product.featuredImage}\n      sizes=\"(min-width: 45em) 50vw, 100vw\"\n      aspectRatio=\"4/5\"\n    /&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import React from 'react';\nimport {Image} from '@shopify/hydrogen';\nimport type {Product} from '@shopify/hydrogen/storefront-api-types';\n\n// An example query\nconst IMAGE_QUERY = `#graphql\n  query {\n    product {\n      featuredImage {\n        altText\n        url\n        height\n        width\n      }\n    }\n  }\n`;\n\nexport default function ProductImage({product}: {product: Product}) {\n  if (!product.featuredImage) {\n    return null;\n  }\n\n  return (\n    &lt;Image\n      data={product.featuredImage}\n      sizes=\"(min-width: 45em) 50vw, 100vw\"\n      aspectRatio=\"4/5\"\n    /&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "HydrogenImageBaseProps",
        "typeDefinitions": {
          "HydrogenImageBaseProps": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenImageBaseProps",
            "value": "{\n  /** The aspect ratio of the image, in the format of `width/height`.\n   *\n   * @example\n   * ```\n   * <Image data={productImage} aspectRatio=\"4/5\" />\n   * ```\n   */\n  aspectRatio?: string;\n  /** The crop position of the image.\n   *\n   * @remarks\n   * In the event that AspectRatio is set, without specifying a crop,\n   * the Shopify CDN won't return the expected image.\n   *\n   * @defaultValue `center`\n   */\n  crop?: Crop;\n  /** Data mapping to the [Storefront API `Image`](https://shopify.dev/docs/api/storefront/2024-07/objects/Image) object. Must be an Image object.\n   *\n   * @example\n   * ```\n   * import {IMAGE_FRAGMENT, Image} from '@shopify/hydrogen';\n   *\n   * export const IMAGE_QUERY = `#graphql\n   * ${IMAGE_FRAGMENT}\n   * query {\n   *   product {\n   *     featuredImage {\n   *       ...Image\n   *     }\n   *   }\n   * }`\n   *\n   * <Image\n   *   data={productImage}\n   *   sizes=\"(min-width: 45em) 50vw, 100vw\"\n   *   aspectRatio=\"4/5\"\n   * />\n   * ```\n   *\n   * Image: {@link https://shopify.dev/api/storefront/reference/common-objects/image}\n   */\n  data?: PartialDeep<ImageType, {recurseIntoArrays: true}>;\n  /** A function that returns a URL string for an image.\n   *\n   * @remarks\n   * By default, this uses Shopifys CDN {@link https://cdn.shopify.com/} but you can provide\n   * your own function to use a another provider, as long as they support URL based image transformations.\n   */\n  loader?: Loader;\n  /** An optional prop you can use to change the default srcSet generation behaviour */\n  srcSetOptions?: SrcSetOptions;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aspectRatio",
                "value": "string",
                "description": "The aspect ratio of the image, in the format of `width/height`.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "<Image data={productImage} aspectRatio=\"4/5\" />",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crop",
                "value": "Crop",
                "description": "The crop position of the image.",
                "isOptional": true,
                "defaultValue": "`center`"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<ImageType, {recurseIntoArrays: true}>",
                "description": "Data mapping to the [Storefront API `Image`](https://shopify.dev/docs/api/storefront/2024-07/objects/Image) object. Must be an Image object.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import {IMAGE_FRAGMENT, Image} from '@shopify/hydrogen';\n\nexport const IMAGE_QUERY = `#graphql\n${IMAGE_FRAGMENT}\nquery {\n  product {\n    featuredImage {\n      ...Image\n    }\n  }\n}`\n\n<Image\n  data={productImage}\n  sizes=\"(min-width: 45em) 50vw, 100vw\"\n  aspectRatio=\"4/5\"\n/>",
                        "title": "Example"
                      },
                      {
                        "code": "Image:",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "loader",
                "value": "Loader",
                "description": "A function that returns a URL string for an image.",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "srcSetOptions",
                "value": "SrcSetOptions",
                "description": "An optional prop you can use to change the default srcSet generation behaviour",
                "isOptional": true
              }
            ]
          },
          "Crop": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Crop",
            "value": "'center' | 'top' | 'bottom' | 'left' | 'right'",
            "description": ""
          },
          "Loader": {
            "filePath": "src/Image.tsx",
            "name": "Loader",
            "description": "",
            "params": [
              {
                "name": "params",
                "description": "",
                "value": "LoaderParams",
                "filePath": "src/Image.tsx"
              }
            ],
            "returns": {
              "filePath": "src/Image.tsx",
              "description": "",
              "name": "string",
              "value": "string"
            },
            "value": "export type Loader = (params: LoaderParams) => string;"
          },
          "LoaderParams": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoaderParams",
            "value": "{\n  /** The base URL of the image */\n  src?: ImageType['url'];\n  /** The URL param that controls width */\n  width?: number;\n  /** The URL param that controls height */\n  height?: number;\n  /** The URL param that controls the cropping region */\n  crop?: Crop;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crop",
                "value": "Crop",
                "description": "The URL param that controls the cropping region",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "height",
                "value": "number",
                "description": "The URL param that controls height",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "src",
                "value": "string",
                "description": "The base URL of the image",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "width",
                "value": "number",
                "description": "The URL param that controls width",
                "isOptional": true
              }
            ]
          },
          "SrcSetOptions": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SrcSetOptions",
            "value": "{\n  /** The number of sizes to generate */\n  intervals: number;\n  /** The smallest image size */\n  startingWidth: number;\n  /** The increment by which to increase for each size, in pixels */\n  incrementSize: number;\n  /** The size used for placeholder fallback images */\n  placeholderWidth: number;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "incrementSize",
                "value": "number",
                "description": "The increment by which to increase for each size, in pixels"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "intervals",
                "value": "number",
                "description": "The number of sizes to generate"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "placeholderWidth",
                "value": "number",
                "description": "The size used for placeholder fallback images"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "startingWidth",
                "value": "number",
                "description": "The smallest image size"
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "ExternalVideo",
    "category": "components",
    "subCategory": "media",
    "isVisualComponent": false,
    "related": [
      {
        "name": "MediaFile",
        "type": "component",
        "url": "/api/hydrogen/components/mediafile"
      }
    ],
    "description": "The `ExternalVideo` component renders an embedded video for the Storefront API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo).",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {ExternalVideo} from '@shopify/hydrogen';\n\nexport default function MyProductVideo({products}) {\n  const firstMediaElement = products.nodes[0].media.nodes[0];\n\n  if (firstMediaElement.__typename === 'ExternalVideo') {\n    return &lt;ExternalVideo data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {ExternalVideo} from '@shopify/hydrogen';\nimport type {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport default function MyProductVideo({\n  products,\n}: {\n  products: ProductConnection;\n}) {\n  const firstMediaElement = products.nodes[0].media.nodes[0];\n  if (firstMediaElement.__typename === 'ExternalVideo') {\n    return &lt;ExternalVideo data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "tsx"
          }
        ],
        "title": "ExternalVideo example"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "Takes in the same props as a native `<iframe>` element, except for `src`.",
        "type": "ExternalVideoBaseProps",
        "typeDefinitions": {
          "ExternalVideoBaseProps": {
            "filePath": "src/ExternalVideo.tsx",
            "name": "ExternalVideoBaseProps",
            "description": "",
            "members": [
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<ExternalVideoType, {recurseIntoArrays: true}>",
                "description": "An object with fields that correspond to the Storefront API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo)."
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "options",
                "value": "YouTube | Vimeo",
                "description": "An object containing the options available for either [YouTube](https://developers.google.com/youtube/player_parameters#Parameters) or [Vimeo](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters).",
                "isOptional": true
              }
            ],
            "value": "export interface ExternalVideoBaseProps {\n  /**\n   * An object with fields that correspond to the Storefront API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo).\n   */\n  data: PartialDeep<ExternalVideoType, {recurseIntoArrays: true}>;\n  /** An object containing the options available for either\n   * [YouTube](https://developers.google.com/youtube/player_parameters#Parameters) or\n   * [Vimeo](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters).\n   */\n  options?: YouTube | Vimeo;\n}"
          },
          "YouTube": {
            "filePath": "src/ExternalVideo.tsx",
            "name": "YouTube",
            "description": "",
            "members": [
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoplay",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cc_lang_pref",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "cc_load_policy",
                "value": "1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "color",
                "value": "'red' | 'white'",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "controls",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "disablekb",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "enablejsapi",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "end",
                "value": "number",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "fs",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hl",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "iv_load_policy",
                "value": "1 | 3",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "list",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "list_type",
                "value": "'playlist' | 'user_uploads'",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "loop",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "modest_branding",
                "value": "1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "origin",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "playlist",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "plays_inline",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "rel",
                "value": "0 | 1",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "start",
                "value": "number",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "widget_referrer",
                "value": "string",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "interface YouTube {\n  autoplay?: 0 | 1;\n  cc_lang_pref?: string;\n  cc_load_policy?: 1;\n  color?: 'red' | 'white';\n  controls?: 0 | 1;\n  disablekb?: 0 | 1;\n  enablejsapi?: 0 | 1;\n  end?: number;\n  fs?: 0 | 1;\n  hl?: string;\n  iv_load_policy?: 1 | 3;\n  list?: string;\n  list_type?: 'playlist' | 'user_uploads';\n  loop?: 0 | 1;\n  modest_branding?: 1;\n  origin?: string;\n  playlist?: string;\n  plays_inline?: 0 | 1;\n  rel?: 0 | 1;\n  start?: number;\n  widget_referrer?: string;\n}"
          },
          "Vimeo": {
            "filePath": "src/ExternalVideo.tsx",
            "name": "Vimeo",
            "description": "",
            "members": [
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "#t",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autopause",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoplay",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "background",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "byline",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "color",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "controls",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "dnt",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "loop",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "muted",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "pip",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "playsinline",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "portrait",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "quality",
                "value": "'240p' | '360p' | '540p' | '720p' | '1080p' | '2k' | '4k'",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "speed",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "texttrack",
                "value": "string",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/ExternalVideo.tsx",
                "syntaxKind": "PropertySignature",
                "name": "transparent",
                "value": "VimeoBoolean",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "interface Vimeo {\n  autopause?: VimeoBoolean;\n  autoplay?: VimeoBoolean;\n  background?: VimeoBoolean;\n  byline?: VimeoBoolean;\n  color?: string;\n  controls?: VimeoBoolean;\n  dnt?: VimeoBoolean;\n  loop?: VimeoBoolean;\n  muted?: VimeoBoolean;\n  pip?: VimeoBoolean;\n  playsinline?: VimeoBoolean;\n  portrait?: VimeoBoolean;\n  quality?: '240p' | '360p' | '540p' | '720p' | '1080p' | '2k' | '4k';\n  speed?: VimeoBoolean;\n  '#t'?: string;\n  texttrack?: string;\n  title?: VimeoBoolean;\n  transparent?: VimeoBoolean;\n}"
          },
          "VimeoBoolean": {
            "filePath": "src/ExternalVideo.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "VimeoBoolean",
            "value": "0 | 1 | boolean",
            "description": ""
          }
        }
      }
    ]
  },
  {
    "name": "MediaFile",
    "category": "components",
    "subCategory": "media",
    "isVisualComponent": false,
    "related": [
      {
        "name": "Image",
        "type": "component",
        "url": "/api/hydrogen/components/image"
      },
      {
        "name": "Video",
        "type": "component",
        "url": "/api/hydrogen/components/video"
      },
      {
        "name": "ExternalVideo",
        "type": "component",
        "url": "/api/hydrogen/components/externalvideo"
      },
      {
        "name": "ModelViewer",
        "type": "component",
        "url": "/api/hydrogen/components/modelviewer"
      }
    ],
    "description": "The `MediaFile` component renders the media for the Storefront API's\n[Media object](https://shopify.dev/api/storefront/reference/products/media). It renders an `Image`, `Video`, an `ExternalVideo`, or a `ModelViewer` depending on the `__typename` of the `data` prop.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {MediaFile} from '@shopify/hydrogen';\n\nexport function ProductsMediaFiles({products}) {\n  return (\n    &lt;ul&gt;\n      {products.nodes.map((product) =&gt; {\n        return &lt;MediaFile data={product.media.nodes[0]} key={product.id} /&gt;;\n      })}\n    &lt;/ul&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {MediaFile} from '@shopify/hydrogen';\nimport type {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport function ProductsMediaFiles({products}: {products: ProductConnection}) {\n  return (\n    &lt;ul&gt;\n      {products.nodes.map((product) =&gt; {\n        return &lt;MediaFile data={product.media.nodes[0]} key={product.id} /&gt;;\n      })}\n    &lt;/ul&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "MediaFile renders an `Image`, `Video`, `ExternalVideo`, or `ModelViewer` component. Use the `mediaOptions` prop to customize the props sent to each of these components.",
        "type": "MediaFileProps",
        "typeDefinitions": {
          "MediaFileProps": {
            "filePath": "src/MediaFile.tsx",
            "name": "MediaFileProps",
            "description": "",
            "members": [
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "about",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "accessKey",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-activedescendant",
                "value": "string | undefined",
                "description": "Identifies the currently active element when DOM focus is on a composite widget, textbox, group, or application.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-atomic",
                "value": "Booleanish | undefined",
                "description": "Indicates whether assistive technologies will present all, or only parts of, the changed region based on the change notifications defined by the aria-relevant attribute.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-autocomplete",
                "value": "'none' | 'inline' | 'list' | 'both' | undefined",
                "description": "Indicates whether inputting text could trigger display of one or more predictions of the user's intended value for an input and specifies how predictions would be presented if they are made.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-braillelabel",
                "value": "string | undefined",
                "description": "Defines a string value that labels the current element, which is intended to be converted into Braille.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-brailleroledescription",
                "value": "string | undefined",
                "description": "Defines a human-readable, author-localized abbreviated description for the role of an element, which is intended to be converted into Braille.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-busy",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-checked",
                "value": "boolean | 'false' | 'mixed' | 'true' | undefined",
                "description": "Indicates the current \"checked\" state of checkboxes, radio buttons, and other widgets.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colcount",
                "value": "number | undefined",
                "description": "Defines the total number of columns in a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colindex",
                "value": "number | undefined",
                "description": "Defines an element's column index or position with respect to the total number of columns within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colindextext",
                "value": "string | undefined",
                "description": "Defines a human readable text alternative of aria-colindex.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-colspan",
                "value": "number | undefined",
                "description": "Defines the number of columns spanned by a cell or gridcell within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-controls",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) whose contents or presence are controlled by the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-current",
                "value": "boolean | 'false' | 'true' | 'page' | 'step' | 'location' | 'date' | 'time' | undefined",
                "description": "Indicates the element that represents the current item within a container or set of related elements.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-describedby",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) that describes the object.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-description",
                "value": "string | undefined",
                "description": "Defines a string value that describes or annotates the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-details",
                "value": "string | undefined",
                "description": "Identifies the element that provides a detailed, extended description for the object.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-disabled",
                "value": "Booleanish | undefined",
                "description": "Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-dropeffect",
                "value": "'none' | 'copy' | 'execute' | 'link' | 'move' | 'popup' | undefined",
                "description": "Indicates what functions can be performed when a dragged object is released on the drop target.",
                "isOptional": true,
                "deprecationMessage": "in ARIA 1.1"
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-errormessage",
                "value": "string | undefined",
                "description": "Identifies the element that provides an error message for the object.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-expanded",
                "value": "Booleanish | undefined",
                "description": "Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-flowto",
                "value": "string | undefined",
                "description": "Identifies the next element (or elements) in an alternate reading order of content which, at the user's discretion, allows assistive technology to override the general default of reading in document source order.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-grabbed",
                "value": "Booleanish | undefined",
                "description": "Indicates an element's \"grabbed\" state in a drag-and-drop operation.",
                "isOptional": true,
                "deprecationMessage": "in ARIA 1.1"
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-haspopup",
                "value": "boolean | 'false' | 'true' | 'menu' | 'listbox' | 'tree' | 'grid' | 'dialog' | undefined",
                "description": "Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-hidden",
                "value": "Booleanish | undefined",
                "description": "Indicates whether the element is exposed to an accessibility API.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-invalid",
                "value": "boolean | 'false' | 'true' | 'grammar' | 'spelling' | undefined",
                "description": "Indicates the entered value does not conform to the format expected by the application.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-keyshortcuts",
                "value": "string | undefined",
                "description": "Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-label",
                "value": "string | undefined",
                "description": "Defines a string value that labels the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-labelledby",
                "value": "string | undefined",
                "description": "Identifies the element (or elements) that labels the current element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-level",
                "value": "number | undefined",
                "description": "Defines the hierarchical level of an element within a structure.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-live",
                "value": "'off' | 'assertive' | 'polite' | undefined",
                "description": "Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-modal",
                "value": "Booleanish | undefined",
                "description": "Indicates whether an element is modal when displayed.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-multiline",
                "value": "Booleanish | undefined",
                "description": "Indicates whether a text box accepts multiple lines of input or only a single line.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-multiselectable",
                "value": "Booleanish | undefined",
                "description": "Indicates that the user may select more than one item from the current selectable descendants.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-orientation",
                "value": "'horizontal' | 'vertical' | undefined",
                "description": "Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-owns",
                "value": "string | undefined",
                "description": "Identifies an element (or elements) in order to define a visual, functional, or contextual parent/child relationship between DOM elements where the DOM hierarchy cannot be used to represent the relationship.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-placeholder",
                "value": "string | undefined",
                "description": "Defines a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-posinset",
                "value": "number | undefined",
                "description": "Defines an element's number or position in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-pressed",
                "value": "boolean | 'false' | 'mixed' | 'true' | undefined",
                "description": "Indicates the current \"pressed\" state of toggle buttons.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-readonly",
                "value": "Booleanish | undefined",
                "description": "Indicates that the element is not editable, but is otherwise operable.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-relevant",
                "value": "'additions' | 'additions removals' | 'additions text' | 'all' | 'removals' | 'removals additions' | 'removals text' | 'text' | 'text additions' | 'text removals' | undefined",
                "description": "Indicates what notifications the user agent will trigger when the accessibility tree within a live region is modified.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-required",
                "value": "Booleanish | undefined",
                "description": "Indicates that user input is required on the element before a form may be submitted.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-roledescription",
                "value": "string | undefined",
                "description": "Defines a human-readable, author-localized description for the role of an element.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowcount",
                "value": "number | undefined",
                "description": "Defines the total number of rows in a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowindex",
                "value": "number | undefined",
                "description": "Defines an element's row index or position with respect to the total number of rows within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowindextext",
                "value": "string | undefined",
                "description": "Defines a human readable text alternative of aria-rowindex.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-rowspan",
                "value": "number | undefined",
                "description": "Defines the number of rows spanned by a cell or gridcell within a table, grid, or treegrid.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-selected",
                "value": "Booleanish | undefined",
                "description": "Indicates the current \"selected\" state of various widgets.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-setsize",
                "value": "number | undefined",
                "description": "Defines the number of items in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-sort",
                "value": "'none' | 'ascending' | 'descending' | 'other' | undefined",
                "description": "Indicates if items in a table or grid are sorted in ascending or descending order.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuemax",
                "value": "number | undefined",
                "description": "Defines the maximum allowed value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuemin",
                "value": "number | undefined",
                "description": "Defines the minimum allowed value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuenow",
                "value": "number | undefined",
                "description": "Defines the current value for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aria-valuetext",
                "value": "string | undefined",
                "description": "Defines the human readable text alternative of aria-valuenow for a range widget.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoCapitalize",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoCorrect",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoFocus",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "autoSave",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "children",
                "value": "ReactNode | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "className",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "color",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "content",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "contentEditable",
                "value": "Booleanish | \"inherit\" | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "contextMenu",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "dangerouslySetInnerHTML",
                "value": "{\n            // Should be InnerHTML['innerHTML'].\n            // But unfortunately we're mixing renderer-specific type declarations.\n            __html: string | TrustedHTML;\n        } | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<MediaEdgeType['node'], {recurseIntoArrays: true}>",
                "description": "An object with fields that correspond to the Storefront API's [Media object](https://shopify.dev/api/storefront/reference/products/media)."
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "datatype",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "defaultChecked",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "defaultValue",
                "value": "string | number | ReadonlyArray<string> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "dir",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "draggable",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hidden",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "id",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inlist",
                "value": "any",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "inputMode",
                "value": "'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search' | undefined",
                "description": "Hints at the type of data that might be entered by the user while editing the element or its contents",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "is",
                "value": "string | undefined",
                "description": "Specify that a standard HTML element should behave like a defined custom built-in element",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemID",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemProp",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemRef",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemScope",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "itemType",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "lang",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "mediaOptions",
                "value": "MediaOptions",
                "description": "The options for the `Image`, `Video`, `ExternalVideo`, or `ModelViewer` components.",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "nonce",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAbort",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAbortCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationEnd",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationEndCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationIteration",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationIterationCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationStart",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAnimationStartCapture",
                "value": "AnimationEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAuxClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onAuxClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBeforeInput",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBeforeInputCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBlur",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onBlurCapture",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlay",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayThrough",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCanPlayThroughCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onChange",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onChangeCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionEnd",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionEndCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionStart",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionStartCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionUpdate",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCompositionUpdateCapture",
                "value": "CompositionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onContextMenu",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onContextMenuCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCopy",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCopyCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCut",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCutCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDoubleClick",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDoubleClickCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDrag",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnd",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEndCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnter",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragEnterCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragExit",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragExitCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragLeave",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragLeaveCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragOver",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragOverCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragStart",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDragStartCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDrop",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDropCapture",
                "value": "DragEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDurationChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onDurationChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEmptied",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEmptiedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEncrypted",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEncryptedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEnded",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEndedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onError",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onErrorCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onFocus",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onFocusCapture",
                "value": "FocusEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onGotPointerCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onGotPointerCaptureCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInput",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInputCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInvalid",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onInvalidCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyDown",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyDownCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyPress",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Deprecated"
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyPressCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true,
                "deprecationMessage": "Deprecated"
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyUp",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onKeyUpCapture",
                "value": "KeyboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoad",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedData",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedDataCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedMetadata",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadedMetadataCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadStart",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoadStartCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLostPointerCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLostPointerCaptureCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseDown",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseDownCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseEnter",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseLeave",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseMove",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseMoveCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOut",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOutCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOver",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseOverCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseUp",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onMouseUpCapture",
                "value": "MouseEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPaste",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPasteCapture",
                "value": "ClipboardEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPause",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPauseCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlay",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlayCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlaying",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlayingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerCancel",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerCancelCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerDown",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerDownCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerEnter",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerEnterCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerLeave",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerLeaveCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerMove",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerMoveCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOut",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOutCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOver",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerOverCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerUp",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPointerUpCapture",
                "value": "PointerEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onProgress",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onProgressCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onRateChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onRateChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onReset",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResetCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResize",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onResizeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onScroll",
                "value": "UIEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onScrollCapture",
                "value": "UIEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeeked",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeekedCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeeking",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSeekingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSelect",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSelectCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onStalled",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onStalledCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSubmit",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSubmitCapture",
                "value": "FormEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSuspend",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSuspendCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTimeUpdate",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTimeUpdateCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchCancel",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchCancelCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchEnd",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchEndCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchMove",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchMoveCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchStart",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTouchStartCapture",
                "value": "TouchEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTransitionEnd",
                "value": "TransitionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onTransitionEndCapture",
                "value": "TransitionEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVolumeChange",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onVolumeChangeCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWaiting",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWaitingCapture",
                "value": "ReactEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWheel",
                "value": "WheelEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onWheelCapture",
                "value": "WheelEventHandler<T> | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "placeholder",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "prefix",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "property",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "radioGroup",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "rel",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "resource",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "results",
                "value": "number | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "rev",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "role",
                "value": "AriaRole | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "security",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "slot",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "spellCheck",
                "value": "Booleanish | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "style",
                "value": "CSSProperties | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "suppressContentEditableWarning",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "suppressHydrationWarning",
                "value": "boolean | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "tabIndex",
                "value": "number | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "translate",
                "value": "'yes' | 'no' | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "typeof",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "unselectable",
                "value": "'on' | 'off' | undefined",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "vocab",
                "value": "string | undefined",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface MediaFileProps extends BaseProps {\n  /** An object with fields that correspond to the Storefront API's [Media object](https://shopify.dev/api/storefront/reference/products/media). */\n  data: PartialDeep<MediaEdgeType['node'], {recurseIntoArrays: true}>;\n  /** The options for the `Image`, `Video`, `ExternalVideo`, or `ModelViewer` components. */\n  mediaOptions?: MediaOptions;\n}"
          },
          "MediaOptions": {
            "filePath": "src/MediaFile.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "MediaOptions",
            "value": "{\n  /** Props that will only apply when an `<Image />` is rendered */\n  image?: Omit<HydrogenImageProps, 'data'>;\n  /** Props that will only apply when a `<Video />` is rendered */\n  video?: Omit<React.ComponentProps<typeof Video>, 'data'>;\n  /** Props that will only apply when an `<ExternalVideo />` is rendered */\n  externalVideo?: Omit<\n    React.ComponentProps<typeof ExternalVideo>['options'],\n    'data'\n  >;\n  /** Props that will only apply when a `<ModelViewer />` is rendered */\n  modelViewer?: Omit<typeof ModelViewer, 'data'>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "externalVideo",
                "value": "Omit<\n    React.ComponentProps<typeof ExternalVideo>['options'],\n    'data'\n  >",
                "description": "Props that will only apply when an `<ExternalVideo />` is rendered",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "image",
                "value": "Omit<HydrogenImageProps, 'data'>",
                "description": "Props that will only apply when an `<Image />` is rendered",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "modelViewer",
                "value": "Omit<typeof ModelViewer, 'data'>",
                "description": "Props that will only apply when a `<ModelViewer />` is rendered",
                "isOptional": true
              },
              {
                "filePath": "src/MediaFile.tsx",
                "syntaxKind": "PropertySignature",
                "name": "video",
                "value": "Omit<React.ComponentProps<typeof Video>, 'data'>",
                "description": "Props that will only apply when a `<Video />` is rendered",
                "isOptional": true
              }
            ]
          },
          "HydrogenImageProps": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenImageProps",
            "value": "React.ComponentPropsWithRef<'img'> & HydrogenImageBaseProps",
            "description": ""
          },
          "HydrogenImageBaseProps": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "HydrogenImageBaseProps",
            "value": "{\n  /** The aspect ratio of the image, in the format of `width/height`.\n   *\n   * @example\n   * ```\n   * <Image data={productImage} aspectRatio=\"4/5\" />\n   * ```\n   */\n  aspectRatio?: string;\n  /** The crop position of the image.\n   *\n   * @remarks\n   * In the event that AspectRatio is set, without specifying a crop,\n   * the Shopify CDN won't return the expected image.\n   *\n   * @defaultValue `center`\n   */\n  crop?: Crop;\n  /** Data mapping to the [Storefront API `Image`](https://shopify.dev/docs/api/storefront/2024-07/objects/Image) object. Must be an Image object.\n   *\n   * @example\n   * ```\n   * import {IMAGE_FRAGMENT, Image} from '@shopify/hydrogen';\n   *\n   * export const IMAGE_QUERY = `#graphql\n   * ${IMAGE_FRAGMENT}\n   * query {\n   *   product {\n   *     featuredImage {\n   *       ...Image\n   *     }\n   *   }\n   * }`\n   *\n   * <Image\n   *   data={productImage}\n   *   sizes=\"(min-width: 45em) 50vw, 100vw\"\n   *   aspectRatio=\"4/5\"\n   * />\n   * ```\n   *\n   * Image: {@link https://shopify.dev/api/storefront/reference/common-objects/image}\n   */\n  data?: PartialDeep<ImageType, {recurseIntoArrays: true}>;\n  /** A function that returns a URL string for an image.\n   *\n   * @remarks\n   * By default, this uses Shopifys CDN {@link https://cdn.shopify.com/} but you can provide\n   * your own function to use a another provider, as long as they support URL based image transformations.\n   */\n  loader?: Loader;\n  /** An optional prop you can use to change the default srcSet generation behaviour */\n  srcSetOptions?: SrcSetOptions;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "aspectRatio",
                "value": "string",
                "description": "The aspect ratio of the image, in the format of `width/height`.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "<Image data={productImage} aspectRatio=\"4/5\" />",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crop",
                "value": "Crop",
                "description": "The crop position of the image.",
                "isOptional": true,
                "defaultValue": "`center`"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<ImageType, {recurseIntoArrays: true}>",
                "description": "Data mapping to the [Storefront API `Image`](https://shopify.dev/docs/api/storefront/2024-07/objects/Image) object. Must be an Image object.",
                "isOptional": true,
                "examples": [
                  {
                    "title": "Example",
                    "description": "",
                    "tabs": [
                      {
                        "code": "import {IMAGE_FRAGMENT, Image} from '@shopify/hydrogen';\n\nexport const IMAGE_QUERY = `#graphql\n${IMAGE_FRAGMENT}\nquery {\n  product {\n    featuredImage {\n      ...Image\n    }\n  }\n}`\n\n<Image\n  data={productImage}\n  sizes=\"(min-width: 45em) 50vw, 100vw\"\n  aspectRatio=\"4/5\"\n/>",
                        "title": "Example"
                      },
                      {
                        "code": "Image:",
                        "title": "Example"
                      }
                    ]
                  }
                ]
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "loader",
                "value": "Loader",
                "description": "A function that returns a URL string for an image.",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "srcSetOptions",
                "value": "SrcSetOptions",
                "description": "An optional prop you can use to change the default srcSet generation behaviour",
                "isOptional": true
              }
            ]
          },
          "Crop": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Crop",
            "value": "'center' | 'top' | 'bottom' | 'left' | 'right'",
            "description": ""
          },
          "Loader": {
            "filePath": "src/Image.tsx",
            "name": "Loader",
            "description": "",
            "params": [
              {
                "name": "params",
                "description": "",
                "value": "LoaderParams",
                "filePath": "src/Image.tsx"
              }
            ],
            "returns": {
              "filePath": "src/Image.tsx",
              "description": "",
              "name": "string",
              "value": "string"
            },
            "value": "export type Loader = (params: LoaderParams) => string;"
          },
          "LoaderParams": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoaderParams",
            "value": "{\n  /** The base URL of the image */\n  src?: ImageType['url'];\n  /** The URL param that controls width */\n  width?: number;\n  /** The URL param that controls height */\n  height?: number;\n  /** The URL param that controls the cropping region */\n  crop?: Crop;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crop",
                "value": "Crop",
                "description": "The URL param that controls the cropping region",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "height",
                "value": "number",
                "description": "The URL param that controls height",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "src",
                "value": "string",
                "description": "The base URL of the image",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "width",
                "value": "number",
                "description": "The URL param that controls width",
                "isOptional": true
              }
            ]
          },
          "SrcSetOptions": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "SrcSetOptions",
            "value": "{\n  /** The number of sizes to generate */\n  intervals: number;\n  /** The smallest image size */\n  startingWidth: number;\n  /** The increment by which to increase for each size, in pixels */\n  incrementSize: number;\n  /** The size used for placeholder fallback images */\n  placeholderWidth: number;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "incrementSize",
                "value": "number",
                "description": "The increment by which to increase for each size, in pixels"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "intervals",
                "value": "number",
                "description": "The number of sizes to generate"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "placeholderWidth",
                "value": "number",
                "description": "The size used for placeholder fallback images"
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "startingWidth",
                "value": "number",
                "description": "The smallest image size"
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Money",
    "category": "components",
    "isVisualComponent": false,
    "related": [
      {
        "name": "useMoney",
        "type": "hook",
        "url": "/api/hydrogen/hooks/useMoney"
      }
    ],
    "description": "The `Money` component renders a string of the Storefront API's[MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) according to the `locale` in the [`ShopifyProvider` component](/api/hydrogen/components/global/shopifyprovider).\nThe component outputs a `<div>`. You can [customize this component](https://api/hydrogen/components#customizing-hydrogen-components) using passthrough props.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Money} from '@shopify/hydrogen';\n\nexport default function ProductMoney({product}) {\n  const price = product.variants.nodes[0].price;\n\n  return &lt;Money data={price} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {Money} from '@shopify/hydrogen';\nimport type {Product} from '@shopify/hydrogen/storefront-api-types';\n\nexport default function ProductMoney({product}: {product: Product}) {\n  const price = product.variants.nodes[0].price;\n\n  return &lt;Money data={price} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "MoneyPropsBase",
        "typeDefinitions": {
          "MoneyPropsBase": {
            "filePath": "src/Money.tsx",
            "name": "MoneyPropsBase",
            "description": "",
            "members": [
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "as",
                "value": "ComponentGeneric",
                "description": "An HTML tag or React Component to be rendered as the base element wrapper. The default is `div`.",
                "isOptional": true
              },
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<MoneyV2, {recurseIntoArrays: true}>",
                "description": "An object with fields that correspond to the Storefront API's [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2)."
              },
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "measurement",
                "value": "PartialDeep<UnitPriceMeasurement, {recurseIntoArrays: true}>",
                "description": "A [UnitPriceMeasurement object](https://shopify.dev/api/storefront/2024-07/objects/unitpricemeasurement).",
                "isOptional": true
              },
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "measurementSeparator",
                "value": "ReactNode",
                "description": "Customizes the separator between the money output and the measurement output. Used with the `measurement` prop. Defaults to `'/'`.",
                "isOptional": true
              },
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withoutCurrency",
                "value": "boolean",
                "description": "Whether to remove the currency symbol from the output.",
                "isOptional": true
              },
              {
                "filePath": "src/Money.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withoutTrailingZeros",
                "value": "boolean",
                "description": "Whether to remove trailing zeros (fractional money) from the output.",
                "isOptional": true
              }
            ],
            "value": "export interface MoneyPropsBase<ComponentGeneric extends React.ElementType> {\n  /** An HTML tag or React Component to be rendered as the base element wrapper. The default is `div`. */\n  as?: ComponentGeneric;\n  /** An object with fields that correspond to the Storefront API's [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2). */\n  data: PartialDeep<MoneyV2, {recurseIntoArrays: true}>;\n  /** Whether to remove the currency symbol from the output. */\n  withoutCurrency?: boolean;\n  /** Whether to remove trailing zeros (fractional money) from the output. */\n  withoutTrailingZeros?: boolean;\n  /** A [UnitPriceMeasurement object](https://shopify.dev/api/storefront/2024-07/objects/unitpricemeasurement). */\n  measurement?: PartialDeep<UnitPriceMeasurement, {recurseIntoArrays: true}>;\n  /** Customizes the separator between the money output and the measurement output. Used with the `measurement` prop. Defaults to `'/'`. */\n  measurementSeparator?: ReactNode;\n}"
          }
        }
      }
    ]
  },
  {
    "name": "ModelViewer",
    "category": "components",
    "subCategory": "media",
    "isVisualComponent": false,
    "related": [
      {
        "name": "MediaFile",
        "type": "component",
        "url": "/api/hydrogen/components/mediafile"
      }
    ],
    "description": "The `ModelViewer` component renders a 3D model (with the `model-viewer` custom element) for the Storefront API's [Model3d object](https://shopify.dev/api/storefront/reference/products/model3d). The `model-viewer` custom element is lazily downloaded through a dynamically-injected `<script type='module'>` tag when the `<ModelViewer />` component is rendered. ModelViewer is using version `1.21.1` of the `@google/model-viewer` library.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {ModelViewer} from '@shopify/hydrogen';\n\nexport default function MyProductModel({products}) {\n  const firstMediaElement = products.nodes[0].media.nodes[0];\n\n  if (firstMediaElement.__typename === 'Model3d') {\n    return &lt;ModelViewer data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {ModelViewer} from '@shopify/hydrogen';\nimport type {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport default function MyProductModel({\n  products,\n}: {\n  products: ProductConnection;\n}) {\n  const firstMediaElement = products.nodes[0].media.nodes[0];\n  if (firstMediaElement.__typename === 'Model3d') {\n    return &lt;ModelViewer data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "ModelViewerBaseProps",
        "typeDefinitions": {
          "ModelViewerBaseProps": {
            "filePath": "src/ModelViewer.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ModelViewerBaseProps",
            "value": "{\n  /** An object with fields that correspond to the Storefront API's [Model3D object](https://shopify.dev/api/storefront/2024-07/objects/model3d). */\n  data: PartialDeep<Model3d, {recurseIntoArrays: true}>;\n  /** The callback to invoke when the 'error' event is triggered. Refer to [error in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-error). */\n  onError?: (event: Event) => void;\n  /** The callback to invoke when the `load` event is triggered. Refer to [load in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-load). */\n  onLoad?: (event: Event) => void;\n  /** The callback to invoke when the 'preload' event is triggered. Refer to [preload in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-preload). */\n  onPreload?: (event: Event) => void;\n  /** The callback to invoke when the 'model-visibility' event is triggered. Refer to [model-visibility in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-modelVisibility). */\n  onModelVisibility?: (event: Event) => void;\n  /** The callback to invoke when the 'progress' event is triggered. Refer to [progress in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-progress). */\n  onProgress?: (event: Event) => void;\n  /** The callback to invoke when the 'ar-status' event is triggered. Refer to [ar-status in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arStatus). */\n  onArStatus?: (event: Event) => void;\n  /** The callback to invoke when the 'ar-tracking' event is triggered. Refer to [ar-tracking in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arTracking). */\n  onArTracking?: (event: Event) => void;\n  /** The callback to invoke when the 'quick-look-button-tapped' event is triggered. Refer to [quick-look-button-tapped in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-quickLookButtonTapped). */\n  onQuickLookButtonTapped?: (event: Event) => void;\n  /** The callback to invoke when the 'camera-change' event is triggered. Refer to [camera-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-events-cameraChange). */\n  onCameraChange?: (event: Event) => void;\n  /** The callback to invoke when the 'environment-change' event is triggered. Refer to [environment-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-events-environmentChange).  */\n  onEnvironmentChange?: (event: Event) => void;\n  /**  The callback to invoke when the 'play' event is triggered. Refer to [play in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-play). */\n  onPlay?: (event: Event) => void;\n  /**  The callback to invoke when the 'pause' event is triggered. Refer to [pause in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-pause). */\n  onPause?: (event: Event) => void;\n  /** The callback to invoke when the 'scene-graph-ready' event is triggered. Refer to [scene-graph-ready in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-events-sceneGraphReady). */\n  onSceneGraphReady?: (event: Event) => void;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<Model3d, {recurseIntoArrays: true}>",
                "description": "An object with fields that correspond to the Storefront API's [Model3D object](https://shopify.dev/api/storefront/2024-07/objects/model3d)."
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onArStatus",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'ar-status' event is triggered. Refer to [ar-status in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arStatus).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onArTracking",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'ar-tracking' event is triggered. Refer to [ar-tracking in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arTracking).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onCameraChange",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'camera-change' event is triggered. Refer to [camera-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-events-cameraChange).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onEnvironmentChange",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'environment-change' event is triggered. Refer to [environment-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-events-environmentChange).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onError",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'error' event is triggered. Refer to [error in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-error).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onLoad",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the `load` event is triggered. Refer to [load in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-load).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onModelVisibility",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'model-visibility' event is triggered. Refer to [model-visibility in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-modelVisibility).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPause",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'pause' event is triggered. Refer to [pause in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-pause).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPlay",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'play' event is triggered. Refer to [play in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-play).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onPreload",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'preload' event is triggered. Refer to [preload in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-preload).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onProgress",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'progress' event is triggered. Refer to [progress in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-progress).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onQuickLookButtonTapped",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'quick-look-button-tapped' event is triggered. Refer to [quick-look-button-tapped in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-quickLookButtonTapped).",
                "isOptional": true
              },
              {
                "filePath": "src/ModelViewer.tsx",
                "syntaxKind": "PropertySignature",
                "name": "onSceneGraphReady",
                "value": "(event: Event) => void",
                "description": "The callback to invoke when the 'scene-graph-ready' event is triggered. Refer to [scene-graph-ready in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-events-sceneGraphReady).",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "ShopPayButton",
    "category": "components",
    "isVisualComponent": false,
    "related": [],
    "description": "The `ShopPayButton` component renders a button that redirects to the Shop Pay checkout. It renders a [`<shop-pay-button>`](https://shopify.dev/custom-storefronts/tools/web-components) custom element, for which it will lazy-load the source code automatically.",
    "type": "component",
    "defaultExample": {
      "description": "<ShopPayButton> without <ShopifyProvider>",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {ShopPayButton} from '@shopify/hydrogen';\n\nexport function AddVariantQuantity1({variantId, storeDomain}) {\n  return &lt;ShopPayButton variantIds={[variantId]} storeDomain={storeDomain} /&gt;;\n}\n\nexport function AddVariantQuantityMultiple({variantId, quantity, storeDomain}) {\n  return (\n    &lt;ShopPayButton\n      variantIdsAndQuantities={[{id: variantId, quantity}]}\n      storeDomain={storeDomain}\n    /&gt;\n  );\n}\n\nexport function ChannelAttribution({channel, variantId, storeDomain}) {\n  return (\n    &lt;ShopPayButton\n      channel={channel}\n      variantIds={[variantId]}\n      storeDomain={storeDomain}\n    /&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {ShopPayButton} from '@shopify/hydrogen';\n\nexport function AddVariantQuantity1({\n  variantId,\n  storeDomain,\n}: {\n  variantId: string;\n  storeDomain: string;\n}) {\n  return &lt;ShopPayButton variantIds={[variantId]} storeDomain={storeDomain} /&gt;;\n}\n\nexport function AddVariantQuantityMultiple({\n  variantId,\n  quantity,\n  storeDomain,\n}: {\n  variantId: string;\n  quantity: number;\n  storeDomain: string;\n}) {\n  return (\n    &lt;ShopPayButton\n      variantIdsAndQuantities={[{id: variantId, quantity}]}\n      storeDomain={storeDomain}\n    /&gt;\n  );\n}\n\nexport function ChannelAttribution({\n  channel,\n  variantId,\n  storeDomain,\n}: {\n  channel: 'headless' | 'hydrogen';\n  variantId: string;\n  storeDomain: string;\n}) {\n  return (\n    &lt;ShopPayButton\n      channel={channel}\n      variantIds={[variantId]}\n      storeDomain={storeDomain}\n    /&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "<ShopPayButton> without <ShopifyProvider>"
      }
    },
    "examples": {
      "description": "",
      "examples": [
        {
          "description": "If `<ShopifyProvider>` context provider is used in your app, you can use the `<ShopPayButton>` without supplying a `storeDomain` prop",
          "codeblock": {
            "tabs": [
              {
                "title": "JavaScript",
                "code": "import {ShopifyProvider, ShopPayButton} from '@shopify/hydrogen';\n\nexport default function App() {\n  return (\n    &lt;ShopifyProvider\n      storeDomain=\"my-store\"\n      storefrontToken=\"abc123\"\n      storefrontApiVersion=\"2024-07\"\n      countryIsoCode=\"CA\"\n      languageIsoCode=\"EN\"\n    &gt;\n      &lt;AddVariantQuantity1 variantId=\"gid://shopify/ProductVariant/1\" /&gt;\n    &lt;/ShopifyProvider&gt;\n  );\n}\n\nexport function AddVariantQuantity1({variantId}) {\n  return &lt;ShopPayButton variantIds={[variantId]} /&gt;;\n}\n",
                "language": "jsx"
              },
              {
                "title": "TypeScript",
                "code": "import {ShopifyProvider, ShopPayButton} from '@shopify/hydrogen';\n\nexport default function App() {\n  return (\n    &lt;ShopifyProvider\n      storeDomain=\"my-store\"\n      storefrontToken=\"abc123\"\n      storefrontApiVersion=\"2024-07\"\n      countryIsoCode=\"CA\"\n      languageIsoCode=\"EN\"\n    &gt;\n      &lt;AddVariantQuantity1 variantId=\"gid://shopify/ProductVariant/1\" /&gt;\n    &lt;/ShopifyProvider&gt;\n  );\n}\n\nexport function AddVariantQuantity1({variantId}: {variantId: string}) {\n  return &lt;ShopPayButton variantIds={[variantId]} /&gt;;\n}\n",
                "language": "tsx"
              }
            ],
            "title": "<ShopPayButton> with <ShopifyProvider>"
          }
        }
      ]
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "ShopPayButtonProps",
        "typeDefinitions": {
          "ShopPayButtonProps": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayButtonProps",
            "value": "ShopPayButtonStyleProps & ShopPayDomainProps & ShopPayChannelAttribution & (ShopPayVariantIds | ShopPayVariantAndQuantities)",
            "description": ""
          },
          "ShopPayButtonStyleProps": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayButtonStyleProps",
            "value": "{\n  /** A string of classes to apply to the `div` that wraps the Shop Pay button. */\n  className?: string;\n  /** A string that's applied to the [CSS custom property (variable)](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) `--shop-pay-button-width` for the [Buy with Shop Pay component](https://shopify.dev/custom-storefronts/tools/web-components#buy-with-shop-pay-component). */\n  width?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "className",
                "value": "string",
                "description": "A string of classes to apply to the `div` that wraps the Shop Pay button.",
                "isOptional": true
              },
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "width",
                "value": "string",
                "description": "A string that's applied to the [CSS custom property (variable)](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) `--shop-pay-button-width` for the [Buy with Shop Pay component](https://shopify.dev/custom-storefronts/tools/web-components#buy-with-shop-pay-component).",
                "isOptional": true
              }
            ]
          },
          "ShopPayDomainProps": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayDomainProps",
            "value": "{\n  /** The domain of your Shopify storefront URL (eg: `your-store.myshopify.com`). */\n  storeDomain?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "storeDomain",
                "value": "string",
                "description": "The domain of your Shopify storefront URL (eg: `your-store.myshopify.com`).",
                "isOptional": true
              }
            ]
          },
          "ShopPayChannelAttribution": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayChannelAttribution",
            "value": "{\n  /** A string that adds channel attribution to the order. Can be either `headless` or `hydrogen` */\n  channel?: 'headless' | 'hydrogen';\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "channel",
                "value": "'headless' | 'hydrogen'",
                "description": "A string that adds channel attribution to the order. Can be either `headless` or `hydrogen`",
                "isOptional": true
              }
            ]
          },
          "ShopPayVariantIds": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayVariantIds",
            "value": "{\n  /** An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use `variantIdsAndQuantities`. */\n  variantIds: string[];\n  /** An array of variant IDs and quantities to purchase with Shop Pay. */\n  variantIdsAndQuantities?: never;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantIds",
                "value": "string[]",
                "description": "An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use `variantIdsAndQuantities`."
              },
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantIdsAndQuantities",
                "value": "never",
                "description": "An array of variant IDs and quantities to purchase with Shop Pay.",
                "isOptional": true
              }
            ]
          },
          "ShopPayVariantAndQuantities": {
            "filePath": "src/ShopPayButton.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopPayVariantAndQuantities",
            "value": "{\n  /** An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use `variantIdsAndQuantities`. */\n  variantIds?: never;\n  /** An array of variant IDs and quantities to purchase with Shop Pay. */\n  variantIdsAndQuantities: Array<{\n    id: string;\n    quantity: number;\n  }>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantIds",
                "value": "never",
                "description": "An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use `variantIdsAndQuantities`.",
                "isOptional": true
              },
              {
                "filePath": "src/ShopPayButton.tsx",
                "syntaxKind": "PropertySignature",
                "name": "variantIdsAndQuantities",
                "value": "Array<{\n    id: string;\n    quantity: number;\n  }>",
                "description": "An array of variant IDs and quantities to purchase with Shop Pay."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "RichText",
    "category": "components",
    "isVisualComponent": false,
    "related": [],
    "description": "The `RichText` component renders a metafield of type `rich_text_field`. By default the rendered output uses semantic HTML tags. Customize how nodes are rendered with the `components` prop.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {RichText} from '@shopify/hydrogen';\n\nexport function MainRichText({metaFieldData}) {\n  return (\n    &lt;RichText\n      data={metaFieldData}\n      components={{\n        paragraph({node}) {\n          return &lt;p className=\"customClass\"&gt;{node.children}&lt;/p&gt;;\n        },\n      }}\n    /&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {RichText} from '@shopify/hydrogen';\n\nexport function MainRichText({metaFieldData}: {metaFieldData: string}) {\n  return (\n    &lt;RichText\n      data={metaFieldData}\n      components={{\n        paragraph({node}) {\n          return &lt;p className=\"customClass\"&gt;{node.children}&lt;/p&gt;;\n        },\n      }}\n    /&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "RichTextPropsForDocs",
        "typeDefinitions": {
          "RichTextPropsForDocs": {
            "filePath": "src/RichText.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "RichTextPropsForDocs",
            "value": "RichTextPropsBase<AsType>",
            "description": "",
            "members": [
              {
                "filePath": "src/RichText.tsx",
                "syntaxKind": "PropertySignature",
                "name": "as",
                "value": "ComponentGeneric",
                "description": "An HTML tag or React Component to be rendered as the base element wrapper. The default is `div`.",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.tsx",
                "syntaxKind": "PropertySignature",
                "name": "components",
                "value": "CustomComponents",
                "description": "Customize how rich text components are rendered",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "string",
                "description": "The JSON string that correspond to the Storefront API's [RichText format](https://shopify.dev/docs/apps/custom-data/metafields/types#rich-text-formatting)."
              },
              {
                "filePath": "src/RichText.tsx",
                "syntaxKind": "PropertySignature",
                "name": "plain",
                "value": "boolean",
                "description": "Remove rich text formatting and render plain text",
                "isOptional": true
              }
            ]
          },
          "CustomComponents": {
            "filePath": "src/RichText.components.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "CustomComponents",
            "value": "{\n  /** The root node of the rich text. Defaults to `<div>` */\n  root?: typeof Root;\n  /** Customize the headings. Each heading has a `level` property from 1-6. Defaults to `<h1>` to `<h6>` */\n  heading?: typeof Heading;\n  /** Customize paragraphs. Defaults to `<p>` */\n  paragraph?: typeof Paragraph;\n  /** Customize how text nodes. They can either be bold or italic. Defaults to `<em>`, `<strong>` or text. */\n  text?: typeof Text;\n  /** Customize links. Defaults to a React Router `<Link>` component in Hydrogen and a `<a>` in Hydrogen React. */\n  link?: typeof RichTextLink;\n  /** Customize lists. They can be either ordered or unordered. Defaults to `<ol>` or `<ul>` */\n  list?: typeof List;\n  /** Customize list items. Defaults to `<li>`. */\n  listItem?: typeof ListItem;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "heading",
                "value": "({ node, }: { node: { type: \"heading\"; level: number; children?: ReactNode[]; }; }) => ReactNode",
                "description": "Customize the headings. Each heading has a `level` property from 1-6. Defaults to `<h1>` to `<h6>`",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "link",
                "value": "({ node, }: { node: { type: \"link\"; url: string; title?: string; target?: string; children?: ReactNode[]; }; }) => ReactNode",
                "description": "Customize links. Defaults to a React Router `<Link>` component in Hydrogen and a `<a>` in Hydrogen React.",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "list",
                "value": "({ node, }: { node: { type: \"list\"; listType: \"unordered\" | \"ordered\"; children?: ReactNode[]; }; }) => ReactNode",
                "description": "Customize lists. They can be either ordered or unordered. Defaults to `<ol>` or `<ul>`",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "listItem",
                "value": "({ node, }: { node: { type: \"list-item\"; children?: ReactNode[]; }; }) => ReactNode",
                "description": "Customize list items. Defaults to `<li>`.",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "paragraph",
                "value": "({ node, }: { node: { type: \"paragraph\"; children?: ReactNode[]; }; }) => ReactNode",
                "description": "Customize paragraphs. Defaults to `<p>`",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "root",
                "value": "({ node, }: { node: { type: \"root\"; children?: ReactNode[]; }; }) => ReactNode",
                "description": "The root node of the rich text. Defaults to `<div>`",
                "isOptional": true
              },
              {
                "filePath": "src/RichText.components.tsx",
                "syntaxKind": "PropertySignature",
                "name": "text",
                "value": "({ node, }: { node: { type: \"text\"; italic?: boolean; bold?: boolean; value?: string; }; }) => ReactNode",
                "description": "Customize how text nodes. They can either be bold or italic. Defaults to `<em>`, `<strong>` or text.",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "Video",
    "category": "components",
    "subCategory": "media",
    "isVisualComponent": false,
    "related": [
      {
        "name": "MediaFile",
        "type": "component",
        "url": "/api/hydrogen/hooks/mediafile"
      },
      {
        "name": "Image",
        "type": "component",
        "url": "/api/hydrogen/hooks/image"
      }
    ],
    "description": "The `Video` component renders a video for the Storefront API's [Video object](https://shopify.dev/api/storefront/reference/products/video).\nThe component outputs a `video` element. You can [customize this component](https://shopify.dev/api/hydrogen/components#customizing-hydrogen-components) using passthrough props.",
    "type": "component",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {Video} from '@shopify/hydrogen';\n\nexport default function MyProductVideo({products}) {\n  const firstMediaElement = products.edges[0].node.media.edges[0].node;\n\n  if (firstMediaElement.__typename === 'Video') {\n    return &lt;Video data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {Video} from '@shopify/hydrogen';\nimport type {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport default function MyProductVideo({\n  products,\n}: {\n  products: ProductConnection;\n}) {\n  const firstMediaElement = products.edges[0].node.media.edges[0].node;\n\n  if (firstMediaElement.__typename === 'Video') {\n    return &lt;Video data={firstMediaElement} /&gt;;\n  }\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "VideoProps",
        "typeDefinitions": {
          "VideoProps": {
            "filePath": "src/Video.tsx",
            "name": "VideoProps",
            "description": "",
            "members": [
              {
                "filePath": "src/Video.tsx",
                "syntaxKind": "PropertySignature",
                "name": "data",
                "value": "PartialDeep<VideoType, {recurseIntoArrays: true}>",
                "description": "An object with fields that correspond to the Storefront API's [Video object](https://shopify.dev/api/storefront/2024-07/objects/video)."
              },
              {
                "filePath": "src/Video.tsx",
                "syntaxKind": "PropertySignature",
                "name": "previewImageOptions",
                "value": "LoaderParams",
                "description": "An object of image size options for the video's `previewImage`. Uses `shopifyImageLoader` to generate the `poster` URL.",
                "isOptional": true
              },
              {
                "filePath": "src/Video.tsx",
                "syntaxKind": "PropertySignature",
                "name": "sourceProps",
                "value": "HTMLAttributes<HTMLSourceElement> & { 'data-testid'?: string; }",
                "description": "Props that will be passed to the `video` element's `source` children elements.",
                "isOptional": true
              }
            ],
            "value": "export interface VideoProps {\n  /** An object with fields that correspond to the Storefront API's [Video object](https://shopify.dev/api/storefront/2024-07/objects/video). */\n  data: PartialDeep<VideoType, {recurseIntoArrays: true}>;\n  /** An object of image size options for the video's `previewImage`. Uses `shopifyImageLoader` to generate the `poster` URL. */\n  previewImageOptions?: Parameters<typeof shopifyLoader>[0];\n  /** Props that will be passed to the `video` element's `source` children elements. */\n  sourceProps?: HTMLAttributes<HTMLSourceElement> & {\n    'data-testid'?: string;\n  };\n}"
          },
          "LoaderParams": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoaderParams",
            "value": "{\n  /** The base URL of the image */\n  src?: ImageType['url'];\n  /** The URL param that controls width */\n  width?: number;\n  /** The URL param that controls height */\n  height?: number;\n  /** The URL param that controls the cropping region */\n  crop?: Crop;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "crop",
                "value": "Crop",
                "description": "The URL param that controls the cropping region",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "height",
                "value": "number",
                "description": "The URL param that controls height",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "src",
                "value": "string",
                "description": "The base URL of the image",
                "isOptional": true
              },
              {
                "filePath": "src/Image.tsx",
                "syntaxKind": "PropertySignature",
                "name": "width",
                "value": "number",
                "description": "The URL param that controls width",
                "isOptional": true
              }
            ]
          },
          "Crop": {
            "filePath": "src/Image.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "Crop",
            "value": "'center' | 'top' | 'bottom' | 'left' | 'right'",
            "description": ""
          }
        }
      }
    ]
  },
  {
    "name": "useMoney",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [
      {
        "name": "Money",
        "type": "component",
        "url": "/api/hydrogen/components/money"
      }
    ],
    "description": "\n    The `useMoney` hook takes a [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) and returns a\n    default-formatted string of the amount with the correct currency indicator, along with some of the parts provided by\n    [Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat).\n  ",
    "type": "hook",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {useMoney, ShopifyProvider} from '@shopify/hydrogen';\n\nexport function App() {\n  return (\n    &lt;ShopifyProvider languageIsoCode=\"EN\" countryIsoCode=\"US\"&gt;\n      &lt;UsingMoney /&gt;\n    &lt;/ShopifyProvider&gt;\n  );\n}\n\nfunction UsingMoney() {\n  const myMoney = {amount: '100', currencyCode: 'USD'};\n  const money = useMoney(myMoney);\n  return (\n    &lt;&gt;\n      &lt;div&gt;Localized money: {money.localizedString}&lt;/div&gt;\n      &lt;div&gt;Money without trailing zeros: {money.withoutTrailingZeros}&lt;/div&gt;\n    &lt;/&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {useMoney, ShopifyProvider} from '@shopify/hydrogen';\nimport type {MoneyV2} from '@shopify/hydrogen/storefront-api-types';\n\nexport function App() {\n  return (\n    // @ts-expect-error intentionally missing the rest of the props\n    &lt;ShopifyProvider countryIsoCode=\"US\" languageIsoCode=\"EN\"&gt;\n      &lt;UsingMoney /&gt;\n    &lt;/ShopifyProvider&gt;\n  );\n}\n\nfunction UsingMoney() {\n  const myMoney = {amount: '100', currencyCode: 'USD'} satisfies MoneyV2;\n  const money = useMoney(myMoney);\n  return (\n    &lt;&gt;\n      &lt;div&gt;Localized money: {money.localizedString}&lt;/div&gt;\n      &lt;div&gt;Money without trailing zeros: {money.withoutTrailingZeros}&lt;/div&gt;\n    &lt;/&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "`useMoney` must be a descendent of a `ShopifyProvider` component.",
        "type": "UseMoneyGeneratedType",
        "typeDefinitions": {
          "UseMoneyGeneratedType": {
            "filePath": "src/useMoney.tsx",
            "name": "UseMoneyGeneratedType",
            "description": "The `useMoney` hook takes a [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) and returns a default-formatted string of the amount with the correct currency indicator, along with some of the parts provided by [Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat). Uses `locale` from `ShopifyProvider` &nbsp;",
            "params": [
              {
                "name": "money",
                "description": "",
                "value": "MoneyV2",
                "filePath": "src/useMoney.tsx"
              }
            ],
            "returns": {
              "filePath": "src/useMoney.tsx",
              "description": "",
              "name": "UseMoneyValue",
              "value": "UseMoneyValue"
            },
            "value": "export function useMoney(money: MoneyV2): UseMoneyValue {\n  const {countryIsoCode, languageIsoCode} = useShop();\n  const locale = languageIsoCode.includes('_')\n    ? languageIsoCode.replace('_', '-')\n    : `${languageIsoCode}-${countryIsoCode}`;\n\n  if (!locale) {\n    throw new Error(\n      `useMoney(): Unable to get 'locale' from 'useShop()', which means that 'locale' was not passed to '<ShopifyProvider/>'. 'locale' is required for 'useMoney()' to work`,\n    );\n  }\n\n  const amount = parseFloat(money.amount);\n\n  const {\n    defaultFormatter,\n    nameFormatter,\n    narrowSymbolFormatter,\n    withoutTrailingZerosFormatter,\n    withoutCurrencyFormatter,\n    withoutTrailingZerosOrCurrencyFormatter,\n  } = useMemo(() => {\n    const options = {\n      style: 'currency' as const,\n      currency: money.currencyCode,\n    };\n\n    return {\n      defaultFormatter: getLazyFormatter(locale, options),\n      nameFormatter: getLazyFormatter(locale, {\n        ...options,\n        currencyDisplay: 'name',\n      }),\n      narrowSymbolFormatter: getLazyFormatter(locale, {\n        ...options,\n        currencyDisplay: 'narrowSymbol',\n      }),\n      withoutTrailingZerosFormatter: getLazyFormatter(locale, {\n        ...options,\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 0,\n      }),\n      withoutCurrencyFormatter: getLazyFormatter(locale),\n      withoutTrailingZerosOrCurrencyFormatter: getLazyFormatter(locale, {\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 0,\n      }),\n    };\n  }, [money.currencyCode, locale]);\n\n  const isPartCurrency = (part: Intl.NumberFormatPart): boolean =>\n    part.type === 'currency';\n\n  // By wrapping these properties in functions, we only\n  // create formatters if they are going to be used.\n  const lazyFormatters = useMemo(\n    () => ({\n      original: () => money,\n      currencyCode: () => money.currencyCode,\n\n      localizedString: () => defaultFormatter().format(amount),\n\n      parts: () => defaultFormatter().formatToParts(amount),\n\n      withoutTrailingZeros: () =>\n        amount % 1 === 0\n          ? withoutTrailingZerosFormatter().format(amount)\n          : defaultFormatter().format(amount),\n\n      withoutTrailingZerosAndCurrency: () =>\n        amount % 1 === 0\n          ? withoutTrailingZerosOrCurrencyFormatter().format(amount)\n          : withoutCurrencyFormatter().format(amount),\n\n      currencyName: () =>\n        nameFormatter().formatToParts(amount).find(isPartCurrency)?.value ??\n        money.currencyCode, // e.g. \"US dollars\"\n\n      currencySymbol: () =>\n        defaultFormatter().formatToParts(amount).find(isPartCurrency)?.value ??\n        money.currencyCode, // e.g. \"USD\"\n\n      currencyNarrowSymbol: () =>\n        narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)\n          ?.value ?? '', // e.g. \"$\"\n\n      amount: () =>\n        defaultFormatter()\n          .formatToParts(amount)\n          .filter((part) =>\n            ['decimal', 'fraction', 'group', 'integer', 'literal'].includes(\n              part.type,\n            ),\n          )\n          .map((part) => part.value)\n          .join(''),\n    }),\n    [\n      money,\n      amount,\n      nameFormatter,\n      defaultFormatter,\n      narrowSymbolFormatter,\n      withoutCurrencyFormatter,\n      withoutTrailingZerosFormatter,\n      withoutTrailingZerosOrCurrencyFormatter,\n    ],\n  );\n\n  // Call functions automatically when the properties are accessed\n  // to keep these functions as an implementation detail.\n  return useMemo(\n    () =>\n      new Proxy(lazyFormatters as unknown as UseMoneyValue, {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        get: (target, key) => Reflect.get(target, key)?.call(null),\n      }),\n    [lazyFormatters],\n  );\n}",
            "examples": [
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "initialize the money object",
                    "title": "Example"
                  },
                  {
                    "code": "const money = useMoney({\namount: '100.00',\ncurrencyCode: 'USD'\n})",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "basic usage, outputs: $100.00",
                    "title": "Example"
                  },
                  {
                    "code": "money.localizedString",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "without currency, outputs: 100.00",
                    "title": "Example"
                  },
                  {
                    "code": "money.amount",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "without trailing zeros, outputs: $100",
                    "title": "Example"
                  },
                  {
                    "code": "money.withoutTrailingZeros",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "currency name, outputs: US dollars",
                    "title": "Example"
                  },
                  {
                    "code": "money.currencyCode",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "currency symbol, outputs: $",
                    "title": "Example"
                  },
                  {
                    "code": "money.currencySymbol",
                    "title": "Example"
                  },
                  {
                    "code": "&nbsp;",
                    "title": "Example"
                  }
                ]
              },
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "without currency and without trailing zeros, outputs: 100",
                    "title": "Example"
                  },
                  {
                    "code": "money.withoutTrailingZerosAndCurrency",
                    "title": "Example"
                  }
                ]
              }
            ]
          },
          "UseMoneyValue": {
            "filePath": "src/useMoney.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "UseMoneyValue",
            "value": "{\n  /**\n   * The currency code from the `MoneyV2` object.\n   */\n  currencyCode: CurrencyCode;\n  /**\n   * The name for the currency code, returned by `Intl.NumberFormat`.\n   */\n  currencyName?: string;\n  /**\n   * The currency symbol returned by `Intl.NumberFormat`.\n   */\n  currencySymbol?: string;\n  /**\n   * The currency narrow symbol returned by `Intl.NumberFormat`.\n   */\n  currencyNarrowSymbol?: string;\n  /**\n   * The localized amount, without any currency symbols or non-number types from the `Intl.NumberFormat.formatToParts` parts.\n   */\n  amount: string;\n  /**\n   * All parts returned by `Intl.NumberFormat.formatToParts`.\n   */\n  parts: Intl.NumberFormatPart[];\n  /**\n   * A string returned by `new Intl.NumberFormat` for the amount and currency code,\n   * using the `locale` value in the [`LocalizationProvider` component](https://shopify.dev/api/hydrogen/components/localization/localizationprovider).\n   */\n  localizedString: string;\n  /**\n   * The `MoneyV2` object provided as an argument to the hook.\n   */\n  original: MoneyV2;\n  /**\n   * A string with trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains.\n   * For example, `$640.00` turns into `$640`.\n   * `$640.42` remains `$640.42`.\n   */\n  withoutTrailingZeros: string;\n  /**\n   * A string without currency and without trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains.\n   * For example, `$640.00` turns into `640`.\n   * `$640.42` turns into `640.42`.\n   */\n  withoutTrailingZerosAndCurrency: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "amount",
                "value": "string",
                "description": "The localized amount, without any currency symbols or non-number types from the `Intl.NumberFormat.formatToParts` parts."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currencyCode",
                "value": "CurrencyCode",
                "description": "The currency code from the `MoneyV2` object."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currencyName",
                "value": "string",
                "description": "The name for the currency code, returned by `Intl.NumberFormat`.",
                "isOptional": true
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currencyNarrowSymbol",
                "value": "string",
                "description": "The currency narrow symbol returned by `Intl.NumberFormat`.",
                "isOptional": true
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "currencySymbol",
                "value": "string",
                "description": "The currency symbol returned by `Intl.NumberFormat`.",
                "isOptional": true
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "localizedString",
                "value": "string",
                "description": "A string returned by `new Intl.NumberFormat` for the amount and currency code, using the `locale` value in the [`LocalizationProvider` component](https://shopify.dev/api/hydrogen/components/localization/localizationprovider)."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "original",
                "value": "MoneyV2",
                "description": "The `MoneyV2` object provided as an argument to the hook."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "parts",
                "value": "NumberFormatPart[]",
                "description": "All parts returned by `Intl.NumberFormat.formatToParts`."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withoutTrailingZeros",
                "value": "string",
                "description": "A string with trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains. For example, `$640.00` turns into `$640`. `$640.42` remains `$640.42`."
              },
              {
                "filePath": "src/useMoney.tsx",
                "syntaxKind": "PropertySignature",
                "name": "withoutTrailingZerosAndCurrency",
                "value": "string",
                "description": "A string without currency and without trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains. For example, `$640.00` turns into `640`. `$640.42` turns into `640.42`."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "useLoadScript",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [],
    "description": "The `useLoadScript` hook loads an external script tag in the browser. It allows React components to lazy-load third-party dependencies.",
    "type": "hook",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import React, {useEffect} from 'react';\nimport {useLoadScript} from '@shopify/hydrogen';\n\nexport default function Homepage() {\n  const scriptStatus = useLoadScript('https://some-cdn.com/some-script.js');\n\n  useEffect(() =&gt; {\n    if (scriptStatus === 'done') {\n      // do something\n    }\n  }, [scriptStatus]);\n\n  return &lt;div&gt;{scriptStatus === 'done' && &lt;p&gt;Script loaded!&lt;/p&gt;}&lt;/div&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import React, {useEffect} from 'react';\nimport {useLoadScript} from '@shopify/hydrogen';\n\nexport default function Homepage() {\n  const scriptStatus = useLoadScript('https://some-cdn.com/some-script.js');\n\n  useEffect(() =&gt; {\n    if (scriptStatus === 'done') {\n      // do something\n    }\n  }, [scriptStatus]);\n\n  return &lt;div&gt;{scriptStatus === 'done' && &lt;p&gt;Script loaded!&lt;/p&gt;}&lt;/div&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "LoadScriptParams",
        "typeDefinitions": {
          "LoadScriptParams": {
            "filePath": "src/load-script.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoadScriptParams",
            "value": "[src: string, options?: LoadScriptOptions]",
            "description": ""
          },
          "LoadScriptOptions": {
            "filePath": "src/load-script.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "LoadScriptOptions",
            "value": "{\n  module?: boolean;\n  in?: 'head' | 'body';\n  attributes?: Record<string, string>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/load-script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "attributes",
                "value": "Record<string, string>",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/load-script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "in",
                "value": "'head' | 'body'",
                "description": "",
                "isOptional": true
              },
              {
                "filePath": "src/load-script.tsx",
                "syntaxKind": "PropertySignature",
                "name": "module",
                "value": "boolean",
                "description": "",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "useShopifyCookies",
    "category": "hooks",
    "isVisualComponent": false,
    "related": [
      {
        "subtitle": "Utility",
        "name": "sendShopifyAnalytics",
        "url": "/api/hydrogen/utilities/sendShopifyAnalytics",
        "type": "gear"
      },
      {
        "subtitle": "Utility",
        "name": "getClientBrowserParameters",
        "url": "/api/hydrogen/utilities/getclientbrowserparameters",
        "type": "gear"
      },
      {
        "subtitle": "Utility",
        "name": "getShopifyCookies",
        "url": "/api/hydrogen/utilities/getShopifyCookies",
        "type": "gear"
      }
    ],
    "description": "Sets Shopify user and session cookies and refreshes the expiry time.",
    "type": "hooks",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import * as React from 'react';\nimport {useShopifyCookies} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useShopifyCookies({hasUserConsent: false});\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import * as React from 'react';\nimport {useShopifyCookies} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useShopifyCookies({hasUserConsent: false});\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "useShopifyCookies",
        "description": "Manages Shopify cookies. If `hasUserConsent` option is false, Shopify cookies will be removed.",
        "type": "UseShopifyCookiesGeneratedType",
        "typeDefinitions": {
          "UseShopifyCookiesGeneratedType": {
            "filePath": "src/useShopifyCookies.tsx",
            "name": "UseShopifyCookiesGeneratedType",
            "description": "",
            "params": [
              {
                "name": "options",
                "description": "",
                "value": "UseShopifyCookiesOptions",
                "isOptional": true,
                "filePath": "src/useShopifyCookies.tsx"
              }
            ],
            "returns": {
              "filePath": "src/useShopifyCookies.tsx",
              "description": "",
              "name": "void",
              "value": "void"
            },
            "value": "export function useShopifyCookies(options?: UseShopifyCookiesOptions): void {\n  const {\n    hasUserConsent = false,\n    domain = '',\n    checkoutDomain = '',\n  } = options || {};\n  useEffect(() => {\n    const cookies = getShopifyCookies(document.cookie);\n\n    /**\n     * Setting cookie with domain\n     *\n     * If no domain is provided, the cookie will be set for the current host.\n     * For Shopify, we need to ensure this domain is set with a leading dot.\n     */\n\n    // Use override domain or current host\n    let currentDomain = domain || window.document.location.host;\n\n    if (checkoutDomain) {\n      const checkoutDomainParts = checkoutDomain.split('.').reverse();\n      const currentDomainParts = currentDomain.split('.').reverse();\n      const sameDomainParts: Array<string> = [];\n      checkoutDomainParts.forEach((part, index) => {\n        if (part === currentDomainParts[index]) {\n          sameDomainParts.push(part);\n        }\n      });\n\n      currentDomain = sameDomainParts.reverse().join('.');\n    }\n\n    // Reset domain if localhost\n    if (/^localhost/.test(currentDomain)) currentDomain = '';\n\n    // Shopify checkout only consumes cookies set with leading dot domain\n    const domainWithLeadingDot = currentDomain\n      ? /^\\./.test(currentDomain)\n        ? currentDomain\n        : `.${currentDomain}`\n      : '';\n\n    /**\n     * Set user and session cookies and refresh the expiry time\n     */\n    if (hasUserConsent) {\n      setCookie(\n        SHOPIFY_Y,\n        cookies[SHOPIFY_Y] || buildUUID(),\n        longTermLength,\n        domainWithLeadingDot,\n      );\n      setCookie(\n        SHOPIFY_S,\n        cookies[SHOPIFY_S] || buildUUID(),\n        shortTermLength,\n        domainWithLeadingDot,\n      );\n    } else {\n      setCookie(SHOPIFY_Y, '', 0, domainWithLeadingDot);\n      setCookie(SHOPIFY_S, '', 0, domainWithLeadingDot);\n    }\n  }, [options, hasUserConsent, domain, checkoutDomain]);\n}"
          },
          "UseShopifyCookiesOptions": {
            "filePath": "src/useShopifyCookies.tsx",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "UseShopifyCookiesOptions",
            "value": "{\n  /**\n   * If set to `false`, Shopify cookies will be removed.\n   * If set to `true`, Shopify unique user token cookie will have cookie expiry of 1 year.\n   * Defaults to false.\n   **/\n  hasUserConsent?: boolean;\n  /**\n   * The domain scope of the cookie. Defaults to empty string.\n   **/\n  domain?: string;\n  /**\n   * The checkout domain of the shop. Defaults to empty string. If set, the cookie domain will check if it can be set with the checkout domain.\n   */\n  checkoutDomain?: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/useShopifyCookies.tsx",
                "syntaxKind": "PropertySignature",
                "name": "checkoutDomain",
                "value": "string",
                "description": "The checkout domain of the shop. Defaults to empty string. If set, the cookie domain will check if it can be set with the checkout domain.",
                "isOptional": true
              },
              {
                "filePath": "src/useShopifyCookies.tsx",
                "syntaxKind": "PropertySignature",
                "name": "domain",
                "value": "string",
                "description": "The domain scope of the cookie. Defaults to empty string.",
                "isOptional": true
              },
              {
                "filePath": "src/useShopifyCookies.tsx",
                "syntaxKind": "PropertySignature",
                "name": "hasUserConsent",
                "value": "boolean",
                "description": "If set to `false`, Shopify cookies will be removed. If set to `true`, Shopify unique user token cookie will have cookie expiry of 1 year. Defaults to false.",
                "isOptional": true
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "flattenConnection",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "\n    The `flattenConnection` utility transforms a connection object from the Storefront API (for example, [Product-related connections](https://shopify.dev/api/storefront/reference/products/product)) into a flat array of nodes. The utility works with either `nodes` or `edges.node`.\n\nIf `connection` is null or undefined, will return an empty array instead in production. In development, an error will be thrown.\n  ",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {flattenConnection} from '@shopify/hydrogen';\n\nexport function ProductList({productConnection}) {\n  const products = flattenConnection(productConnection);\n  return (\n    &lt;ul&gt;\n      {products.map((product) =&gt; (\n        &lt;li key={product.id}&gt;{product.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {flattenConnection} from '@shopify/hydrogen';\nimport type {ProductConnection} from '@shopify/hydrogen/storefront-api-types';\n\nexport function ProductList({\n  productConnection,\n}: {\n  productConnection: ProductConnection;\n}) {\n  const products = flattenConnection(productConnection);\n  return (\n    &lt;ul&gt;\n      {products.map((product) =&gt; (\n        &lt;li key={product.id}&gt;{product.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Parameters",
        "description": "",
        "type": "ConnectionGenericForDoc",
        "typeDefinitions": {
          "ConnectionGenericForDoc": {
            "filePath": "src/flatten-connection.ts",
            "name": "ConnectionGenericForDoc",
            "description": "",
            "members": [
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "PropertySignature",
                "name": "connection",
                "value": "ConnectionEdges | ConnectionNodes",
                "description": "",
                "isOptional": true
              }
            ],
            "value": "export interface ConnectionGenericForDoc {\n  connection?: ConnectionEdges | ConnectionNodes;\n}"
          },
          "ConnectionEdges": {
            "filePath": "src/flatten-connection.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ConnectionEdges",
            "value": "{\n  edges: Array<{node: unknown}>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "PropertySignature",
                "name": "edges",
                "value": "Array<{node: unknown}>",
                "description": ""
              }
            ]
          },
          "ConnectionNodes": {
            "filePath": "src/flatten-connection.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ConnectionNodes",
            "value": "{\n  nodes: Array<unknown>;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "PropertySignature",
                "name": "nodes",
                "value": "Array<unknown>",
                "description": ""
              }
            ]
          }
        }
      },
      {
        "title": "Returns",
        "description": "",
        "type": "FlattenConnectionReturnForDoc",
        "typeDefinitions": {
          "FlattenConnectionReturnForDoc": {
            "filePath": "src/flatten-connection.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "FlattenConnectionReturnForDoc",
            "value": "Array<unknown>",
            "description": "",
            "members": [
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "__@iterator@450",
                "value": "() => IterableIterator<unknown>",
                "description": "Iterator"
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "PropertySignature",
                "name": "__@unscopables@452",
                "value": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; splice?: boolean; unshift?: boolean; indexOf?: boolean; lastIndexOf?: boolean; every?: boolean; some?: boolean; forEach?: boolean; map?: boolean; filter?: boolean; reduce?: boolean; reduceRight?: boolean; find?: boolean; findIndex?: boolean; fill?: boolean; copyWithin?: boolean; entries?: boolean; keys?: boolean; values?: boolean; includes?: boolean; flatMap?: boolean; flat?: boolean; [Symbol.iterator]?: boolean; readonly [Symbol.unscopables]?: boolean; at?: boolean; }",
                "description": "Is an object whose properties have the value 'true' when they will be absent when used in a 'with' statement."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "at",
                "value": "(index: number) => unknown",
                "description": "Takes an integer value and returns the item at that index, allowing for positive and negative integers. Negative integers count back from the last item in the array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "concat",
                "value": "{ (...items: ConcatArray<unknown>[]): unknown[]; (...items: unknown[]): unknown[]; }",
                "description": "Combines two or more arrays. This method returns a new array without modifying any existing arrays."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "copyWithin",
                "value": "(target: number, start: number, end?: number) => FlattenConnectionReturnForDoc",
                "description": "Returns the this object after copying a section of the array identified by start and end to the same array starting at position target"
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "entries",
                "value": "() => IterableIterator<[number, unknown]>",
                "description": "Returns an iterable of key, value pairs for every entry in the array"
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "every",
                "value": "{ <S extends unknown>(predicate: (value: unknown, index: number, array: unknown[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any): boolean; }",
                "description": "Determines whether all the members of an array satisfy the specified test."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "fill",
                "value": "(value: unknown, start?: number, end?: number) => FlattenConnectionReturnForDoc",
                "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array"
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "filter",
                "value": "{ <S extends unknown>(predicate: (value: unknown, index: number, array: unknown[]) => value is S, thisArg?: any): S[]; (predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any): unknown[]; }",
                "description": "Returns the elements of an array that meet the condition specified in a callback function."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "find",
                "value": "{ <S extends unknown>(predicate: (value: unknown, index: number, obj: unknown[]) => value is S, thisArg?: any): S; (predicate: (value: unknown, index: number, obj: unknown[]) => unknown, thisArg?: any): unknown; }",
                "description": "Returns the value of the first element in the array where predicate is true, and undefined otherwise."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "findIndex",
                "value": "(predicate: (value: unknown, index: number, obj: unknown[]) => unknown, thisArg?: any) => number",
                "description": "Returns the index of the first element in the array where predicate is true, and -1 otherwise."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "flat",
                "value": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
                "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "flatMap",
                "value": "<U, This = undefined>(callback: (this: This, value: unknown, index: number, array: unknown[]) => U | readonly U[], thisArg?: This) => U[]",
                "description": "Calls a defined callback function on each element of an array. Then, flattens the result into a new array. This is identical to a map followed by flat with depth 1."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "forEach",
                "value": "(callbackfn: (value: unknown, index: number, array: unknown[]) => void, thisArg?: any) => void",
                "description": "Performs the specified action for each element in an array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "includes",
                "value": "(searchElement: unknown, fromIndex?: number) => boolean",
                "description": "Determines whether an array includes a certain element, returning true or false as appropriate."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "indexOf",
                "value": "(searchElement: unknown, fromIndex?: number) => number",
                "description": "Returns the index of the first occurrence of a value in an array, or -1 if it is not present."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "join",
                "value": "(separator?: string) => string",
                "description": "Adds all the elements of an array into a string, separated by the specified separator string."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "keys",
                "value": "() => IterableIterator<number>",
                "description": "Returns an iterable of keys in the array"
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "lastIndexOf",
                "value": "(searchElement: unknown, fromIndex?: number) => number",
                "description": "Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "PropertySignature",
                "name": "length",
                "value": "number",
                "description": "Gets or sets the length of the array. This is a number one higher than the highest index in the array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "map",
                "value": "<U>(callbackfn: (value: unknown, index: number, array: unknown[]) => U, thisArg?: any) => U[]",
                "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "pop",
                "value": "() => unknown",
                "description": "Removes the last element from an array and returns it. If the array is empty, undefined is returned and the array is not modified."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "push",
                "value": "(...items: unknown[]) => number",
                "description": "Appends new elements to the end of an array, and returns the new length of the array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "reduce",
                "value": "{ (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown): unknown; (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown, initialValue: unknown): unknown; <U>(callbackfn: (previousValue: U, currentValue: unknown, currentIndex: number, array: unknown[]) => U, initialValue: U): U; }",
                "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "reduceRight",
                "value": "{ (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown): unknown; (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown, initialValue: unknown): unknown; <U>(callbackfn: (previousValue: U, currentValue: unknown, currentIndex: number, array: unknown[]) => U, initialValue: U): U; }",
                "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "reverse",
                "value": "() => unknown[]",
                "description": "Reverses the elements in an array in place. This method mutates the array and returns a reference to the same array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "shift",
                "value": "() => unknown",
                "description": "Removes the first element from an array and returns it. If the array is empty, undefined is returned and the array is not modified."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "slice",
                "value": "(start?: number, end?: number) => unknown[]",
                "description": "Returns a copy of a section of an array. For both start and end, a negative index can be used to indicate an offset from the end of the array. For example, -2 refers to the second to last element of the array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "some",
                "value": "(predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any) => boolean",
                "description": "Determines whether the specified callback function returns true for any element of an array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "sort",
                "value": "(compareFn?: (a: unknown, b: unknown) => number) => FlattenConnectionReturnForDoc",
                "description": "Sorts an array in place. This method mutates the array and returns a reference to the same array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "splice",
                "value": "{ (start: number, deleteCount?: number): unknown[]; (start: number, deleteCount: number, ...items: unknown[]): unknown[]; }",
                "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "toLocaleString",
                "value": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
                "description": "Returns a string representation of an array. The elements are converted to string using their toLocaleString methods."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "toString",
                "value": "() => string",
                "description": "Returns a string representation of an array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "unshift",
                "value": "(...items: unknown[]) => number",
                "description": "Inserts new elements at the start of an array, and returns the new length of the array."
              },
              {
                "filePath": "src/flatten-connection.ts",
                "syntaxKind": "MethodSignature",
                "name": "values",
                "value": "() => IterableIterator<unknown>",
                "description": "Returns an iterable of values in the array"
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getClientBrowserParameters",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "subtitle": "Utility",
        "name": "sendShopifyAnalytics",
        "url": "/api/hydrogen/utilities/sendShopifyAnalytics",
        "type": "gear"
      },
      {
        "subtitle": "Hook",
        "name": "useShopifyCookies",
        "url": "/api/hydrogen/hooks/useShopifyCookies",
        "type": "tool"
      }
    ],
    "description": "Gathers client browser values commonly used for analytics",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import * as React from 'react';\nimport {useEffect} from 'react';\nimport {getClientBrowserParameters} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useEffect(() =&gt; {\n    getClientBrowserParameters();\n  });\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import * as React from 'react';\nimport {useEffect} from 'react';\nimport {getClientBrowserParameters} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useEffect(() =&gt; {\n    getClientBrowserParameters();\n  });\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "getClientBrowserParameters",
        "description": "If executed on server, this method will return empty string for each field.",
        "type": "GetClientBrowserParametersGeneratedType",
        "typeDefinitions": {
          "GetClientBrowserParametersGeneratedType": {
            "filePath": "src/analytics.ts",
            "name": "GetClientBrowserParametersGeneratedType",
            "description": "",
            "params": [],
            "returns": {
              "filePath": "src/analytics.ts",
              "description": "",
              "name": "ClientBrowserParameters",
              "value": "ClientBrowserParameters"
            },
            "value": "export function getClientBrowserParameters(): ClientBrowserParameters {\n  if (errorIfServer('getClientBrowserParameters')) {\n    return {\n      uniqueToken: '',\n      visitToken: '',\n      url: '',\n      path: '',\n      search: '',\n      referrer: '',\n      title: '',\n      userAgent: '',\n      navigationType: '',\n      navigationApi: '',\n    };\n  }\n\n  const [navigationType, navigationApi] = getNavigationType();\n  const cookies = getShopifyCookies(document.cookie);\n\n  return {\n    uniqueToken: cookies[SHOPIFY_Y],\n    visitToken: cookies[SHOPIFY_S],\n    url: location.href,\n    path: location.pathname,\n    search: location.search,\n    referrer: document.referrer,\n    title: document.title,\n    userAgent: navigator.userAgent,\n    navigationType,\n    navigationApi,\n  };\n}"
          },
          "ClientBrowserParameters": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ClientBrowserParameters",
            "value": "{\n  /**\n   * Shopify unique user token: Value of `_shopify_y` cookie.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  uniqueToken: string;\n  /**\n   * Shopify session token: Value of `_shopify_s` cookie.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  visitToken: string;\n  /**\n   * Value of `window.location.href`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  url: string;\n  /**\n   * Value of `window.location.pathname`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  path: string;\n  /**\n   * Value of `window.location.search`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  search: string;\n  /**\n   * Value of `window.document.referrer`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  referrer: string;\n  /**\n   * Value of `document.title`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  title: string;\n  /**\n   * Value of `navigator.userAgent`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  userAgent: string;\n  /**\n   * Navigation type: `'navigate' | 'reload' | 'back_forward' | 'prerender' | 'unknown'`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  navigationType: string;\n  /**\n   * Navigation api: `'PerformanceNavigationTiming' | 'performance.navigation'`.\n   *\n   * Use `getClientBrowserParameters()` to collect this value.\n   **/\n  navigationApi: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationApi",
                "value": "string",
                "description": "Navigation api: `'PerformanceNavigationTiming' | 'performance.navigation'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationType",
                "value": "string",
                "description": "Navigation type: `'navigate' | 'reload' | 'back_forward' | 'prerender' | 'unknown'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "Value of `window.location.pathname`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "referrer",
                "value": "string",
                "description": "Value of `window.document.referrer`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "search",
                "value": "string",
                "description": "Value of `window.location.search`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string",
                "description": "Value of `document.title`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uniqueToken",
                "value": "string",
                "description": "Shopify unique user token: Value of `_shopify_y` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "Value of `window.location.href`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userAgent",
                "value": "string",
                "description": "Value of `navigator.userAgent`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "visitToken",
                "value": "string",
                "description": "Shopify session token: Value of `_shopify_s` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "getShopifyCookies",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "subtitle": "Hook",
        "name": "useShopifyCookies",
        "url": "/api/hydrogen/hooks/useShopifyCookies",
        "type": "tool"
      }
    ],
    "description": "Parses cookie string and returns Shopify cookies.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import * as React from 'react';\nimport {useEffect} from 'react';\nimport {getShopifyCookies} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useEffect(() =&gt; {\n    getShopifyCookies(document.cookie);\n  });\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import * as React from 'react';\nimport {useEffect} from 'react';\nimport {getShopifyCookies} from '@shopify/hydrogen';\n\nexport default function App({Component, pageProps}) {\n  useEffect(() =&gt; {\n    getShopifyCookies(document.cookie);\n  });\n\n  return &lt;Component {...pageProps} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "getShopifyCookies",
        "description": "If the Shopify cookies doesn't exist, this method will return empty string for each missing cookie.",
        "type": "GetShopifyCookiesGeneratedType",
        "typeDefinitions": {
          "GetShopifyCookiesGeneratedType": {
            "filePath": "src/cookies-utils.tsx",
            "name": "GetShopifyCookiesGeneratedType",
            "description": "",
            "params": [
              {
                "name": "cookies",
                "description": "",
                "value": "string",
                "filePath": "src/cookies-utils.tsx"
              }
            ],
            "returns": {
              "filePath": "src/cookies-utils.tsx",
              "description": "",
              "name": "ShopifyCookies",
              "value": "ShopifyCookies"
            },
            "value": "export function getShopifyCookies(cookies: string): ShopifyCookies {\n  const cookieData = parse(cookies);\n  return {\n    [SHOPIFY_Y]: cookieData[SHOPIFY_Y] || '',\n    [SHOPIFY_S]: cookieData[SHOPIFY_S] || '',\n  };\n}"
          },
          "ShopifyCookies": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyCookies",
            "value": "{\n  /** Shopify unique user token: Value of `_shopify_y` cookie. */\n  [SHOPIFY_Y]: string;\n  /** Shopify session token: Value of `_shopify_s` cookie. */\n  [SHOPIFY_S]: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "_shopify_s",
                "value": "string",
                "description": "Shopify session token: Value of `_shopify_s` cookie."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "_shopify_y",
                "value": "string",
                "description": "Shopify unique user token: Value of `_shopify_y` cookie."
              }
            ]
          }
        }
      },
      {
        "title": "ShopifyCookies",
        "description": "Shopify cookies names",
        "type": "ShopifyCookies",
        "typeDefinitions": {
          "ShopifyCookies": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyCookies",
            "value": "{\n  /** Shopify unique user token: Value of `_shopify_y` cookie. */\n  [SHOPIFY_Y]: string;\n  /** Shopify session token: Value of `_shopify_s` cookie. */\n  [SHOPIFY_S]: string;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "_shopify_s",
                "value": "string",
                "description": "Shopify session token: Value of `_shopify_s` cookie."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "_shopify_y",
                "value": "string",
                "description": "Shopify unique user token: Value of `_shopify_y` cookie."
              }
            ]
          }
        }
      }
    ]
  },
  {
    "name": "parseMetafield",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "\n    A function that uses `metafield.type` to parse the Metafield's `value` or `reference` or `references` (depending on the `metafield.type`) and places the result in `metafield.parsedValue`.\n  ",
    "type": "gear",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {parseMetafield} from '@shopify/hydrogen';\n\nexport function DateMetafield({metafield}) {\n  const parsedMetafield = parseMetafield(metafield);\n\n  return &lt;div&gt;Date: {parsedMetafield.parsedValue?.toDateString()}&lt;/div&gt;;\n}\n\nexport function VariantReferenceMetafield({metafield}) {\n  const parsedMetafield = parseMetafield(metafield);\n\n  return &lt;div&gt;Variant title: {parsedMetafield.parsedValue?.title}&lt;/div&gt;;\n}\n\nexport function ListCollectionReferenceMetafield({metafield}) {\n  const parsedMetafield = parseMetafield(metafield);\n\n  return (\n    &lt;div&gt;\n      The first collection title: {parsedMetafield.parsedValue?.[0].title}\n    &lt;/div&gt;\n  );\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import {parseMetafield, type ParsedMetafields} from '@shopify/hydrogen';\nimport type {Metafield} from '@shopify/hydrogen/storefront-api-types';\n\nexport function DateMetafield({metafield}: {metafield: Metafield}) {\n  const parsedMetafield = parseMetafield&lt;ParsedMetafields['date']&gt;(metafield);\n\n  return &lt;div&gt;Date: {parsedMetafield.parsedValue?.toDateString()}&lt;/div&gt;;\n}\n\nexport function VariantReferenceMetafield({metafield}: {metafield: Metafield}) {\n  const parsedMetafield =\n    parseMetafield&lt;ParsedMetafields['variant_reference']&gt;(metafield);\n\n  return &lt;div&gt;Variant title: {parsedMetafield.parsedValue?.title}&lt;/div&gt;;\n}\n\nexport function ListCollectionReferenceMetafield({\n  metafield,\n}: {\n  metafield: Metafield;\n}) {\n  const parsedMetafield =\n    parseMetafield&lt;ParsedMetafields['list.collection_reference']&gt;(metafield);\n\n  return (\n    &lt;div&gt;\n      The first collection title: {parsedMetafield.parsedValue?.[0].title}\n    &lt;/div&gt;\n  );\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "Use the `ParsedMetafields` type as the returned type of `parseMetafield(metafield)`",
        "type": "ParseMetafieldGeneratedType",
        "typeDefinitions": {
          "ParseMetafieldGeneratedType": {
            "filePath": "src/parse-metafield.ts",
            "name": "ParseMetafieldGeneratedType",
            "description": "A function that uses `metafield.type` to parse the Metafield's `value` or `reference` or `references` (depending on the `metafield.type`) and places the result in `metafield.parsedValue`\n\nTypeScript developers can use the type `ParsedMetafields` from this package to get the returned object's type correct. For example:\n\n``` parseMetafield<ParsedMetafields['boolean']>({type: 'boolean', value: 'false'} ```",
            "params": [
              {
                "name": "metafield",
                "description": "",
                "value": "PartialObjectDeep<Metafield, { recurseIntoArrays: true; }>",
                "filePath": "src/parse-metafield.ts"
              }
            ],
            "returns": {
              "filePath": "src/parse-metafield.ts",
              "description": "",
              "name": "ReturnGeneric",
              "value": "ReturnGeneric"
            },
            "value": "export function parseMetafield<ReturnGeneric>(\n  metafield: PartialDeep<MetafieldBaseType, {recurseIntoArrays: true}>,\n): ReturnGeneric {\n  if (!metafield.type) {\n    const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;\n    if (__HYDROGEN_DEV__) {\n      throw new Error(noTypeError);\n    } else {\n      console.error(`${noTypeError} Returning 'parsedValue' of 'null'`);\n      return {\n        ...metafield,\n        parsedValue: null,\n      } as ReturnGeneric;\n    }\n  }\n\n  switch (metafield.type) {\n    case 'boolean':\n      return {\n        ...metafield,\n        parsedValue: metafield.value === 'true',\n      } as ReturnGeneric;\n\n    case 'collection_reference':\n    case 'file_reference':\n    case 'page_reference':\n    case 'product_reference':\n    case 'variant_reference':\n      return {\n        ...metafield,\n        parsedValue: metafield.reference,\n      } as ReturnGeneric;\n\n    case 'color':\n    case 'multi_line_text_field':\n    case 'single_line_text_field':\n    case 'url':\n      return {\n        ...metafield,\n        parsedValue: metafield.value,\n      } as ReturnGeneric;\n\n    // TODO: 'money' should probably be parsed even further to like `useMoney()`, but that logic needs to be extracted first so it's not a hook\n    case 'dimension':\n    case 'money':\n    case 'json':\n    case 'rating':\n    case 'volume':\n    case 'weight':\n    case 'rich_text_field':\n    case 'list.color':\n    case 'list.dimension':\n    case 'list.number_integer':\n    case 'list.number_decimal':\n    case 'list.rating':\n    case 'list.single_line_text_field':\n    case 'list.url':\n    case 'list.volume':\n    case 'list.weight': {\n      let parsedValue = null;\n      try {\n        parsedValue = parseJSON(metafield.value ?? '');\n      } catch (err) {\n        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;\n        if (__HYDROGEN_DEV__) {\n          throw new Error(parseError);\n        } else {\n          console.error(`${parseError} Returning 'null' for 'parsedValue'`);\n        }\n        parsedValue = null;\n      }\n      return {\n        ...metafield,\n        parsedValue,\n      } as ReturnGeneric;\n    }\n\n    case 'date':\n    case 'date_time':\n      return {\n        ...metafield,\n        parsedValue: new Date(metafield.value ?? ''),\n      } as ReturnGeneric;\n\n    case 'list.date':\n    case 'list.date_time': {\n      const jsonParseValue = parseJSON(metafield?.value ?? '') as string[];\n      return {\n        ...metafield,\n        parsedValue: jsonParseValue.map((dateString) => new Date(dateString)),\n      } as ReturnGeneric;\n    }\n\n    case 'number_decimal':\n    case 'number_integer':\n      return {\n        ...metafield,\n        parsedValue: Number(metafield.value),\n      } as ReturnGeneric;\n\n    case 'list.collection_reference':\n    case 'list.file_reference':\n    case 'list.page_reference':\n    case 'list.product_reference':\n    case 'list.variant_reference':\n      return {\n        ...metafield,\n        parsedValue: flattenConnection(metafield.references ?? undefined),\n      } as ReturnGeneric;\n\n    default: {\n      const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: \"${metafield.type}\". If you believe this is an error, please open an issue on GitHub.`;\n      if (__HYDROGEN_DEV__) {\n        throw new Error(typeNotFoundError);\n      } else {\n        console.error(\n          `${typeNotFoundError}  Returning 'parsedValue' of 'null'`,\n        );\n        return {\n          ...metafield,\n          parsedValue: null,\n        } as ReturnGeneric;\n      }\n    }\n  }\n}"
          }
        }
      }
    ]
  },
  {
    "name": "sendShopifyAnalytics",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "subtitle": "Hook",
        "name": "useShopifyCookies",
        "url": "/api/hydrogen/hooks/useShopifyCookies",
        "type": "tool"
      },
      {
        "subtitle": "Utility",
        "name": "getClientBrowserParameters",
        "url": "/api/hydrogen/utilities/getclientbrowserparameters",
        "type": "gear"
      }
    ],
    "description": "Sends analytics to Shopify.",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {\n  sendShopifyAnalytics,\n  getClientBrowserParameters,\n  AnalyticsEventName,\n  useShopifyCookies,\n} from '@shopify/hydrogen';\nimport {useRouter} from 'next/router';\nimport {useEffect} from 'react';\n\nfunction sendPageView(analyticsPageData) {\n  const payload = {\n    ...getClientBrowserParameters(),\n    ...analyticsPageData,\n  };\n  sendShopifyAnalytics({\n    eventName: AnalyticsEventName.PAGE_VIEW,\n    payload,\n  });\n}\n\n// Hook into your router's page change events to fire this analytics event:\n// for example, in NextJS:\n\nconst analyticsShopData = {\n  shopId: 'gid://shopify/Shop/{your-shop-id}',\n  currency: 'USD',\n  acceptedLanguage: 'en',\n};\n\nexport default function App({Component, pageProps}) {\n  const router = useRouter();\n\n  // eslint-disable-next-line no-undef\n  const hasUserConsent = yourFunctionToDetermineIfUserHasConsent();\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const analytics = {\n    hasUserConsent,\n    ...analyticsShopData,\n    ...pageProps.analytics,\n  };\n  const pagePropsWithAppAnalytics = {\n    ...pageProps,\n    analytics,\n  };\n\n  useEffect(() =&gt; {\n    const handleRouteChange = () =&gt; {\n      sendPageView(analytics);\n    };\n\n    router.events.on('routeChangeComplete', handleRouteChange);\n\n    return () =&gt; {\n      router.events.off('routeChangeComplete', handleRouteChange);\n    };\n  }, [analytics, router.events]);\n\n  useShopifyCookies();\n\n  return &lt;Component {...pagePropsWithAppAnalytics} /&gt;;\n}\n",
            "language": "jsx"
          },
          {
            "title": "TypeScript",
            "code": "import * as React from 'react';\nimport {useEffect} from 'react';\nimport {\n  sendShopifyAnalytics,\n  getClientBrowserParameters,\n  AnalyticsEventName,\n  useShopifyCookies,\n} from '@shopify/hydrogen';\nimport {useRouter} from 'next/router';\n\nfunction sendPageView(analyticsPageData) {\n  const payload = {\n    ...getClientBrowserParameters(),\n    ...analyticsPageData,\n  };\n  sendShopifyAnalytics({\n    eventName: AnalyticsEventName.PAGE_VIEW,\n    payload,\n  });\n}\n\n// Hook into your router's page change events to fire this analytics event:\n// for example, in NextJS:\n\nconst analyticsShopData = {\n  shopId: 'gid://shopify/Shop/{your-shop-id}',\n  currency: 'USD',\n  acceptedLanguage: 'en',\n};\n\nexport default function App({Component, pageProps}) {\n  const router = useRouter();\n\n  // @ts-expect-error - this is an example, you should implement this function\n  const hasUserConsent = yourFunctionToDetermineIfUserHasConsent();\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const analytics = {\n    hasUserConsent,\n    ...analyticsShopData,\n    ...pageProps.analytics,\n  };\n  const pagePropsWithAppAnalytics = {\n    ...pageProps,\n    analytics,\n  };\n\n  useEffect(() =&gt; {\n    const handleRouteChange = () =&gt; {\n      sendPageView(analytics);\n    };\n\n    router.events.on('routeChangeComplete', handleRouteChange);\n\n    return () =&gt; {\n      router.events.off('routeChangeComplete', handleRouteChange);\n    };\n  }, [analytics, router.events]);\n\n  useShopifyCookies();\n\n  return &lt;Component {...pagePropsWithAppAnalytics} /&gt;;\n}\n",
            "language": "tsx"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "sendShopifyAnalytics",
        "description": "If `event.payload.hasUserConsent` is false, no analytics event will happen.",
        "type": "SendShopifyAnalyticsGeneratedType",
        "typeDefinitions": {
          "SendShopifyAnalyticsGeneratedType": {
            "filePath": "src/analytics.ts",
            "name": "SendShopifyAnalyticsGeneratedType",
            "description": "Set user and session cookies and refresh the expiry time",
            "params": [
              {
                "name": "event",
                "description": "The analytics event.",
                "value": "ShopifyAnalytics",
                "filePath": "src/analytics.ts"
              },
              {
                "name": "shopDomain",
                "description": "The Online Store domain to sent Shopify analytics under the same\ntop level domain.",
                "value": "string",
                "isOptional": true,
                "filePath": "src/analytics.ts"
              }
            ],
            "returns": {
              "filePath": "src/analytics.ts",
              "description": "",
              "name": "Promise<void>",
              "value": "Promise<void>"
            },
            "value": "export function sendShopifyAnalytics(\n  event: ShopifyAnalytics,\n  shopDomain?: string,\n): Promise<void> {\n  const {eventName, payload} = event;\n  if (!payload.hasUserConsent) return Promise.resolve();\n\n  let events: ShopifyMonorailEvent[] = [];\n  const pageViewPayload = payload as ShopifyPageViewPayload;\n\n  if (eventName === AnalyticsEventName.PAGE_VIEW) {\n    events = events.concat(\n      trekkiePageView(pageViewPayload),\n      customerPageView(pageViewPayload),\n    );\n  } else if (eventName === AnalyticsEventName.ADD_TO_CART) {\n    events = events.concat(\n      customerAddToCart(payload as ShopifyAddToCartPayload),\n    );\n  } else if (eventName === AnalyticsEventName.PAGE_VIEW_2) {\n    events = events.concat(\n      trekkiePageView(pageViewPayload),\n      customerPageView2(pageViewPayload),\n    );\n  } else if (eventName === AnalyticsEventName.COLLECTION_VIEW) {\n    events = events.concat(customerCollectionView(pageViewPayload));\n  } else if (eventName === AnalyticsEventName.PRODUCT_VIEW) {\n    events = events.concat(customerProductView(pageViewPayload));\n  } else if (eventName === AnalyticsEventName.SEARCH_VIEW) {\n    events = events.concat(customerSearchView(pageViewPayload));\n  }\n\n  if (events.length) {\n    return sendToShopify(events, shopDomain);\n  } else {\n    return Promise.resolve();\n  }\n}"
          },
          "ShopifyAnalytics": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyAnalytics",
            "value": "ShopifyPageView | ShopifyAddToCart",
            "description": ""
          },
          "ShopifyPageView": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyPageView",
            "value": "{\n  /** Use `AnalyticsEventName.PAGE_VIEW` constant. */\n  eventName: string;\n  payload: ShopifyPageViewPayload;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "eventName",
                "value": "string",
                "description": "Use `AnalyticsEventName.PAGE_VIEW` constant."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "ShopifyPageViewPayload",
                "description": ""
              }
            ]
          },
          "ShopifyPageViewPayload": {
            "filePath": "src/analytics-types.ts",
            "name": "ShopifyPageViewPayload",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "acceptedLanguage",
                "value": "LanguageCode",
                "description": "Language displayed to buyer.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "analyticsAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.analyticsProcessingAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "assetVersionId",
                "value": "string",
                "description": "NPM package version of either hydrogen or hydrogen-react. Defaults to hydrogen-react package version.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "canonicalUrl",
                "value": "string",
                "description": "Canonical url.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "ccpaEnforced",
                "value": "boolean",
                "description": "Result of `!customerPrivacyApi.saleOfDataAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collectionHandle",
                "value": "string",
                "description": "Shopify collection handle.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "collectionId",
                "value": "string",
                "description": "Shopify collection id.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currency",
                "value": "CurrencyCode",
                "description": "Currency code."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerId",
                "value": "string",
                "description": "Shopify customer id in the form of `gid://shopify/Customer/<id>`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "gdprEnforced",
                "value": "boolean",
                "description": "Result of `!(customerPrivacyApi.marketingAllowed() && customerPrivacy.analyticsProcessingAllowed())`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasUserConsent",
                "value": "boolean",
                "description": "If we have consent from buyer for data collection"
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hydrogenSubchannelId",
                "value": "string",
                "description": "Alternative name for Shopify storefront id generated by Hydrogen sales channel. The value of env.PUBLIC_STOREFRONT_ID.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "marketingAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.marketingAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationApi",
                "value": "string",
                "description": "Navigation api: `'PerformanceNavigationTiming' | 'performance.navigation'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationType",
                "value": "string",
                "description": "Navigation type: `'navigate' | 'reload' | 'back_forward' | 'prerender' | 'unknown'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "pageType",
                "value": "string",
                "description": "Shopify page type.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "Value of `window.location.pathname`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "products",
                "value": "ShopifyAnalyticsProduct[]",
                "description": "Product list.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "referrer",
                "value": "string",
                "description": "Value of `window.document.referrer`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "resourceId",
                "value": "string",
                "description": "Shopify resource id in the form of `gid://shopify/<type>/<id>`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "saleOfDataAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.saleOfDataAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "search",
                "value": "string",
                "description": "Value of `window.location.search`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "searchString",
                "value": "string",
                "description": "Search term used on a search results page.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shopId",
                "value": "string",
                "description": "Shopify shop id in the form of `gid://shopify/Shop/<id>`."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shopifySalesChannel",
                "value": "ShopifySalesChannels",
                "description": "Shopify sales channel.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontId",
                "value": "string",
                "description": "Shopify storefront id generated by Hydrogen sales channel. The value of env.PUBLIC_STOREFRONT_ID.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string",
                "description": "Value of `document.title`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "totalValue",
                "value": "number",
                "description": "Total value of products.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uniqueToken",
                "value": "string",
                "description": "Shopify unique user token: Value of `_shopify_y` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "Value of `window.location.href`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userAgent",
                "value": "string",
                "description": "Value of `navigator.userAgent`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "visitToken",
                "value": "string",
                "description": "Shopify session token: Value of `_shopify_s` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              }
            ],
            "value": "export interface ShopifyPageViewPayload\n  extends ShopifyAnalyticsBase,\n    ClientBrowserParameters {\n  /** Canonical url. */\n  canonicalUrl?: string;\n  /** Shopify page type. */\n  pageType?: string;\n  /** Shopify resource id in the form of `gid://shopify/<type>/<id>`. */\n  resourceId?: string;\n  /** Shopify collection handle. */\n  collectionHandle?: string;\n  /** Shopify collection id. */\n  collectionId?: string;\n  /** Search term used on a search results page. */\n  searchString?: string;\n}"
          },
          "ShopifyAnalyticsProduct": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyAnalyticsProduct",
            "value": "{\n  /** Product id in the form of `gid://shopify/Product/<id>`. */\n  productGid: Product['id'];\n  /** Variant id in the form of `gid://shopify/ProductVariant/<id>`. */\n  variantGid?: ProductVariant['id'];\n  /** Product name. */\n  name: Product['title'];\n  /** Variant name. */\n  variantName?: ProductVariant['title'];\n  /** Product brand or vendor. */\n  brand: Product['vendor'];\n  /** Product category or type. */\n  category?: Product['productType'];\n  /** Product price. */\n  price: ProductVariant['price']['amount'];\n  /** Product sku. */\n  sku?: ProductVariant['sku'];\n  /** Quantity of the product in this event. */\n  quantity?: number;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "brand",
                "value": "string",
                "description": "Product brand or vendor."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "category",
                "value": "string",
                "description": "Product category or type.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "name",
                "value": "string",
                "description": "Product name."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "price",
                "value": "string",
                "description": "Product price."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "productGid",
                "value": "string",
                "description": "Product id in the form of `gid://shopify/Product/<id>`."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "quantity",
                "value": "number",
                "description": "Quantity of the product in this event.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "sku",
                "value": "string",
                "description": "Product sku.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variantGid",
                "value": "string",
                "description": "Variant id in the form of `gid://shopify/ProductVariant/<id>`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "variantName",
                "value": "string",
                "description": "Variant name.",
                "isOptional": true
              }
            ]
          },
          "ShopifySalesChannels": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifySalesChannels",
            "value": "keyof typeof ShopifySalesChannel",
            "description": ""
          },
          "ShopifySalesChannel": {
            "filePath": "src/analytics-constants.ts",
            "name": "ShopifySalesChannel",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "headless",
                "value": "\"headless\"",
                "description": "Shopify Headless sales channel"
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "hydrogen",
                "value": "\"hydrogen\"",
                "description": "Shopify Hydrogen sales channel"
              }
            ],
            "value": "export interface ShopifySalesChannel {\n  /** Shopify Hydrogen sales channel */\n  hydrogen: 'hydrogen';\n  /** Shopify Headless sales channel */\n  headless: 'headless';\n}"
          },
          "ShopifyAddToCart": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyAddToCart",
            "value": "{\n  /** Use `AnalyticsEventName.ADD_TO_CART` constant. */\n  eventName: string;\n  payload: ShopifyAddToCartPayload;\n}",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "eventName",
                "value": "string",
                "description": "Use `AnalyticsEventName.ADD_TO_CART` constant."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "payload",
                "value": "ShopifyAddToCartPayload",
                "description": ""
              }
            ]
          },
          "ShopifyAddToCartPayload": {
            "filePath": "src/analytics-types.ts",
            "name": "ShopifyAddToCartPayload",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "acceptedLanguage",
                "value": "LanguageCode",
                "description": "Language displayed to buyer.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "analyticsAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.analyticsProcessingAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "assetVersionId",
                "value": "string",
                "description": "NPM package version of either hydrogen or hydrogen-react. Defaults to hydrogen-react package version.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "cartId",
                "value": "string",
                "description": "Shopify cart id in the form of `gid://shopify/Cart/<id>`."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "ccpaEnforced",
                "value": "boolean",
                "description": "Result of `!customerPrivacyApi.saleOfDataAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "currency",
                "value": "CurrencyCode",
                "description": "Currency code."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "customerId",
                "value": "string",
                "description": "Shopify customer id in the form of `gid://shopify/Customer/<id>`.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "gdprEnforced",
                "value": "boolean",
                "description": "Result of `!(customerPrivacyApi.marketingAllowed() && customerPrivacy.analyticsProcessingAllowed())`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hasUserConsent",
                "value": "boolean",
                "description": "If we have consent from buyer for data collection"
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "hydrogenSubchannelId",
                "value": "string",
                "description": "Alternative name for Shopify storefront id generated by Hydrogen sales channel. The value of env.PUBLIC_STOREFRONT_ID.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "marketingAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.marketingAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationApi",
                "value": "string",
                "description": "Navigation api: `'PerformanceNavigationTiming' | 'performance.navigation'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "navigationType",
                "value": "string",
                "description": "Navigation type: `'navigate' | 'reload' | 'back_forward' | 'prerender' | 'unknown'`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "path",
                "value": "string",
                "description": "Value of `window.location.pathname`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "products",
                "value": "ShopifyAnalyticsProduct[]",
                "description": "Product list.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "referrer",
                "value": "string",
                "description": "Value of `window.document.referrer`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "saleOfDataAllowed",
                "value": "boolean",
                "description": "Result of `customerPrivacyApi.saleOfDataAllowed()`",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "search",
                "value": "string",
                "description": "Value of `window.location.search`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shopId",
                "value": "string",
                "description": "Shopify shop id in the form of `gid://shopify/Shop/<id>`."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "shopifySalesChannel",
                "value": "ShopifySalesChannels",
                "description": "Shopify sales channel.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "storefrontId",
                "value": "string",
                "description": "Shopify storefront id generated by Hydrogen sales channel. The value of env.PUBLIC_STOREFRONT_ID.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "title",
                "value": "string",
                "description": "Value of `document.title`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "totalValue",
                "value": "number",
                "description": "Total value of products.",
                "isOptional": true
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "uniqueToken",
                "value": "string",
                "description": "Shopify unique user token: Value of `_shopify_y` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "url",
                "value": "string",
                "description": "Value of `window.location.href`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "userAgent",
                "value": "string",
                "description": "Value of `navigator.userAgent`.\n\nUse `getClientBrowserParameters()` to collect this value."
              },
              {
                "filePath": "src/analytics-types.ts",
                "syntaxKind": "PropertySignature",
                "name": "visitToken",
                "value": "string",
                "description": "Shopify session token: Value of `_shopify_s` cookie.\n\nUse `getClientBrowserParameters()` to collect this value."
              }
            ],
            "value": "export interface ShopifyAddToCartPayload\n  extends ShopifyAnalyticsBase,\n    ClientBrowserParameters {\n  /** Shopify cart id in the form of `gid://shopify/Cart/<id>`. */\n  cartId: string;\n}"
          }
        }
      },
      {
        "title": "AnalyticsEventName",
        "description": "Analytics event names accepted by Shopify analytics.",
        "type": "AnalyticsEventName",
        "typeDefinitions": {
          "AnalyticsEventName": {
            "filePath": "src/analytics-constants.ts",
            "name": "AnalyticsEventName",
            "description": "These duplicated interface declaration is so that we can generate proper documentation for these public facing constants",
            "members": [
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "ADD_TO_CART",
                "value": "\"ADD_TO_CART\"",
                "description": "Add to cart"
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "PAGE_VIEW",
                "value": "\"PAGE_VIEW\"",
                "description": "Page view"
              }
            ],
            "value": "export interface AnalyticsEventName {\n  /** Page view */\n  PAGE_VIEW: 'PAGE_VIEW';\n  /** Add to cart */\n  ADD_TO_CART: 'ADD_TO_CART';\n}"
          }
        }
      },
      {
        "title": "AnalyticsPageType",
        "description": "Analytics page type values accepted by Shopify analytics.",
        "type": "AnalyticsPageType",
        "typeDefinitions": {
          "AnalyticsPageType": {
            "filePath": "src/analytics-constants.ts",
            "name": "AnalyticsPageType",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "article",
                "value": "\"article\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "blog",
                "value": "\"blog\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "captcha",
                "value": "\"captcha\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "cart",
                "value": "\"cart\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "collection",
                "value": "\"collection\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersAccount",
                "value": "\"customers/account\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersActivateAccount",
                "value": "\"customers/activate_account\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersAddresses",
                "value": "\"customers/addresses\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersLogin",
                "value": "\"customers/login\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersOrder",
                "value": "\"customers/order\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersRegister",
                "value": "\"customers/register\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "customersResetPassword",
                "value": "\"customers/reset_password\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "forbidden",
                "value": "\"403\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "giftCard",
                "value": "\"gift_card\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "home",
                "value": "\"index\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "listCollections",
                "value": "\"list-collections\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "notFound",
                "value": "\"404\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "page",
                "value": "\"page\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "password",
                "value": "\"password\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "policy",
                "value": "\"policy\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "product",
                "value": "\"product\"",
                "description": ""
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "search",
                "value": "\"search\"",
                "description": ""
              }
            ],
            "value": "export interface AnalyticsPageType {\n  article: 'article';\n  blog: 'blog';\n  captcha: 'captcha';\n  cart: 'cart';\n  collection: 'collection';\n  customersAccount: 'customers/account';\n  customersActivateAccount: 'customers/activate_account';\n  customersAddresses: 'customers/addresses';\n  customersLogin: 'customers/login';\n  customersOrder: 'customers/order';\n  customersRegister: 'customers/register';\n  customersResetPassword: 'customers/reset_password';\n  giftCard: 'gift_card';\n  home: 'index';\n  listCollections: 'list-collections';\n  forbidden: '403';\n  notFound: '404';\n  page: 'page';\n  password: 'password';\n  product: 'product';\n  policy: 'policy';\n  search: 'search';\n}"
          }
        }
      },
      {
        "title": "ShopifySalesChannel",
        "description": "Analytics sales channel values accepted by Shopify analytics.",
        "type": "ShopifySalesChannel",
        "typeDefinitions": {
          "ShopifySalesChannel": {
            "filePath": "src/analytics-constants.ts",
            "name": "ShopifySalesChannel",
            "description": "",
            "members": [
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "headless",
                "value": "\"headless\"",
                "description": "Shopify Headless sales channel"
              },
              {
                "filePath": "src/analytics-constants.ts",
                "syntaxKind": "PropertySignature",
                "name": "hydrogen",
                "value": "\"hydrogen\"",
                "description": "Shopify Hydrogen sales channel"
              }
            ],
            "value": "export interface ShopifySalesChannel {\n  /** Shopify Hydrogen sales channel */\n  hydrogen: 'hydrogen';\n  /** Shopify Headless sales channel */\n  headless: 'headless';\n}"
          }
        }
      }
    ]
  },
  {
    "name": "storefrontApiCustomScalars",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "Storefront Schema",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefront-schema"
      },
      {
        "name": "Storefront API Types",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefront-api-types"
      }
    ],
    "description": "\n    Meant to be used with GraphQL CodeGen to type the Storefront API's custom scalars correctly when using TypeScript.By default, GraphQL CodeGen uses `any` for custom scalars; by using these definitions, GraphQL Codegen will generate the correct types for the Storefront API's custom scalars.\n\nSee more about [GraphQL CodeGen](https://graphql-code-generator.com/) and [custom scalars for TypeScript](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript#scalars).\n\nNote that `@shopify/hydrogen-react` has already generated types for the Storefront API, so you may not need to setup GraphQL Codegen on your own.\n  ",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "Codegen Config",
            "code": "import {storefrontApiCustomScalars} from '@shopify/hydrogen';\n\nconst config = {\n  overwrite: true,\n  schema: require.resolve('@shopify/hydrogen/storefront.schema.json'),\n  documents: 'pages/**/*.tsx',\n  generates: {\n    './gql/': {\n      preset: 'client',\n      plugins: [],\n      config: {\n        // defines the custom scalars used in the Storefront API\n        scalars: storefrontApiCustomScalars,\n      },\n    },\n  },\n};\n\nexport default config;\n",
            "language": "js"
          }
        ],
        "title": "codegen.ts"
      }
    },
    "definitions": []
  },
  {
    "name": "parseGid",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [],
    "description": "\n    Parses [Shopify Global ID (GID)](https://shopify.dev/api/usage/gids) and returns the resource type and ID.\n  ",
    "type": "gear",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "JavaScript",
            "code": "import {parseGid} from '@shopify/hydrogen';\n\nconst {id, resource} = parseGid('gid://shopify/Order/123');\n\nconsole.log(id); // 123\nconsole.log(resource); // Order\n",
            "language": "js"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": [
      {
        "title": "Props",
        "description": "",
        "type": "ParseGidGeneratedType",
        "typeDefinitions": {
          "ParseGidGeneratedType": {
            "filePath": "src/analytics-utils.ts",
            "name": "ParseGidGeneratedType",
            "description": "Parses global id (gid) and returns the resource type and id.",
            "params": [
              {
                "name": "gid",
                "description": "A shopify GID (string)",
                "value": "string",
                "filePath": "src/analytics-utils.ts"
              }
            ],
            "returns": {
              "filePath": "src/analytics-utils.ts",
              "description": "",
              "name": "ShopifyGid",
              "value": "ShopifyGid"
            },
            "value": "export function parseGid(gid: string | undefined): ShopifyGid {\n  const defaultReturn: ShopifyGid = {\n    id: '',\n    resource: null,\n    resourceId: null,\n    search: '',\n    searchParams: new URLSearchParams(),\n    hash: '',\n  };\n\n  if (typeof gid !== 'string') {\n    return defaultReturn;\n  }\n\n  try {\n    const {search, searchParams, pathname, hash} = new URL(gid);\n    const pathnameParts = pathname.split('/');\n    const lastPathnamePart = pathnameParts[pathnameParts.length - 1];\n    const resourcePart = pathnameParts[pathnameParts.length - 2];\n\n    if (!lastPathnamePart || !resourcePart) {\n      return defaultReturn;\n    }\n\n    const id = `${lastPathnamePart}${search}${hash}` || '';\n    const resourceId = lastPathnamePart || null;\n    const resource = resourcePart ?? null;\n\n    return {id, resource, resourceId, search, searchParams, hash};\n  } catch {\n    return defaultReturn;\n  }\n}",
            "examples": [
              {
                "title": "Example",
                "description": "",
                "tabs": [
                  {
                    "code": "const {id, resource} = parseGid('gid://shopify/Order/123')\n// => id = \"123\", resource = 'Order'\n\n * const {id, resource} = parseGid('gid://shopify/Cart/abc123')\n// => id = \"abc123\", resource = 'Cart'",
                    "title": "Example"
                  }
                ]
              }
            ]
          },
          "ShopifyGid": {
            "filePath": "src/analytics-types.ts",
            "syntaxKind": "TypeAliasDeclaration",
            "name": "ShopifyGid",
            "value": "Pick<URL, 'search' | 'searchParams' | 'hash'> & {\n  id: string;\n  resource: string | null;\n  resourceId: string | null;\n}",
            "description": ""
          }
        }
      }
    ]
  },
  {
    "name": "Storefront Schema",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "storefrontApiCustomScalars",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefrontApiCustomScalars"
      },
      {
        "name": "Storefront API Types",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefront-api-types"
      }
    ],
    "description": "\n    Hydrogen React ships with a pre-generated GraphQL schema for the Storefront API, which can integrate with your IDE and other GraphQL tooling (such as a [GraphQL config file](https://www.graphql-config.com/docs/user/user-usage)) to provide autocompletion and validation for your Storefront API GraphQL queries.\n\nThis schema is generated using the Storefront API's introspection query, and is available at `@shopify/hydrogen-react/storefront.schema.json`.\n\nTo get these features working in your IDE, you may need to install an extension. For example, in VSCode you can install this [GraphQL extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql).\n  ",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "GraphQL Config File",
            "code": "schema: node_modules/@shopify/hydrogen/storefront.schema.json\n",
            "language": "yml"
          }
        ],
        "title": ".graphqlrc.yml"
      }
    },
    "definitions": []
  },
  {
    "name": "Storefront API Types",
    "category": "utilities",
    "isVisualComponent": false,
    "related": [
      {
        "name": "storefrontApiCustomScalars",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefrontApiCustomScalars"
      },
      {
        "name": "Storefront Schema",
        "type": "gear",
        "url": "/api/hydrogen/utilities/storefront-schema"
      }
    ],
    "description": "\n    If you are using TypeScript, pre-generated TypeScript types are available that match the Storefront API's GraphQL schema. These types can be used when you need to manually create an object that matches a Storefront API object's shape.\n\nThese types also work really well with the new [`satisfies` operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator) introduced in TypeScript 4.9, though you don't need to use `satisfies` to use these types.\n  ",
    "type": "utility",
    "defaultExample": {
      "description": "I am the default example",
      "codeblock": {
        "tabs": [
          {
            "title": "Storefront API Types in TypeScript",
            "code": "import type {\n  Product,\n  Collection,\n} from '@shopify/hydrogen/storefront-api-types';\n\nconst myProduct = {id: '123', title: 'My Product'} satisfies Partial&lt;Product&gt;;\nconsole.log(myProduct.title);\n\nconst myCollection = {\n  id: '456',\n  title: 'My Collection',\n} satisfies Partial&lt;Collection&gt;;\nconsole.log(myCollection.title);\n\nconst myNotSatisfyingProduct: Partial&lt;Product&gt; = {\n  id: '789',\n  title: 'Other Product',\n};\nconsole.log(myNotSatisfyingProduct.title);\n",
            "language": "ts"
          }
        ],
        "title": "Example code"
      }
    },
    "definitions": []
  }
]
