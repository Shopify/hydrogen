import {test, expect} from '@playwright/test';
import {
  PRIVACY_BANNER_DIALOG_ID,
  ANALYTICS_COOKIES,
  PERF_KIT_URL,
  MONORAIL_URL,
  GRAPHQL_URL,
  MOCK_VALUE_PATTERN,
  getServerTimingValues,
  waitForConsentResponse,
} from './specs/cookies/utils';

/**
 * This test verifies behavior when the privacy banner is disabled but the region
 * has a "no consent by default" policy configured in Shopify Admin.
 *
 * Server-timing values:
 * - Navigation entries: Generated by our Hydrogen server (optimistic tracking info)
 * - Resource entries: From Shopify's API responses (the authoritative values)
 *
 * Expected behavior:
 * - Server-timing values from Shopify (resource entries) should be mock values
 *   (00000000-0000-0000-5000-000000000000) indicating no consent in this region
 * - Since consent is not granted by default, no analytics cookies should be set
 *   (only _shopify_essential is allowed)
 * - No analytics requests should be made (Monorail, PerfKit)
 * - The privacy banner should not appear (disabled via route interception)
 */
test.describe('Consent Tracking - Decline (Privacy Banner Disabled)', () => {
  test('should have server-timing values but no analytics when privacy banner is disabled and region defaults to no consent', async ({
    page,
  }) => {
    // Track network requests
    const analyticsRequests: string[] = [];
    const perfKitRequests: string[] = [];
    let graphqlRequestCompleted = false;

    page.on('request', (request) => {
      const url = request.url();
      if (url.includes(MONORAIL_URL)) {
        analyticsRequests.push(url);
      }
      if (url.includes(PERF_KIT_URL)) {
        perfKitRequests.push(url);
      }
    });

    // Set up response listener for the consent GraphQL response
    const consentResponsePromise = waitForConsentResponse(page);

    // 0. Use route interception to disable the privacy banner by modifying the HTML
    // This replaces withPrivacyBanner from true to false in the serialized loader data
    await page.route('/', async (route) => {
      console.log('Intercepting main page to disable privacy banner');
      const response = await route.fetch();
      let body = await response.text();

      const originalBody = body;
      // Replace withPrivacyBanner from true to false to disable the privacy banner
      // The serialized format in turbo-stream is: "withPrivacyBanner\",true
      // (opening quote, key, escaped quote, comma, value)
      body = body
        // Format: "withPrivacyBanner\",true (turbo-stream with escaped quote before comma)
        .replace(/(withPrivacyBanner\\",)(true|false)/g, '$1false');

      console.log(
        'Modified page HTML to disable privacy banner:',
        originalBody !== body,
      );

      await route.fulfill({
        response,
        body,
        headers: {
          ...response.headers(),
        },
      });
    });

    // 1. Navigate to main page
    await page.goto('/');

    // Wait for the page to hydrate and initial requests to settle
    await page.waitForLoadState('networkidle');

    // 2. Check that server-timing values (_y and _s) are available via Performance API
    // Navigation entry values are generated by our Hydrogen server (optimistic)
    const navigationTimingValues = await getServerTimingValues(page);

    expect(
      navigationTimingValues._y,
      '_y value should be present in server-timing (navigation)',
    ).toBeTruthy();
    expect(
      navigationTimingValues._s,
      '_s value should be present in server-timing (navigation)',
    ).toBeTruthy();

    const consentResponse = await consentResponsePromise;
    expect(
      consentResponse.ok(),
      'Consent management request should succeed',
    ).toBe(true);

    // Verify server-timing values changed after consent
    // Wait for cookies to be updated and get new server timing
    await page.waitForLoadState('networkidle');

    // Get server-timing values from resource entries (Shopify's API responses)
    // These are the authoritative values that determine consent state
    const shopifyTimingValues = await getServerTimingValues(page, true);

    // Check if Shopify returned mock values (00000000-0000-0000-5000-...)
    // which indicates the server recognizes this as a "no consent by default" region
    expect(shopifyTimingValues._y, '_y value should be a mock value').toMatch(
      MOCK_VALUE_PATTERN,
    );
    expect(shopifyTimingValues._s, '_s value should be a mock value').toMatch(
      MOCK_VALUE_PATTERN,
    );

    // 3. Verify no analytics/marketing cookies are set (only _shopify_essential is allowed)
    const cookies = await page.context().cookies();
    for (const cookieName of ANALYTICS_COOKIES) {
      const cookie = cookies.find((c) => c.name.startsWith(cookieName));
      expect(
        cookie,
        `Cookie ${cookieName} should not be present when region defaults to no consent`,
      ).toBeUndefined();
    }

    // Note: _shopify_essential cookie IS allowed as it doesn't require consent

    // 4. Verify no analytics requests made
    expect(
      analyticsRequests,
      'No analytics requests should be made when privacy banner is disabled',
    ).toHaveLength(0);

    // 5. Verify perf-kit script is not downloaded yet
    expect(
      perfKitRequests,
      'Perf-kit script should not be downloaded when privacy banner is disabled',
    ).toHaveLength(0);

    // 6. Verify privacy banner never appears (wait 5 seconds to confirm)
    const privacyBanner = page.locator(`#${PRIVACY_BANNER_DIALOG_ID}`);

    // Wait a bit to ensure the banner has time to potentially appear
    await page.waitForTimeout(5000);

    await expect(
      privacyBanner,
      'Privacy banner should not appear when disabled',
    ).not.toBeVisible();

    // Verify still no analytics requests after waiting
    expect(
      analyticsRequests,
      'No analytics requests should be made after waiting',
    ).toHaveLength(0);

    const cookiesAfterWait = await page.context().cookies();
    for (const cookieName of ANALYTICS_COOKIES) {
      const cookie = cookiesAfterWait.find((c) =>
        c.name.startsWith(cookieName),
      );
      expect(
        cookie,
        `Cookie ${cookieName} should still not be present after waiting`,
      ).toBeUndefined();
    }

    expect(
      perfKitRequests,
      'Perf-kit script should still not be downloaded after waiting',
    ).toHaveLength(0);

    // 7. Navigate to first product and verify no analytics requests are made
    analyticsRequests.length = 0;
    perfKitRequests.length = 0;

    // Find and click on the first product link
    const productLink = page.locator('a[href*="/products/"]').first();
    await expect(productLink).toBeVisible({timeout: 10000});
    await productLink.click();

    // Wait for navigation and page to settle
    await page.waitForLoadState('networkidle');

    // Verify we're on a product page
    await expect(page).toHaveURL(/\/products\//);

    // Wait a bit for any potential analytics to fire
    await page.waitForTimeout(3000);

    // Verify no analytics cookies are set on product page
    const productPageCookies = await page.context().cookies();
    for (const cookieName of ANALYTICS_COOKIES) {
      const cookie = productPageCookies.find((c) =>
        c.name.startsWith(cookieName),
      );
      expect(
        cookie,
        `Cookie ${cookieName} should not be present on product page`,
      ).toBeUndefined();
    }

    // Verify no analytics requests were made during navigation
    expect(
      analyticsRequests,
      'No analytics requests should be made after navigating to product page',
    ).toHaveLength(0);

    // Verify perf-kit was not downloaded on product page
    expect(
      perfKitRequests,
      'Perf-kit script should not be downloaded on product page',
    ).toHaveLength(0);

    // Verify privacy banner still doesn't appear on product page
    const privacyBannerOnProduct = page.locator(`#${PRIVACY_BANNER_DIALOG_ID}`);
    await expect(
      privacyBannerOnProduct,
      'Privacy banner should not appear on product page',
    ).not.toBeVisible();
  });
});
