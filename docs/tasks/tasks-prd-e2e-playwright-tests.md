## Relevant Files

- `playwright.config.ts` – Playwright configuration shared by all tests (created).
- `e2e/tests/smoke.spec.ts` – Smoke-subset tests with placeholder test (created).
- `test/unit/scaffolding.spec.ts` – Unit test for E2E command scaffolding (moved from e2e/tests/).
- `test/unit/server.test.ts` – Unit test for server management helper (created).
- `package.json` – Added npm scripts `e2e` and `e2e:smoke` (modified).
- `e2e/helpers/server.ts` – Utility to start/stop the skeleton dev server programmatically (created - stub implementation).
- `e2e/tests/product-flow.spec.ts` – Product journey tests (to be created).
- `e2e/tests/cart-flow.spec.ts` – Cart journey tests (to be created).
- `e2e/tests/collection-flow.spec.ts` – Collection journey tests (to be created).
- `.github/workflows/e2e.yml` – GitHub Actions workflow to run the suite in CI (to be created).
- `docs/tasks/tasks-prd-e2e-playwright-tests.md` – This task list.

### Notes

- Follow outside-in TDD: write each failing Playwright test before implementing supporting helpers or configuration.
- Safe iteration: one failing test at a time; minimal code to pass.
- Verification: run `npm run e2e:smoke` for quick feedback, `npm run e2e` for the full suite.
- CI: the Github Actions workflow must block merges on failures and upload Playwright reports.
- Flake control: implement retries and trace capture on second failure.
- Extensibility: keep server URL and auth flags configurable via environment variables.

### Implementation Learnings

**Test Execution Context:**
- The project uses Vitest as the test runner (not Jest), accessible via `npx vitest run`
- No dedicated `npm run vitest` script exists; use `npx vitest run` directly for unit tests
- The main test script `npm test` runs via Turbo across all packages in parallel
- Pre-commit hooks automatically run prettier on TypeScript files, which may adjust formatting
- Unit tests for scaffolding can use `execSync` from child_process to verify npm script existence

**Project Structure:**
- This is a monorepo with packages/, templates/, and examples/ directories
- The skeleton template is located at templates/skeleton/
- The e2e/ directory should be created at the repository root level
- No existing e2e testing infrastructure was found

**Playwright Installation Notes:**
- Installation via `npm install -D @playwright/test` works smoothly
- Browser installation via `npx playwright install` runs silently (no output when successful)
- You can also install specific browsers: `npx playwright install chromium`
- Node version warnings may appear (undici requires 20.18.1+, project uses 20.12.2) but don't block functionality
- The project has many npm audit vulnerabilities but these don't affect Playwright setup

**Testing Workflow:**
- TDD approach working well: failing test written first, then implementation
- Test failures provide clear error messages showing missing npm scripts
- Use `npx vitest run <test-file>` for focused test runs during development

**Next Steps Considerations:**
- When installing Playwright, ensure compatibility with the existing Node version (.nvmrc specifies the version)
- The project uses npm (not yarn/pnpm) as evidenced by package-lock.json
- Consider how Playwright tests will integrate with the existing Turbo-based test pipeline
- The skeleton template dev server will need to be started programmatically for tests
- Playwright config file will need to be created manually (not auto-generated by install command)

**Key Implementation Insights (Sessions 1-2):**
- **Test Organization Critical**: Unit tests about the E2E setup (like scaffolding tests) must be kept separate from actual E2E tests. Playwright will try to run anything in the e2e/tests directory as a Playwright test, causing module import errors with Vitest tests.
- **Directory Structure**: Created `test/unit/` for unit tests about the E2E infrastructure, keeping `e2e/tests/` exclusively for Playwright tests
- **Playwright Exit Codes**: Playwright exits with status 1 when no tests are found. Need at least one test file with appropriate tags for commands to succeed.
- **Test Output Matching**: Playwright's actual output format differs from what might be expected. The HTML report message is "To open last HTML report run:" not "Playwright HTML report". Tests should match actual output.
- **Minimal Implementation Works**: Creating a placeholder test with just the `@smoke` tag was sufficient to make the scaffolding test pass, following TDD principles
- **Configuration Location**: `playwright.config.ts` must be at repository root, not in the e2e/ directory
- **HTML Report Path**: Playwright generates reports in `playwright-report/` directory by default, which the scaffolding test verifies exists

**Server Implementation Insights (Session 2):**
- **Stub Before Real Implementation**: Successfully used a mock HTTP server with child process stub to pass tests before implementing real skeleton server startup
- **Mock Server Pattern**: Using Node's built-in `http.createServer` for stub implementation provides a lightweight way to test server lifecycle without external dependencies
- **Port 0 Strategy**: Listening on port 0 lets the OS assign an available port, avoiding conflicts in parallel test runs
- **Cleanup Critical**: Server stop function must properly close HTTP server AND kill child process to avoid orphaned resources
- **Test Isolation**: Each test should get its own server instance - no shared state between tests
- **Next Steps for Real Implementation (2.3)**: Will need to:
  - Install `get-port` package for robust port selection
  - Install `execa` for better child process management
  - Find the actual skeleton template dev command (likely `npm run dev` in templates/skeleton/)
  - Wait for server readiness (not just process spawn, but actual HTTP availability)
  - Handle process errors and stdout/stderr for debugging
- **Current State**: Tasks 1 and 2.1-2.2 complete. Stub server implementation passes all tests. Ready for task 2.3 (real skeleton server implementation).

## Tasks

- [x] 1. Add Playwright and command scaffolding

  - [x] 1.1. Write a failing unit test (`e2e/tests/scaffolding.spec.ts`) asserting that the command `npm run e2e:smoke` exits with status 0 and prints the Playwright HTML report path.

  - [x] 1.2. Add Playwright as a dev dependency (`npm install -D @playwright/test`) and generate the default configuration via `npx playwright install` (expect the test to remain failing).

  - [x] 1.3. Add npm scripts `e2e` (full) and `e2e:smoke` (subset) in `package.json` that invoke `playwright test` with appropriate tags.

  - [x] 1.4. Run `npm run vitest e2e/tests/scaffolding.spec.ts` and implement minimal script/config changes until the test passes.

  - [x] 1.5. Verify by running `npm run e2e:smoke` locally.

- [ ] 2. Implement server management utilities

  - [x] 2.1. Write a failing unit test (`e2e/helpers/server.test.ts`) specifying that `startServer()` resolves with `{port, stop}` and that `GET /` responds 200 within 30 s.
    - **Note**: Based on test organization learnings, this unit test should likely go in `test/unit/` not `e2e/helpers/`

  - [x] 2.2. Stub the skeleton template start command with a mock child process; run the test (should still fail).
    - **Implementation**: Created stub server with mock HTTP server and child process in `e2e/helpers/server.ts` that passes all tests

  - [ ] 2.3. Implement `startServer()` in `e2e/helpers/server.ts` using `get-port` and `execa`, returning an async `stop()` handler.

  - [ ] 2.4. Ensure the helper tears down the process after tests to avoid orphaned ports.

  - [ ] 2.5. Run `npm run vitest e2e/helpers/server.test.ts` until all assertions pass.

  - [ ] 2.6. Verify by importing `startServer()` in a scratch script and confirming the server lifecycle.

- [ ] 3. Create smoke subset tests

  - [ ] 3.1. Write a failing Playwright test (`e2e/tests/smoke.spec.ts`) that launches the dev server via the helper, navigates to `/`, and asserts no console errors.

  - [ ] 3.2. Add selectors assertions: hero image, “Add to cart” button, login link, cart icon.

  - [ ] 3.3. Tag the test with `@smoke` and ensure `npm run e2e:smoke` only executes these.

  - [ ] 3.4. Implement minimal page fixes or selector utilities until the test passes.

  - [ ] 3.5. Verify by running `npm run e2e:smoke` locally (<60 s).

- [ ] 4. Implement full test suite (product, cart, collection flows)

  - [ ] 4.1. Write failing `product-flow.spec.ts` covering navigate to product, assert title/price, add to cart.

  - [ ] 4.2. Implement page object helpers (`e2e/page-objects/storefront.ts`) for common interactions.

  - [ ] 4.3. Write failing `cart-flow.spec.ts` to open cart, update quantity, assert subtotal, remove item.

  - [ ] 4.4. Write failing `collection-flow.spec.ts` to verify grid renders expected products.

  - [ ] 4.5. Implement test helpers and minimal fixes until each spec passes individually.

  - [ ] 4.6. Verify by running `npm run e2e` (≤15 min total).

- [ ] 5. Add retry and flake-control mechanisms

  - [ ] 5.1. Write a failing unit test asserting Playwright config has `retries: 1` for CI runs.

  - [ ] 5.2. Update `playwright.config.ts` to conditionally set retries and enable trace/screenshot on last retry.

  - [ ] 5.3. Implement cookie/localStorage clearing utility and integrate via `globalSetup`.

  - [ ] 5.4. Verify by intentionally failing a test and confirming retries & artifacts.

- [ ] 6. Integrate with GitHub Actions workflow

  - [ ] 6.1. Write a failing expect test (`.github/workflows/e2e.yml.test.ts`) that lints workflow YAML for required steps (`actions/setup-node`, browser install, `npm run e2e`).

  - [ ] 6.2. Add workflow file `.github/workflows/e2e.yml` using Playwright’s recommended template.

  - [ ] 6.3. Commit and push branch to trigger CI; ensure workflow blocks on failures and uploads reports.

  - [ ] 6.4. Verify by pushing a deliberate test failure and ensuring the workflow exits 1.

- [ ] 7. Scaffold extensibility hooks and skipped Customer Account API tests

  - [ ] 7.1. Create config helper to inject `STORE_URL` and other env vars.

  - [ ] 7.2. Add placeholder test `e2e/tests/customer-account.spec.ts` wrapped in `test.skip` gated by `process.env.SHOPIFY_HYDROGEN_FLAG_CUSTOMER_ACCOUNT_PUSH`.

  - [ ] 7.3. Document how to enable the flag and extend tests for real stores.

  - [ ] 7.4. Verify by running `npm run e2e` and ensuring skipped test counts appear.

- [ ] 8. Write documentation and onboarding instructions

  - [ ] 8.1. Update root `README.md` with E2E setup and troubleshooting section.

  - [ ] 8.2. Create `docs/e2e-playwright.md` detailing commands, environment variables, CI behaviour.

  - [ ] 8.3. Verify by having a new contributor run through the docs and successfully execute `npm run e2e`.

### AI Implementation Guidelines

Follow Outside-In TDD strictly:
1. Always write the failing test first.
2. Run the test to confirm it fails (and verify the failure is what you expect).
3. Write minimal code to pass.
4. Re-run the test to confirm it passes.
5. Proceed to the next behaviour.

**Practical TDD Tips:**
- When a test fails unexpectedly, run the command being tested manually to see actual output
- Don't assume output format - always verify actual command output first
- Keep unit tests about the infrastructure separate from actual E2E tests
- Placeholder implementations are fine for making tests pass initially

Safe Iteration Pattern:
- Ask the human to run tests after each implementation.
- Debug failing tests before changing code.
- Commit only when all tests pass.

Verification Step Protocol:
- Run the verification command at the end of each parent task.
- If verification fails, fix sub-tasks before marking complete.

External Service Integration:
- Stub network calls with Playwright’s route interception when needed.

When in Doubt:
- Prioritise passing tests over new features.
- Keep implementations simple.
