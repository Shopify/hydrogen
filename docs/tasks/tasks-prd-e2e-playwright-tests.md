## Relevant Files

- `playwright.config.ts` – Playwright configuration shared by all tests (created).
- `e2e/tests/smoke.spec.ts` – Smoke-subset tests with placeholder test (created).
- `test/unit/scaffolding.spec.ts` – Unit test for E2E command scaffolding (moved from e2e/tests/).
- `test/unit/server.test.ts` – Unit test for server management helper (created).
- `package.json` – Added npm scripts `e2e` and `e2e:smoke` (modified).
- `e2e/helpers/server.ts` – Utility to start/stop the skeleton dev server programmatically (created - stub implementation).
- `e2e/tests/product-flow.spec.ts` – Product journey tests (to be created).
- `e2e/tests/cart-flow.spec.ts` – Cart journey tests (to be created).
- `e2e/tests/collection-flow.spec.ts` – Collection journey tests (to be created).
- `.github/workflows/e2e.yml` – GitHub Actions workflow to run the suite in CI (to be created).
- `docs/tasks/tasks-prd-e2e-playwright-tests.md` – This task list.

### Notes

- Follow outside-in TDD: write each failing Playwright test before implementing supporting helpers or configuration.
- Safe iteration: one failing test at a time; minimal code to pass.
- Verification: run `npm run e2e:smoke` for quick feedback, `npm run e2e` for the full suite.
- CI: the Github Actions workflow must block merges on failures and upload Playwright reports.
- Flake control: implement retries and trace capture on second failure.
- Extensibility: keep server URL and auth flags configurable via environment variables.

### Environment Setup Reminders

**Before starting any E2E work:**
1. Ensure you're in the project root directory (not in templates/skeleton/)
2. Run `npm install` in both project root AND templates/skeleton/
3. Verify Playwright browsers are installed with `npx playwright install`
4. Check that the skeleton server can start manually before automating

**Common Gotchas to Watch For:**
- The skeleton server needs 10-15 seconds to start - don't assume it's broken if it doesn't respond immediately
- Use `npm --prefix <path>` to run npm commands in different directories without changing cwd
- The Shopify CLI hydrogen plugin outputs formatted success messages - parse carefully
- Vitest runs from the current directory - always check `pwd` before running tests
- Background processes need explicit cleanup - use KillBash or process.kill()

### Implementation Learnings

**Test Execution Context:**
- The project uses Vitest as the test runner (not Jest), accessible via `npx vitest run`
- No dedicated `npm run vitest` script exists; use `npx vitest run` directly for unit tests
- The main test script `npm test` runs via Turbo across all packages in parallel
- Pre-commit hooks automatically run prettier on TypeScript files, which may adjust formatting
- Unit tests for scaffolding can use `execSync` from child_process to verify npm script existence

**Project Structure:**
- This is a monorepo with packages/, templates/, and examples/ directories
- The skeleton template is located at templates/skeleton/
- The e2e/ directory should be created at the repository root level
- No existing e2e testing infrastructure was found

**Playwright Installation Notes:**
- Installation via `npm install -D @playwright/test` works smoothly
- Browser installation via `npx playwright install` runs silently (no output when successful)
- You can also install specific browsers: `npx playwright install chromium`
- Node version warnings may appear (undici requires 20.18.1+, project uses 20.12.2) but don't block functionality
- The project has many npm audit vulnerabilities but these don't affect Playwright setup

**Testing Workflow:**
- TDD approach working well: failing test written first, then implementation
- Test failures provide clear error messages showing missing npm scripts
- Use `npx vitest run <test-file>` for focused test runs during development

**Next Steps Considerations:**
- When installing Playwright, ensure compatibility with the existing Node version (.nvmrc specifies the version)
- The project uses npm (not yarn/pnpm) as evidenced by package-lock.json
- Consider how Playwright tests will integrate with the existing Turbo-based test pipeline
- The skeleton template dev server will need to be started programmatically for tests
- Playwright config file will need to be created manually (not auto-generated by install command)

**Future Implementation Reminders:**
- **Smoke Tests (Task 3)**: Will need to import the `startServer()` helper and use it in Playwright's test setup/teardown
- **Page Objects Pattern**: Consider creating reusable page object helpers early to avoid duplication across test files
- **Environment Variables**: The skeleton dev server may need specific env vars (NODE_ENV, etc.) - check what the actual dev command uses
- **Parallel Test Execution**: Since server startup is slow (15+ seconds), consider starting one server for all tests rather than per-test
- **CI Considerations**: GitHub Actions will need the monorepo built before running E2E tests - add build step to workflow
- **Flake Prevention**: Network requests to the dev server might be flaky initially - implement retry logic in test helpers

**Key Implementation Insights (Sessions 1-2):**
- **Test Organization Critical**: Unit tests about the E2E setup (like scaffolding tests) must be kept separate from actual E2E tests. Playwright will try to run anything in the e2e/tests directory as a Playwright test, causing module import errors with Vitest tests.
- **Directory Structure**: Created `test/unit/` for unit tests about the E2E infrastructure, keeping `e2e/tests/` exclusively for Playwright tests
- **Playwright Exit Codes**: Playwright exits with status 1 when no tests are found. Need at least one test file with appropriate tags for commands to succeed.
- **Test Output Matching**: Playwright's actual output format differs from what might be expected. The HTML report message is "To open last HTML report run:" not "Playwright HTML report". Tests should match actual output.
- **Minimal Implementation Works**: Creating a placeholder test with just the `@smoke` tag was sufficient to make the scaffolding test pass, following TDD principles
- **Configuration Location**: `playwright.config.ts` must be at repository root, not in the e2e/ directory
- **HTML Report Path**: Playwright generates reports in `playwright-report/` directory by default, which the scaffolding test verifies exists

**Server Implementation Insights (Sessions 2-3):**
- **Stub Before Real Implementation**: Successfully used a mock HTTP server with child process stub to pass tests before implementing real skeleton server startup
- **Mock Server Pattern**: Using Node's built-in `http.createServer` for stub implementation provides a lightweight way to test server lifecycle without external dependencies
- **Port 0 Strategy**: Listening on port 0 lets the OS assign an available port, avoiding conflicts in parallel test runs
- **Cleanup Critical**: Server stop function must properly close HTTP server AND kill child process to avoid orphaned resources
- **Test Isolation**: Each test should get its own server instance - no shared state between tests

**Real Server Implementation Learnings (Session 3):**
- **Working Directory Matters**: Always verify your current working directory with `pwd` before running commands - the skeleton template may be in a different location than expected
- **Port Passing Method**: Use `npm run dev -- --port <port>` format to pass CLI arguments through npm scripts to the underlying command
- **Server Startup Time**: Real skeleton dev server takes 10-15 seconds to start - tests need generous timeouts (90+ seconds) to avoid false failures
- **Dependencies First**: Always ensure `npm install` has been run in the skeleton template directory before attempting to start the server
- **Process Management**: Use `execa` with `reject: false` to prevent automatic rejection on non-zero exits, allowing graceful error handling
- **Readiness Check**: Don't just wait for the process to spawn - poll for HTTP 200 response to ensure the server is actually ready to handle requests
- **Shell Limitations**: The test environment's shell may not support `cd` in eval context - use absolute paths or `npm --prefix` instead
- **Background Process Testing**: Use the `run_in_background` flag for manual testing, then check output with BashOutput tool to debug server startup issues
- **Test Cleanup**: Always clean up servers in `afterEach` hooks to prevent port conflicts and orphaned processes between tests
- **Path Resolution**: Use `path.resolve(__dirname, '../../templates/skeleton')` to reliably find the skeleton template from the helper file location

**Session 4 - Critical Build Dependencies:**
- **Monorepo Build Required**: The skeleton template depends on built packages from the monorepo. Must run `npm run build` at the project root before the skeleton dev server can start
- **Missing Dependencies**: When tests fail with module import errors, check if dependencies like `execa` and `get-port` need to be installed at the project root level
- **Vitest Version**: The project uses Vitest v1.0.4 in the monorepo. Running `npx vitest` may install a different version locally - be aware of version differences
- **Shell Context Reset**: Some commands reset the shell's working directory. Always verify location after complex operations
- **Process Verification**: After implementing teardown, always verify with `ps aux | grep` that no orphaned processes remain
- **Test Execution Location**: Run tests from the project root, not from within subdirectories like templates/skeleton/, to ensure proper module resolution

## Tasks

- [x] 1. Add Playwright and command scaffolding

  - [x] 1.1. Write a failing unit test (`e2e/tests/scaffolding.spec.ts`) asserting that the command `npm run e2e:smoke` exits with status 0 and prints the Playwright HTML report path.

  - [x] 1.2. Add Playwright as a dev dependency (`npm install -D @playwright/test`) and generate the default configuration via `npx playwright install` (expect the test to remain failing).

  - [x] 1.3. Add npm scripts `e2e` (full) and `e2e:smoke` (subset) in `package.json` that invoke `playwright test` with appropriate tags.

  - [x] 1.4. Run `npm run vitest e2e/tests/scaffolding.spec.ts` and implement minimal script/config changes until the test passes.

  - [x] 1.5. Verify by running `npm run e2e:smoke` locally.

- [ ] 2. Implement server management utilities

  - [x] 2.1. Write a failing unit test (`e2e/helpers/server.test.ts`) specifying that `startServer()` resolves with `{port, stop}` and that `GET /` responds 200 within 30 s.
    - **Note**: Based on test organization learnings, this unit test should likely go in `test/unit/` not `e2e/helpers/`

  - [x] 2.2. Stub the skeleton template start command with a mock child process; run the test (should still fail).
    - **Implementation**: Created stub server with mock HTTP server and child process in `e2e/helpers/server.ts` that passes all tests

  - [x] 2.3. Implement `startServer()` in `e2e/helpers/server.ts` using `get-port` and `execa`, returning an async `stop()` handler.
    - **Implementation**: Successfully replaced stub with real implementation using get-port for port selection and execa for process management. Server starts skeleton template on available port and waits for HTTP 200 readiness.

  - [x] 2.4. Ensure the helper tears down the process after tests to avoid orphaned ports.
    - **Verification**: The existing implementation already includes proper teardown in the `stop` function that kills the server process with SIGTERM/SIGKILL. Tests have `afterEach` hooks that call `stop()`. Verified no orphaned processes remain after running tests.

  - [ ] 2.5. Run `npm run vitest e2e/helpers/server.test.ts` until all assertions pass.

  - [ ] 2.6. Verify by importing `startServer()` in a scratch script and confirming the server lifecycle.

- [ ] 3. Create smoke subset tests

  - [ ] 3.1. Write a failing Playwright test (`e2e/tests/smoke.spec.ts`) that launches the dev server via the helper, navigates to `/`, and asserts no console errors.

  - [ ] 3.2. Add selectors assertions: hero image, “Add to cart” button, login link, cart icon.

  - [ ] 3.3. Tag the test with `@smoke` and ensure `npm run e2e:smoke` only executes these.

  - [ ] 3.4. Implement minimal page fixes or selector utilities until the test passes.

  - [ ] 3.5. Verify by running `npm run e2e:smoke` locally (<60 s).

- [ ] 4. Implement full test suite (product, cart, collection flows)

  - [ ] 4.1. Write failing `product-flow.spec.ts` covering navigate to product, assert title/price, add to cart.

  - [ ] 4.2. Implement page object helpers (`e2e/page-objects/storefront.ts`) for common interactions.

  - [ ] 4.3. Write failing `cart-flow.spec.ts` to open cart, update quantity, assert subtotal, remove item.

  - [ ] 4.4. Write failing `collection-flow.spec.ts` to verify grid renders expected products.

  - [ ] 4.5. Implement test helpers and minimal fixes until each spec passes individually.

  - [ ] 4.6. Verify by running `npm run e2e` (≤15 min total).

- [ ] 5. Add retry and flake-control mechanisms

  - [ ] 5.1. Write a failing unit test asserting Playwright config has `retries: 1` for CI runs.

  - [ ] 5.2. Update `playwright.config.ts` to conditionally set retries and enable trace/screenshot on last retry.

  - [ ] 5.3. Implement cookie/localStorage clearing utility and integrate via `globalSetup`.

  - [ ] 5.4. Verify by intentionally failing a test and confirming retries & artifacts.

- [ ] 6. Integrate with GitHub Actions workflow

  - [ ] 6.1. Write a failing expect test (`.github/workflows/e2e.yml.test.ts`) that lints workflow YAML for required steps (`actions/setup-node`, browser install, `npm run e2e`).

  - [ ] 6.2. Add workflow file `.github/workflows/e2e.yml` using Playwright’s recommended template.

  - [ ] 6.3. Commit and push branch to trigger CI; ensure workflow blocks on failures and uploads reports.

  - [ ] 6.4. Verify by pushing a deliberate test failure and ensuring the workflow exits 1.

- [ ] 7. Scaffold extensibility hooks and skipped Customer Account API tests

  - [ ] 7.1. Create config helper to inject `STORE_URL` and other env vars.

  - [ ] 7.2. Add placeholder test `e2e/tests/customer-account.spec.ts` wrapped in `test.skip` gated by `process.env.SHOPIFY_HYDROGEN_FLAG_CUSTOMER_ACCOUNT_PUSH`.

  - [ ] 7.3. Document how to enable the flag and extend tests for real stores.

  - [ ] 7.4. Verify by running `npm run e2e` and ensuring skipped test counts appear.

- [ ] 8. Write documentation and onboarding instructions

  - [ ] 8.1. Update root `README.md` with E2E setup and troubleshooting section.

  - [ ] 8.2. Create `docs/e2e-playwright.md` detailing commands, environment variables, CI behaviour.

  - [ ] 8.3. Verify by having a new contributor run through the docs and successfully execute `npm run e2e`.

### AI Implementation Guidelines

Follow Outside-In TDD strictly:
1. Always write the failing test first.
2. Run the test to confirm it fails (and verify the failure is what you expect).
3. Write minimal code to pass.
4. Re-run the test to confirm it passes.
5. Proceed to the next behaviour.

**Practical TDD Tips:**
- When a test fails unexpectedly, run the command being tested manually to see actual output
- Don't assume output format - always verify actual command output first
- Keep unit tests about the infrastructure separate from actual E2E tests
- Placeholder implementations are fine for making tests pass initially

**Critical Debugging Patterns:**
- **Test Timeouts**: If tests timeout, first increase timeout to 90+ seconds, then debug the actual command
- **Path Issues**: Use absolute paths when relative paths fail, especially with npm commands
- **Process Debugging**: Run commands in background mode first to see actual output before implementing
- **Port Conflicts**: Always use dynamic port allocation (get-port) rather than hardcoded ports
- **Dependency Installation**: Check that `npm install` has been run in all necessary directories
- **Error Visibility**: Use `stdio: 'pipe'` to capture process output for debugging, not 'inherit'
- **Cleanup Pattern**: Store server references at test suite level and clean up in afterEach hooks

Safe Iteration Pattern:
- Ask the human to run tests after each implementation.
- Debug failing tests before changing code.
- Commit only when all tests pass.

Verification Step Protocol:
- Run the verification command at the end of each parent task.
- If verification fails, fix sub-tasks before marking complete.

External Service Integration:
- Stub network calls with Playwright’s route interception when needed.

When in Doubt:
- Prioritise passing tests over new features.
- Keep implementations simple.
