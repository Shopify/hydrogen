## Relevant Files

- `playwright.config.ts` – Playwright configuration shared by all tests (created).
- `e2e/tests/smoke.spec.ts` – Smoke-subset tests with critical element assertions (completed).
- `e2e/tests/non-smoke.spec.ts` – Test file to verify @smoke tag filtering (created).
- `test/unit/scaffolding.spec.ts` – Unit test for E2E command scaffolding (moved from e2e/tests/).
- `test/unit/server.test.ts` – Unit test for server management helper (created).
- `package.json` – Added npm scripts `e2e` and `e2e:smoke` (modified).
- `e2e/helpers/server.ts` – Utility to start/stop the skeleton dev server programmatically (completed with real implementation).
- `e2e/tests/product-flow.spec.ts` – Product journey tests (completed, updated to use page objects).
- `e2e/page-objects/storefront.ts` – Page object classes for Storefront, Product, Cart, and Collection pages (created).
- `e2e/tests/cart-flow.spec.ts` – Cart journey tests (completed - adds item, updates quantity, removes item, verifies empty state).
- `e2e/tests/collection-flow.spec.ts` – Collection journey tests (completed - navigates to collection, verifies grid, checks products have titles/prices).
- `.github/workflows/e2e.yml` – GitHub Actions workflow to run the suite in CI (to be created).
- `docs/tasks/tasks-prd-e2e-playwright-tests.md` – This task list.

### Notes

- Follow outside-in TDD: write each failing Playwright test before implementing supporting helpers or configuration.
- Safe iteration: one failing test at a time; minimal code to pass.
- Verification: run `npm run e2e:smoke` for quick feedback, `npm run e2e` for the full suite.
- CI: the Github Actions workflow must block merges on failures and upload Playwright reports.
- Flake control: implement retries and trace capture on second failure.
- Extensibility: keep server URL and auth flags configurable via environment variables.

### Environment Setup Reminders

**Before starting any E2E work:**
1. Ensure you're in the project root directory (not in templates/skeleton/)
2. Run `npm install` in both project root AND templates/skeleton/
3. Verify Playwright browsers are installed with `npx playwright install`
4. Check that the skeleton server can start manually before automating

**Common Gotchas to Watch For:**
- The skeleton server needs 10-15 seconds to start - don't assume it's broken if it doesn't respond immediately
- Use `npm --prefix <path>` to run npm commands in different directories without changing cwd
- The Shopify CLI hydrogen plugin outputs formatted success messages - parse carefully
- Vitest runs from the current directory - always check `pwd` before running tests
- Background processes need explicit cleanup - use KillBash or process.kill()

### Implementation Learnings

**Test Execution Context:**
- The project uses Vitest as the test runner (not Jest), accessible via `npx vitest run`
- No dedicated `npm run vitest` script exists; use `npx vitest run` directly for unit tests
- The main test script `npm test` runs via Turbo across all packages in parallel
- Pre-commit hooks automatically run prettier on TypeScript files, which may adjust formatting
- Unit tests for scaffolding can use `execSync` from child_process to verify npm script existence

**Project Structure:**
- This is a monorepo with packages/, templates/, and examples/ directories
- The skeleton template is located at templates/skeleton/
- The e2e/ directory should be created at the repository root level
- No existing e2e testing infrastructure was found

**Playwright Installation Notes:**
- Installation via `npm install -D @playwright/test` works smoothly
- Browser installation via `npx playwright install` runs silently (no output when successful)
- You can also install specific browsers: `npx playwright install chromium`
- Node version warnings may appear (undici requires 20.18.1+, project uses 20.12.2) but don't block functionality
- The project has many npm audit vulnerabilities but these don't affect Playwright setup

**Testing Workflow:**
- TDD approach working well: failing test written first, then implementation
- Test failures provide clear error messages showing missing npm scripts
- Use `npx vitest run <test-file>` for focused test runs during development

**Next Steps Considerations:**
- When installing Playwright, ensure compatibility with the existing Node version (.nvmrc specifies the version)
- The project uses npm (not yarn/pnpm) as evidenced by package-lock.json
- Consider how Playwright tests will integrate with the existing Turbo-based test pipeline
- The skeleton template dev server will need to be started programmatically for tests
- Playwright config file will need to be created manually (not auto-generated by install command)

**Future Implementation Reminders:**
- **Smoke Tests (Task 3)**: Will need to import the `startServer()` helper and use it in Playwright's test setup/teardown
- **Page Objects Pattern**: Consider creating reusable page object helpers early to avoid duplication across test files
- **Environment Variables**: The skeleton dev server may need specific env vars (NODE_ENV, etc.) - check what the actual dev command uses
- **Parallel Test Execution**: Since server startup is slow (15+ seconds), consider starting one server for all tests rather than per-test
- **CI Considerations**: GitHub Actions will need the monorepo built before running E2E tests - add build step to workflow
- **Flake Prevention**: Network requests to the dev server might be flaky initially - implement retry logic in test helpers

**Key Implementation Insights (Sessions 1-2):**
- **Test Organization Critical**: Unit tests about the E2E setup (like scaffolding tests) must be kept separate from actual E2E tests. Playwright will try to run anything in the e2e/tests directory as a Playwright test, causing module import errors with Vitest tests.
- **Directory Structure**: Created `test/unit/` for unit tests about the E2E infrastructure, keeping `e2e/tests/` exclusively for Playwright tests
- **Playwright Exit Codes**: Playwright exits with status 1 when no tests are found. Need at least one test file with appropriate tags for commands to succeed.
- **Test Output Matching**: Playwright's actual output format differs from what might be expected. The HTML report message is "To open last HTML report run:" not "Playwright HTML report". Tests should match actual output.
- **Minimal Implementation Works**: Creating a placeholder test with just the `@smoke` tag was sufficient to make the scaffolding test pass, following TDD principles
- **Configuration Location**: `playwright.config.ts` must be at repository root, not in the e2e/ directory
- **HTML Report Path**: Playwright generates reports in `playwright-report/` directory by default, which the scaffolding test verifies exists

**Server Implementation Insights (Sessions 2-3):**
- **Stub Before Real Implementation**: Successfully used a mock HTTP server with child process stub to pass tests before implementing real skeleton server startup
- **Mock Server Pattern**: Using Node's built-in `http.createServer` for stub implementation provides a lightweight way to test server lifecycle without external dependencies
- **Port 0 Strategy**: Listening on port 0 lets the OS assign an available port, avoiding conflicts in parallel test runs
- **Cleanup Critical**: Server stop function must properly close HTTP server AND kill child process to avoid orphaned resources
- **Test Isolation**: Each test should get its own server instance - no shared state between tests

**Real Server Implementation Learnings (Session 3):**
- **Working Directory Matters**: Always verify your current working directory with `pwd` before running commands - the skeleton template may be in a different location than expected
- **Port Passing Method**: Use `npm run dev -- --port <port>` format to pass CLI arguments through npm scripts to the underlying command
- **Server Startup Time**: Real skeleton dev server takes 10-15 seconds to start - tests need generous timeouts (90+ seconds) to avoid false failures
- **Dependencies First**: Always ensure `npm install` has been run in the skeleton template directory before attempting to start the server
- **Process Management**: Use `execa` with `reject: false` to prevent automatic rejection on non-zero exits, allowing graceful error handling
- **Readiness Check**: Don't just wait for the process to spawn - poll for HTTP 200 response to ensure the server is actually ready to handle requests
- **Shell Limitations**: The test environment's shell may not support `cd` in eval context - use absolute paths or `npm --prefix` instead
- **Background Process Testing**: Use the `run_in_background` flag for manual testing, then check output with BashOutput tool to debug server startup issues
- **Test Cleanup**: Always clean up servers in `afterEach` hooks to prevent port conflicts and orphaned processes between tests
- **Path Resolution**: Use `path.resolve(__dirname, '../../templates/skeleton')` to reliably find the skeleton template from the helper file location

**Session 4 - Critical Build Dependencies:**
- **Monorepo Build Required**: The skeleton template depends on built packages from the monorepo. Must run `npm run build` at the project root before the skeleton dev server can start
- **Missing Dependencies**: When tests fail with module import errors, check if dependencies like `execa` and `get-port` need to be installed at the project root level
- **Vitest Version**: The project uses Vitest v1.0.4 in the monorepo. Running `npx vitest` may install a different version locally - be aware of version differences
- **Shell Context Reset**: Some commands reset the shell's working directory. Always verify location after complex operations
- **Process Verification**: After implementing teardown, always verify with `ps aux | grep` that no orphaned processes remain
- **Test Execution Location**: Run tests from the project root, not from within subdirectories like templates/skeleton/, to ensure proper module resolution

### Session 5 - Additional Implementation Learnings:

**TypeScript Module Verification Challenges:**
- TypeScript files (`.ts`) cannot be directly required/imported in Node.js without compilation
- For verification scripts, use Vitest test files instead of standalone scripts - they handle TypeScript natively
- Alternative runners like `tsx` or `ts-node` may have compatibility issues with the project's module system
- When verifying TypeScript modules, create temporary test files rather than standalone scripts

**Test File Locations Matter:**
- Unit tests about E2E infrastructure MUST go in `test/unit/` directory
- Actual E2E Playwright tests go in `e2e/tests/` directory  
- Mixing test types causes module resolution errors
- The test file location was correctly moved from `e2e/helpers/server.test.ts` to `test/unit/server.test.ts`

**Server Lifecycle Verification Best Practices:**
- Always verify server stops responding after calling `stop()` - not just that the function completes
- Use `AbortSignal.timeout()` when testing server unavailability to avoid hanging tests
- Add stability checks (wait a few seconds) to ensure server isn't just slow to start
- Server tests take significant time (~20-30 seconds each) - plan for longer test execution

**Vitest Command Patterns:**
- Use `npx vitest run <file>` for specific test files
- No need for npm scripts - vitest can be invoked directly via npx
- Test timeouts should be generous for server operations (90-120 seconds)
- Console output from tests is preserved and visible, helpful for debugging

### Critical Success Patterns for Future Work:

**TDD Workflow That Actually Works:**
1. Write the failing test first (really, don't skip this)
2. Run the test to see the exact failure message
3. Implement just enough to make it pass
4. Verify the test passes
5. Only then move to the next subtask

**When Things Don't Work as Expected:**
- Check file locations first - many issues are path-related
- Verify dependencies are installed at the correct level (root vs subdirectory)
- Run commands manually to see actual output before writing tests that check output
- Use background processes with BashOutput tool to debug long-running commands
- Always check current working directory with `pwd` when path issues occur

**Integration Points to Remember:**
- Playwright tests will import the server helper from `e2e/helpers/server.ts`
- The skeleton template is at `templates/skeleton/` relative to project root
- The monorepo must be built (`npm run build`) before the skeleton server can start
- All E2E assets go in `/e2e` directory at repository root
- Configuration files like `playwright.config.ts` must be at repository root

**Time Expectations:**
- Server startup: 10-15 seconds
- Individual server tests: 20-30 seconds
- Full smoke test suite target: <60 seconds
- Full E2E suite target: ≤15 minutes

### Session 6 - Playwright E2E Test Implementation Learnings:

**ESM Module Compatibility Critical:**
- Playwright tests run in a hybrid CommonJS/ESM environment
- Modern packages like `execa` v9+ and `get-port` v7+ are ESM-only
- Solution: Use dynamic imports `await import('module')` instead of static imports in helper files
- This issue manifests as "require() of ES Module not supported" errors
- Always check package versions - newer versions often switch to ESM-only

**Playwright Test Structure Best Practices:**
- Use `test.beforeAll`/`test.afterAll` for expensive operations like server startup
- Starting the dev server for each test would add 10-15 seconds per test - avoid this
- Set generous timeouts (90+ seconds) for server startup operations
- The default Playwright timeout is too short for dev server initialization

**Test Verification Strategy:**
- When following TDD, if a test passes when you expect it to fail, verify it's actually testing the right thing
- Temporarily break assertions to confirm tests can detect failures
- Add temporary console.log statements to debug what the test is seeing
- Remove debug code once test behavior is confirmed

**Server Helper Dynamic Import Pattern:**
```typescript
// Instead of: import {execa} from 'execa';
// Use: const {execa} = await import('execa');
// Instead of: import getPort from 'get-port';  
// Use: const getPort = (await import('get-port')).default;
```

**Playwright Console Monitoring:**
- Use `page.on('console', callback)` to capture browser console output
- Check `msg.type()` for 'error', 'warning', 'log', etc.
- Store messages in arrays for later assertion
- This is crucial for detecting client-side JavaScript errors

**Next Implementation Considerations:**
- For selector assertions (3.2), first manually inspect the running app to identify actual selectors
- Consider using Playwright's codegen tool: `npx playwright codegen http://localhost:3000`
- The skeleton template likely uses specific class names or data attributes for key elements
- May need to wait for elements to be visible before asserting their presence
- Use Playwright's built-in waiting mechanisms rather than arbitrary delays

**General Debugging Patterns for E2E Tests:**
- HTML reports are automatically generated in `playwright-report/` directory
- Use `npx playwright show-report` to view detailed test results and screenshots
- Playwright captures screenshots on failure automatically (configured in playwright.config.ts)
- When tests hang, check if the server actually started - look for process output
- Module resolution errors often indicate ESM/CommonJS incompatibility
- If imports fail, check if the package has switched to ESM-only in recent versions
- Always verify the test can fail before assuming it works correctly

### Session 7 - Selector Strategy and Test Organization Learnings:

**HTML Inspection Strategy:**
- Use `curl -s http://localhost:<port>/ | head -200` to quickly inspect page HTML structure
- Start the dev server manually on a different port to inspect while tests are being written
- The skeleton template uses semantic HTML with clear class names which makes selector writing easier
- Key elements found: `.featured-collection-image img`, `a[href="/account"]`, `a[href="/cart"]`

**Playwright Selector Best Practices:**
- Prefer semantic selectors over fragile ones: `a[href="/account"]` over `nav > a:nth-child(2)`
- Use `:has-text()` pseudo-selector for buttons with specific text: `button[type="submit"]:has-text("Add to cart")`
- Always use `.first()` when multiple elements match to avoid ambiguity
- For dynamic content, navigate to the page first before asserting (e.g., product page for "Add to cart")

**Test Tagging and Organization:**
- The `@smoke` tag goes directly in the test name string, not as a separate annotation
- Verify tag filtering works by creating a non-tagged test and using `--list` flag
- `npm run e2e:smoke -- --list` is invaluable for debugging which tests will run
- Keep test files focused: smoke tests separate from full feature tests

**Performance Observations:**
- Smoke tests with server startup complete in ~7-8 seconds total
- Most time is spent on server initialization (first 5-6 seconds)
- Actual test execution is very fast (<2 seconds) once server is ready
- Server startup time is consistent across runs, good for CI predictability

**Debugging Shortcuts:**
- `npm run e2e:smoke -- --list` to verify which tests match the grep pattern
- `time npm run e2e:smoke` to measure actual execution time including npm overhead
- Background process management: Start server with `run_in_background: true`, then use `BashOutput` to monitor
- Always `KillBash` background processes when done to avoid port conflicts

**Task Completion Patterns:**
- Sub-tasks 3.3 and 3.4 were essentially already done by earlier work - recognize when work overlaps
- The @smoke tag was added in 3.1, not 3.3 - implementation often naturally covers multiple requirements
- When a test passes immediately after adding assertions, double-check they're actually running
- Create deliberate test variations (like non-smoke.spec.ts) to verify configuration works

**Future Test Implementation Tips:**
- For product/cart/collection flows (Task 4), consider starting all tests with the server already running
- Page object pattern will be crucial to avoid selector duplication across test files
- Consider data-testid attributes if selectors become too fragile
- Mock the GraphQL responses for faster, more reliable tests in CI
- Keep an eye on test execution time - parallelize where possible

### Session 8 - Product Flow Implementation Learnings:

**TDD Expectations vs Reality:**
- Sometimes tests pass immediately when you expect them to fail - this is OK if the functionality already exists
- Always verify tests can detect failures by temporarily breaking assertions
- The skeleton template has more functionality implemented than initially expected
- Product navigation, price display, and cart functionality work out of the box

**HTML Structure Discovery Patterns:**
- Use `curl -s http://localhost:<port>/ | grep -A 10 -B 10 "keyword"` to quickly inspect HTML structure
- Start a dev server on a different port for manual inspection while writing tests
- The skeleton uses semantic HTML which makes selector writing easier
- Key product elements: `.recommended-products-grid`, `.product-item`, product URLs like `/products/sweatpants`

**Selector Strategy for Product Pages:**
- Products are in `.recommended-products-grid a.product-item` on homepage
- Product titles are in `h1` tags on product pages
- Prices can be in various elements - use flexible selectors like `span:has-text("$")`
- Add to cart buttons are `button[type="submit"]:has-text("Add to cart")`
- Cart updates can be detected via drawer visibility or cart link text changes

**Cart Interaction Patterns:**
- Cart drawer is an `aside` element with "CART" text
- Cart link shows count like "Cart 0" or "Cart 1"
- After adding to cart, either drawer opens OR cart count updates
- Use flexible assertions to handle both behaviors
- Allow 1-2 seconds for cart state to update after actions

**Test Execution Insights:**
- Product flow tests take 10-15 seconds (mostly server startup)
- Once server is running, navigation and assertions are fast (<5 seconds)
- Network idle is a good wait condition for product page loads
- The mock shop data is stable and predictable for testing

**Common Pitfalls to Avoid:**
- Don't assume selector structures - always inspect actual HTML first
- Cart updates may not be instant - add appropriate waits
- Some elements may have multiple valid selectors - use the most stable one
- Test both positive and negative cases to ensure assertions work

### Session 9 - Page Object Implementation Learnings:

**Page Object Pattern Critical Success Factors:**
- **Base URL Management**: Page objects need a base URL passed in constructor - don't rely on page.url() which may be about:blank initially
- **Selector Flexibility**: Use multiple selector alternatives in locators (e.g., `.product-price, div:has-text("$"), span:has-text("$")`) because HTML structure varies
- **Inheritance Structure**: Create a base StorefrontPage class with common elements, then extend it for specific page types
- **Factory Function**: Use a `createPageObjects()` factory that instantiates all page objects with the same base URL for consistency

**HTML Structure Discovery Process:**
- **Manual Inspection First**: Always run dev server and use `curl` to inspect HTML before writing selectors
- **Price Element Gotcha**: Prices might be in `<div>` not `<span>` - the skeleton uses `<div class="product-price"><div>$26.00</div></div>`
- **Background Process Management**: Use `run_in_background: true` for dev servers during development, but remember to KillBash when done
- **Port Conflicts**: Always kill background processes to avoid "address already in use" errors

**Playwright Test Timeout Management:**
- **Long Timeouts Needed**: Server startup operations need 90+ second timeouts, not the default 30 seconds
- **Test Hanging**: If tests timeout at 2 minutes exactly, it's likely the npm run command timeout, not Playwright's timeout
- **Error Messages**: "net::ERR_CONNECTION_REFUSED" usually means the server didn't start or wrong URL is being used

**Directory Context Issues:**
- **Shell Context**: Commands like `cd templates/skeleton && npm run dev` work better than `npm --prefix` when the CLI expects to be in project root
- **Hydrogen CLI Expectations**: The Shopify Hydrogen CLI checks if you're in a Hydrogen project directory - run from skeleton dir
- **Background Process Context**: Background processes inherit the shell's working directory at launch time

**Page Object Method Design:**
- **Async Everything**: All page object methods should be async, even simple getters, for consistency
- **Wait Helpers**: Include wait methods like `waitForCartUpdate()` with reasonable timeouts built in
- **Return Types**: Be explicit about return types (Promise<string>, Promise<number>, etc.) for better TypeScript support
- **Flexible Navigation**: Support both full URLs and paths in goto() methods for versatility

**Testing With Page Objects:**
- **Import Strategy**: Update existing tests to use page objects incrementally - verify each works before moving on
- **Locator Access**: Expose locators as readonly properties so tests can still use Playwright's expect() assertions
- **Method Granularity**: Create both low-level (click button) and high-level (complete purchase) methods
- **State Verification**: Include helper methods to check state (isCartEmpty, getCartCount, etc.)

### Critical Gotchas to Remember:

**Environment Setup:**
- **ALWAYS** run `npm run build` at project root before starting E2E tests
- **ALWAYS** ensure `npm install` has been run in both root AND templates/skeleton
- The skeleton dev server takes 10-15 seconds to start - don't assume it's broken

**Selector Strategies:**
- HTML structure varies between pages - always inspect actual HTML before writing selectors
- Prices might be in div, span, or small elements - use flexible selectors with filters
- Product titles might be h1, h2, h3, or h4 - check the actual page structure
- Use `curl -s http://localhost:PORT/path | grep -A 5 -B 5 "keyword"` for quick HTML inspection

**Test Execution:**
- Server startup in beforeAll hooks needs 90+ second timeout, not default 30
- Background processes must be killed to avoid port conflicts
- The Hydrogen CLI expects to run from within the project directory
- All 7 current tests pass in ~22 seconds with parallel execution

**Page Object Patterns:**
- Keep the `page` property public for direct Playwright access when needed
- Use multiple selector alternatives in locators for robustness
- Always pass baseUrl to page objects - don't rely on page.url()
- Include both low-level and high-level methods for flexibility

### Future Task Considerations (Tasks 4.5-8):

**For Task 4.5 (Test helpers and fixes):**
- All individual tests are passing - may just need to verify they work together
- Consider adding a test helper for clearing cart state between test files
- May want to add wait utilities for common operations (cart updates, navigation)

**For Task 4.6 (Full suite verification):**
- Current execution time is ~22 seconds for 7 tests - well under 15-minute target
- Parallel execution with 5 workers is working without issues
- May want to add a timer utility to track individual test execution times

**For Task 5 (Retry and flake control):**
- No flakiness observed yet, but cart operations might benefit from retries
- Screenshot capture on failure is already configured in playwright.config.ts
- Cookie/localStorage clearing might be needed between test files (not just tests)

**For Task 6 (GitHub Actions):**
- Remember to build the monorepo first (`npm run build`) before running E2E tests
- Playwright browser installation will be needed in CI
- Consider caching node_modules and Playwright browsers for faster CI runs

**For Task 7 (Extensibility hooks):**
- Store URL is currently hardcoded in server.ts - make it configurable via env var
- Customer Account tests will need different auth setup than current mock shop

**For Task 8 (Documentation):**
- Document the need to run `npm install` in both root and templates/skeleton
- Explain the server startup time (10-15 seconds) to set expectations
- Include troubleshooting for common port conflicts

### Session 11 - Collection Flow Implementation Learnings:

**Selector Precision for Collection Pages:**
- **Price Selector Evolution**: Collection page prices are in `<small><div>$19.00</div></small>` structure, not just in spans
- **Multiple Selector Alternatives Work**: Using `.locator('[data-test="product-price"], .price, small div, div').filter({hasText: '$'})` provides flexibility
- **Always Inspect HTML First**: Running a dev server on a separate port for HTML inspection saves debugging time
- **Product Grid Structure**: The skeleton uses `.products-grid` with `.product-item` links containing h4 titles and small/div prices

**Test Organization Insights:**
- **TDD Sometimes Shows Tests Pass Immediately**: When functionality already exists (like collection pages), tests may pass on first run - this is OK
- **Verify Failure Modes**: Even when tests pass, temporarily break assertions to ensure they can detect failures
- **Multiple Collection Handles**: Testing different handles ('all', 'frontpage', 'automated-collection') reveals which have products in mock data

**Performance Observations:**
- **All Tests Run Fast**: Full suite of 7 tests completes in ~22 seconds, well under 15-minute target
- **Parallel Execution Works**: Playwright successfully runs 5 workers in parallel without conflicts
- **Server Startup Dominates Time**: Most test time is server initialization, actual test execution is very fast

**Background Process Management:**
- **Shell Context Matters**: Use `cd templates/skeleton && npm run dev` instead of `npm --prefix` when Hydrogen CLI expects to be in project directory
- **Always Kill Background Processes**: Orphaned dev servers cause port conflicts - always use KillBash after inspection
- **Background Output Monitoring**: The BashOutput tool helps debug server startup issues without blocking test execution

### Session 10 - Cart Flow Implementation Critical Learnings:

**Selector Debugging is 90% of E2E Test Work:**
- **Product Title Gotcha**: The h1 selector can pick up titles from homepage featured collections instead of product pages - use more specific selectors like `.product-main h1`
- **Cart Item Count Trap**: Generic selectors like `.cart-details li` will pick up ALL li elements including size/color option lists - use specific class selectors like `li.cart-line`
- **Dynamic Content Timing**: Always wait for URL changes with `waitForURL(/pattern/)` after navigation to ensure you're on the right page before getting text
- **Text Content Apostrophes**: Watch out for smart quotes vs regular apostrophes in text assertions - use partial matches to avoid encoding issues

**Cart Drawer Interaction Patterns:**
- **Modal Overlays Block Clicks**: Cart drawers often intercept clicks - either close them first or navigate directly to `/cart` page
- **Drawer State Management**: After add-to-cart, the drawer may or may not open automatically - check visibility before trying to interact
- **Post-Action Waits Essential**: Cart operations (add, update quantity, remove) need 1-2 second waits for server updates to complete

**Quantity and Price Handling:**
- **Quantity Display Varies**: Cart quantity might be in input fields OR displayed as text like "Quantity: 1" - check actual HTML structure
- **Subtotal Location**: Subtotal can be in various elements (dd, strong, div) - use multiple selector alternatives
- **Price Parsing**: Extract numeric values with regex like `parseFloat(price.replace(/[^0-9.]/g, ''))` for mathematical comparisons

**Remove Button Complexity:**
- **Multiple Remove Buttons**: Page may have remove buttons for discounts, gift cards, AND cart items - be very specific with selectors
- **Form Submission vs Click**: Remove might be a form submission not just a button click - check actual implementation
- **Cart Closure After Remove**: Removing last item often closes the cart drawer - may need to reopen to check empty state

**Empty Cart State Detection:**
- **Message Text Varies**: Empty cart messages differ between implementations - use partial text matches
- **Hidden vs Removed**: Empty cart UI might be hidden (display:none) rather than removed from DOM - check visibility not just existence
- **Drawer vs Page**: Empty cart UI might look different in drawer vs full cart page

**Page Object Design Insights:**
- **Expose Page Instance**: Keep `page` as public property on page objects for direct Playwright access when needed
- **Wait Helpers**: Build wait methods into page objects (waitForCartUpdate, waitForNavigation) with reasonable timeouts
- **Flexible Locators**: Use multiple selector alternatives in a single locator for robustness
- **Method Granularity**: Both low-level (click button) and high-level (complete purchase) methods are useful

**Test Stability Techniques:**
- **Generous Timeouts**: Server operations need 90+ second timeouts, not default 30 seconds
- **Explicit Waits Over Sleep**: Use `waitForSelector`, `waitForURL`, `waitForLoadState` instead of arbitrary timeouts where possible
- **State Cleanup**: Cart state persists between tests - always verify clean state at test start
- **Debug First**: When tests fail mysteriously, add console.log to see actual values before writing assertions

**Common Pitfalls That Waste Time:**
- Assuming selector will find the right element without checking actual HTML
- Not waiting for navigation/updates to complete before assertions
- Using overly generic selectors that match multiple elements
- Forgetting that cart operations are async and need wait time
- Not checking if modal/drawer is blocking interactions

**Critical Playwright Config Settings:**
- **HTML Report Auto-Open**: Set `open: 'never'` in reporter config to prevent browser tabs opening after every test run
- **Test Timeout**: Default 30s is too short for server operations - set generous timeouts in beforeAll/afterAll hooks
- **Screenshot on Failure**: Already configured but remember screenshots are invaluable for debugging E2E failures

**Debugging Workflow That Actually Works:**
1. Start dev server manually on different port for inspection
2. Use curl to inspect HTML structure and understand selectors
3. Add console.log to see actual values before writing assertions
4. Check screenshots when tests fail to understand page state
5. Use `npx playwright show-report` only when you need detailed failure analysis

**Future Considerations for Cart and Collection Tests:**
- **Cart State**: Cart may persist between tests - always clear/reset cart state in beforeEach or afterEach hooks
- **Dynamic Content**: Product grids and cart items are dynamic - use flexible selectors and count-based assertions
- **GraphQL Timing**: Cart operations involve GraphQL mutations - add appropriate waits after actions
- **Collection Navigation**: Collections may have pagination or infinite scroll - account for this in page objects
- **Variant Selection**: Products have size/color variants - page objects should handle variant selection before add to cart

## Tasks

- [x] 1. Add Playwright and command scaffolding

  - [x] 1.1. Write a failing unit test (`e2e/tests/scaffolding.spec.ts`) asserting that the command `npm run e2e:smoke` exits with status 0 and prints the Playwright HTML report path.

  - [x] 1.2. Add Playwright as a dev dependency (`npm install -D @playwright/test`) and generate the default configuration via `npx playwright install` (expect the test to remain failing).

  - [x] 1.3. Add npm scripts `e2e` (full) and `e2e:smoke` (subset) in `package.json` that invoke `playwright test` with appropriate tags.

  - [x] 1.4. Run `npm run vitest e2e/tests/scaffolding.spec.ts` and implement minimal script/config changes until the test passes.

  - [x] 1.5. Verify by running `npm run e2e:smoke` locally.

- [x] 2. Implement server management utilities

  - [x] 2.1. Write a failing unit test (`e2e/helpers/server.test.ts`) specifying that `startServer()` resolves with `{port, stop}` and that `GET /` responds 200 within 30 s.
    - **Note**: Based on test organization learnings, this unit test should likely go in `test/unit/` not `e2e/helpers/`

  - [x] 2.2. Stub the skeleton template start command with a mock child process; run the test (should still fail).
    - **Implementation**: Created stub server with mock HTTP server and child process in `e2e/helpers/server.ts` that passes all tests

  - [x] 2.3. Implement `startServer()` in `e2e/helpers/server.ts` using `get-port` and `execa`, returning an async `stop()` handler.
    - **Implementation**: Successfully replaced stub with real implementation using get-port for port selection and execa for process management. Server starts skeleton template on available port and waits for HTTP 200 readiness.

  - [x] 2.4. Ensure the helper tears down the process after tests to avoid orphaned ports.
    - **Verification**: The existing implementation already includes proper teardown in the `stop` function that kills the server process with SIGTERM/SIGKILL. Tests have `afterEach` hooks that call `stop()`. Verified no orphaned processes remain after running tests.

  - [x] 2.5. Run `npm run vitest e2e/helpers/server.test.ts` until all assertions pass.
    - **Completed**: Tests run successfully from `test/unit/server.test.ts` - all 3 tests pass in ~21 seconds

  - [x] 2.6. Verify by importing `startServer()` in a scratch script and confirming the server lifecycle.
    - **Completed**: Created and ran verification test confirming full server lifecycle (start, respond, stop, no longer accessible)

- [x] 3. Create smoke subset tests

  - [x] 3.1. Write a failing Playwright test (`e2e/tests/smoke.spec.ts`) that launches the dev server via the helper, navigates to `/`, and asserts no console errors.
    - **Implementation**: Successfully replaced placeholder test with real test that starts server, navigates to homepage, and verifies no console errors
    - **ESM Issue Fixed**: Had to update server.ts to use dynamic imports for `execa` and `get-port` since they are ESM-only modules
    - **Test Structure**: Used `test.beforeAll` and `test.afterAll` hooks for server lifecycle management with 90-second timeout
    - **Verification**: Test correctly passes when no console errors exist and fails when expecting errors that don't exist

  - [x] 3.2. Add selectors assertions: hero image, "Add to cart" button, login link, cart icon.
    - **Implementation**: Added assertions for all required elements based on actual HTML structure
    - **Selectors Used**: `.featured-collection-image img` for hero, `a[href="/account"]` for login, `a[href="/cart"]` for cart, `button[type="submit"]:has-text("Add to cart")` for add to cart
    - **Note**: Add to cart button requires navigation to a product page first

  - [x] 3.3. Tag the test with `@smoke` and ensure `npm run e2e:smoke` only executes these.
    - **Verification**: Test already had `@smoke` tag from 3.1 implementation
    - **Confirmed**: Created non-smoke test file to verify filtering works - `npm run e2e:smoke` only runs tagged tests

  - [x] 3.4. Implement minimal page fixes or selector utilities until the test passes.
    - **Result**: No fixes needed - all selectors worked correctly on first implementation

  - [x] 3.5. Verify by running `npm run e2e:smoke` locally (<60 s).
    - **Result**: Smoke tests complete in ~7.7 seconds, well under 60-second target

- [ ] 4. Implement full test suite (product, cart, collection flows)

  - [x] 4.1. Write failing `product-flow.spec.ts` covering navigate to product, assert title/price, add to cart.
    - **Implementation**: Created test that navigates to first product from recommended products grid
    - **Assertions**: Verifies product title, price format, and add to cart functionality
    - **Result**: Test passes, indicating skeleton template already has necessary functionality

  - [x] 4.2. Implement page object helpers (`e2e/page-objects/storefront.ts`) for common interactions.
    - **Implementation**: Created comprehensive page object classes for Storefront, Product, Cart, and Collection pages
    - **Features**: Base URL handling, common locators, reusable methods for navigation and assertions
    - **Usage**: Updated product-flow.spec.ts to use page objects, making tests more maintainable
    - **Verification**: Product flow test passes using page objects

  - [x] 4.3. Write failing `cart-flow.spec.ts` to open cart, update quantity, assert subtotal, remove item.

  - [x] 4.4. Write failing `collection-flow.spec.ts` to verify grid renders expected products.

  - [ ] 4.5. Implement test helpers and minimal fixes until each spec passes individually.

  - [ ] 4.6. Verify by running `npm run e2e` (≤15 min total).

- [ ] 5. Add retry and flake-control mechanisms

  - [ ] 5.1. Write a failing unit test asserting Playwright config has `retries: 1` for CI runs.

  - [ ] 5.2. Update `playwright.config.ts` to conditionally set retries and enable trace/screenshot on last retry.

  - [ ] 5.3. Implement cookie/localStorage clearing utility and integrate via `globalSetup`.

  - [ ] 5.4. Verify by intentionally failing a test and confirming retries & artifacts.

- [ ] 6. Integrate with GitHub Actions workflow

  - [ ] 6.1. Write a failing expect test (`.github/workflows/e2e.yml.test.ts`) that lints workflow YAML for required steps (`actions/setup-node`, browser install, `npm run e2e`).

  - [ ] 6.2. Add workflow file `.github/workflows/e2e.yml` using Playwright’s recommended template.

  - [ ] 6.3. Commit and push branch to trigger CI; ensure workflow blocks on failures and uploads reports.

  - [ ] 6.4. Verify by pushing a deliberate test failure and ensuring the workflow exits 1.

- [ ] 7. Scaffold extensibility hooks and skipped Customer Account API tests

  - [ ] 7.1. Create config helper to inject `STORE_URL` and other env vars.

  - [ ] 7.2. Add placeholder test `e2e/tests/customer-account.spec.ts` wrapped in `test.skip` gated by `process.env.SHOPIFY_HYDROGEN_FLAG_CUSTOMER_ACCOUNT_PUSH`.

  - [ ] 7.3. Document how to enable the flag and extend tests for real stores.

  - [ ] 7.4. Verify by running `npm run e2e` and ensuring skipped test counts appear.

- [ ] 8. Write documentation and onboarding instructions

  - [ ] 8.1. Update root `README.md` with E2E setup and troubleshooting section.

  - [ ] 8.2. Create `docs/e2e-playwright.md` detailing commands, environment variables, CI behaviour.

  - [ ] 8.3. Verify by having a new contributor run through the docs and successfully execute `npm run e2e`.

### AI Implementation Guidelines

Follow Outside-In TDD strictly:
1. Always write the failing test first.
2. Run the test to confirm it fails (and verify the failure is what you expect).
3. Write minimal code to pass.
4. Re-run the test to confirm it passes.
5. Proceed to the next behaviour.

**Practical TDD Tips:**
- When a test fails unexpectedly, run the command being tested manually to see actual output
- Don't assume output format - always verify actual command output first
- Keep unit tests about the infrastructure separate from actual E2E tests
- Placeholder implementations are fine for making tests pass initially

**Critical Debugging Patterns:**
- **Test Timeouts**: If tests timeout, first increase timeout to 90+ seconds, then debug the actual command
- **Path Issues**: Use absolute paths when relative paths fail, especially with npm commands
- **Process Debugging**: Run commands in background mode first to see actual output before implementing
- **Port Conflicts**: Always use dynamic port allocation (get-port) rather than hardcoded ports
- **Dependency Installation**: Check that `npm install` has been run in all necessary directories
- **Error Visibility**: Use `stdio: 'pipe'` to capture process output for debugging, not 'inherit'
- **Cleanup Pattern**: Store server references at test suite level and clean up in afterEach hooks

Safe Iteration Pattern:
- Ask the human to run tests after each implementation.
- Debug failing tests before changing code.
- Commit only when all tests pass.

Verification Step Protocol:
- Run the verification command at the end of each parent task.
- If verification fails, fix sub-tasks before marking complete.

External Service Integration:
- Stub network calls with Playwright’s route interception when needed.

When in Doubt:
- Prioritise passing tests over new features.
- Keep implementations simple.
